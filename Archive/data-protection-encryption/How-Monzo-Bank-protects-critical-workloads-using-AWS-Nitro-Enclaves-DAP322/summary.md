# AWS re:Inforce 2025 - How Monzo Bank protects critical workloads using AWS Nitro Enclaves (DAP322)

**Video Link:** [Watch on YouTube](https://www.youtube.com/watch?v=xxDy1cFAvHA)

## Video Information
- **Author:** AWS Events
- **Duration:** 15.7 minutes
- **Word Count:** 3,087 words
- **Publish Date:** 20250620
- **Video ID:** xxDy1cFAvHA

## Summary
In this session, security infrastructure engineers from Monzo Bank explain how they use AWS Nitro Enclaves to protect sensitive workloads like cryptographic key ceremonies and multi-party authentication systems. The talk covers the security challenges they faced, such as the operational burden of air-gapped laptops and the lack of cryptographic attestation in EC2 instances, and how Nitro Enclaves offered a high-assurance, tamper-proof execution environment. They also developed a reproducible build system to ensure enclave integrity, avoid insider threats, and establish trust in enclave-based operations. Real-world examples, including key generation and credential brokering, highlight Monzo's use of attestation, encryption in use, and minimal-visibility principles to safeguard critical secrets.

## Key Points
- **Use Cases at Monzo**:
  - **Key ceremonies**: Generating and handling private keys securely, with zero visibility.
  - **Multi-party authentication / Just-in-Time access**: Engineers request elevated credentials that are granted temporarily inside enclaves.

- **Challenges and Tradeoffs**:
  - Air-gapped laptops: High control but poor scalability and operational burden.
  - EC2 instances: Scalable but lack cryptographic assurance and are vulnerable to privileged access.
  - HSMs: Secure but inflexible—limited cryptographic primitives.

- **Nitro Enclaves Benefits**:
  - Isolated compute environments with no access even by EC2 root.
  - Attestation via PCR (Platform Configuration Registers) to verify enclave integrity.
  - Integration with AWS KMS key policies to restrict key access to specific enclave measurements.

- **Security Hardening**:
  - **Reproducible Builds**: Avoid single-employee weakness by building enclave images twice (CI + human verification).
  - Prevents insiders from inserting malicious enclave code and matching PCRs.
  - Enables detection of supply chain risks and increases build confidence.

- **Real-World Key Ceremony Workflow**:
  - Code is peer-reviewed and built reproducibly.
  - Private key is generated inside the enclave and immediately encrypted with Vault’s public key.
  - Private key is never visible—zero-visibility guarantee.
  - Outputs (e.g., CSR) are signed and verified using enclave attestation.

- **Just-in-Time Access Workflow**:
  - Engineer requests temporary elevated permissions.
  - Approval is mediated through the enclave.
  - Credentials are short-lived (via STS) and can only be generated by the enclave.
  - Eliminates persistent admin access and reduces blast radius of compromise.

## Technical Details
- **Nitro Enclave Attestation**:
  - PCRs provide immutable measurements of the enclave image.
  - Attestation reports can be signed to validate runtime integrity and provenance.

- **KMS Key Policy Integration**:
  - KMS keys are restricted to enclaves with specific PCR measurements.
  - Any change (e.g., new env var, code change) alters the PCR, breaking access.

- **Reproducible Enclave Builds**:
  - Built a custom enclave builder (not Nitro CLI) to ensure byte-identical outputs.
  - Publicly available via GitHub.
  - Enables detection of discrepancies, unauthorized changes, and dependency risks.

- **Lessons Learned**:
  - Documentation is insufficient—read source code and understand actual trust boundaries.
  - Reproducible builds provide provenance without needing secure signing infrastructure.
  - A trusted enclave framework can be a reusable security primitive across multiple applications.

- **Outputs and Verification**:
  - Attested outputs (e.g., keys, credentials) offer cryptographic proof of integrity.
  - Encrypted secrets remain unreadable outside the enclave.
  - All secrets flow only between trusted components (enclave ↔ Vault/KMS).

- **Open Source**:
  - Monzo’s reproducible enclave build framework is open-sourced and available on GitHub.

## Full Transcript

Cool. Good morning. And uh yeah, thank you for coming to our talk. Uh, we're from Monzo Bank and we'll be talking today about how nitro enclaves have helped us secure our security critical workloads. My name is Greg, and this is hello, I am Nico. We're both security infrastructure engineers at Monzo. Yeah. Uh, yeah, so today we're gonna be talking a bit about the problem that we're trying to solve. Uh, uh, we look at some of the considerations that we, uh, weighed up before deciding to go with enclaves. Um, yeah, how we actually implemented it and then some lessons learned from this journey. So what is Monzo? Monzo is a UK bank. Uh, we are a digital first bank, which means that we do not have any branches. Uh, customers interact with us through the mobile app, and we work towards having customers be able to self-serve themselves. Uh, we've experienced rapid growth and we are at roughly 12 million customers. For the UK, that means about 1 in 4 adults bank with Monzo. Uh, we're also known as a disruptive bank and part of our self-serve mentality, we want our engineers to be able to self-serve themselves as well. So we have two use cases that we want to talk about today. The first use case is key ceremonies. Key ceremonies is where we want to run some custom code to deal with highly sensitive material. We might be generating private keys, we might be decrypting sensitive information, but the material we're working with is very confidential and we want to be very sure that it is very safe. The other use case we have is multi-party authentication or just in time access. We've built a solution that allows engineers to request access for privileged uh credentials. We don't want engineers to always have these credentials. We want them to get it just as they needed for the shortest time possible. But because it's broken these credentials, it needs to run in a very safe environment. Both of these use cases. are basically the same problem. We need to run a workload in a very safe environment, in a high assurance place. How do we know that our workload is safe? How do we know that it's tamperproof? It needs to potentially interact with Volt or KMS and it needs to be somewhat dynamic. There isn't just a single solution here. We want to have a bit of flexibility in it. So this is what our problem looks like. Some options that we considered along the way. Uh, the first one we looked at was air gapped laptops or offline laptops. This is a very good option because we have full control over the laptop itself. We can control who has access to it, what it has access to, what it is running. But the problem with it is that it's not very scalable and it is very time consuming to do anything with it. So, very good, not gonna hop a scale. The other option we looked at was just running on EC2 instances. This is a great option because it does scale very well. We can very easily run instances where we need to. But there's no cryptographic guarantee of what actually is running on that instance. And your account admins, perhaps somebody in your team, perhaps somebody in another team may have access to these instances. And if they have access to the instance, they could modify the workload that is running on that instance. And that is something that we did not want for this solution. We also looked at HSMs and cloud HSMs. Um, these are very good at what they do, but they're not very flexible. Uh, they have very few, uh, cryptographic primitives, which means that if you are doing what the HSM does, they are a great solution, but we wanted some flexibility in what we can do. And So that leads us to this. The option we were using before we started developing a solution we're going to show to you is Airap laptops. So that's the first one Greg was showing you. And here is me and a co-worker of mine pushing around the safe which stores one of the Agap laptops we usually use. So there's no laptop inside the safe. Usually the laptops are stored in this safe which requires two people to open them. The safe itself is inside another safe, which itself is in a. Room behind like a key card that only lets certain people open it. The point of this slide is to show you just how much of a like operational pain it is to run A gap laptops for key ceremonies, and this is why we wanted to move to a more cloud-based solution, especially considering Monzo is remote first. So Owen had to take a train from Bristol, my coworker here, in order to help me run this operation. To recap what Greg was talking about, what we need is a space in order to run. Programs that are going to modify key material in use. So we're not encrypting in transit, we're not encrypting at rest, we want to encrypt in use. We want to fill this gap here. So, what we use these I do as nitro enclaves, as you might have guessed from the title of the talk. What nitro enclaves are, a quick recap if you haven't used them before, is a very high assurance, highly isolated VM. Where even the machine managing this VM in our case it's just an easy to instance, it has to be an easy to instance, cannot access the underlying VM once it has started. Not even root can look inside the VM. So that gives us quite a lot of confidence that once something is happening inside the VM, it's not going to leak out unless we take it out. N enclaves. Yeah, can you go to the next slide? So natural enclaves have attestation. Uh, what attestation is is they have this measurement, what do we call a they're called a PCR, which is a measurement that we can make at the enclave before running it. So the VM image we can measure it what the PCR is essentially a hash. Once we're running it, we can still measure it and after running it, we can sign any number of bytes. We can just take a a file and sign it with this at the station. And learn the measurements of the enclave that this was produced inside of. This means that when we're building a program, we can measure it. Once we're running it, we can measure it again, make sure it's the same one. And once we make a key inside, we produce some key material or make a public key we can sign that and measure that, and that gives us confidence that it was made inside the same enclave that we were writing the program for. Additionally, the AWS key Management Service or KMS has a very special relationship with Nitro where we can set a key policy on a KMS key. That says only the enclave with this PCR measurement can access this key. That means that only the enclave that we wrote code for can open that key, and if anyone changes the enclave like add an environment variable, change an if statement or something, the PCR changes, therefore it doesn't match the key policy anymore. Therefore, that enclave cannot read the secret anymore. So that gives us a lot of confidence that only the right program is accessing the right key. So we're done, right? We have our high insurance enclave. We can read all the secrets that we want and we're confident that only that enclave is reading those secrets. Spoiler, we're not done. That's too early. So the problem we were worried about is that the person setting the key policy and the person developing the enclave are actually usually the same person. That means if I am evil and I want to exfiltrate the key from KMS, I can write an enclave that just publishes the this key to the internet, set the PCR measurement of this malicious enclave to be the same as the key policy, and just exfiltrate my key. A malicious employee can compromise this very easily and at Monzo we were quite worried about this and the way we solved it. It was with reproducible bills. So essentially instead of building it once and setting the key policy we just build it twice and measure it twice, and we have two different people do it or CI and another person do it and then have a second human verify this. This gives us a lot of confidence that if the human had changed anything, and had written some evil code to exfiltrate the secret, the other human would see the measurements mismatch, and we would catch this before we actually deploy the enclave, therefore avoiding a single what we call the single employee weakness, which is a single employee can compromise our operation. Turns out building an enclave image twice and getting the exact same image again was quite hard. If you've used NBS nitro enclaves, you know that you use the Nitro CLI to do this. Turns out if you need to build an enclave image twice with this thing, it it's not actually the exact same one again. So NWS just hadn't thought of building this thing twice and getting the exact same result. Um, not only that, but some of the other binaries that went inside we couldn't build from source reproducibly like twice in the same go. Uh, there's actually an article online that's very good, uh, for this is by Trail of Bits. Therefore, we built a framework to basically build enclaves without the nitro CLI so that we could build two enclaves and have them be the exact same. Again, so we built our own reproducible enclave builder. It's worth noting that since we raised these concerns with LWS, they actually have, um, built their own reproducible framework, so you can reproduce like, say the kernel, the kernel module that goes in the enclave yourself, but they have not integrated this into the WSLLI yet. Uh, but if you want to do it reproducibly, you can use our library and they, but they have listened to our feedback. It is now much easier to do this since. What else would you want from reproducible builds? Well, the main benefit in my opinion is that if you're building something twice and you're getting the exact same second time then to do that you must know everything you're using to build it. That means all of the libraries you're using and you're building them from source, you need to have all the sources for this. So you're very confident that you know what's going inside your program and you wanna know because that's the thing that's gonna read your very secret keys. Therefore, if you know everything that's inside your enclave, then you can very easily detect supply chain attacks. You know exactly what libraries they have, what versions they are, and you can very easily check if you have a library you don't like there. Additionally, if you're building something twice and you're building it the exact same way, chances are you're also gonna build it the 3rd and 4th and 5th time successfully, because you're very much in control of the entire environment. So what have we learned from trying to build reproducibly? First, from using nitro enclaves and trying to do the reproducible builds. First is that you have to be very keenly aware of the trust relationships and the security products that you use. Reading the source, the reading documentation is not necessarily enough. You might have to go beyond that and read the source of the open source tool you're using. We found that the things AWS was worried about when building this product were not necessarily necessarily the same things we were worried about. It's not a problem. You just have to make sure you have the same threat model, security model. Thank you. So coming back to our use cases, we want to go through a bit of an example of one of our use cases here, one of our key ceremonies. Uh, this is a real-world example that I'm gonna talk through of generating a private key pair and a CSR. We often generate this when we need to sign some of our external APIs, and that's because we need a third party um authority to sign that certificate. So we start off with writing some go code into our Git repository. This goes through a peer review process. So another engineer has reviewed the code that we're going to run inside this enclave. Because we have reproducible builds, the engineer can then build this and verify like, OK, right, this is my PCR, this is my measurement. I know exactly what it is. That can then go into the enclave itself and run. This would be a once-off operation, so we're just gonna run it once and it's gonna generate a private key pair and CSR. Another thing that we are very interested in is zero visibility of this private key. We don't want anyone to ever be able to see this private key. So we'll see the enclave with the public key of our vault so that inside the enclave, we can encrypt that private key. No one will ever be able to see this, uh, private key, so we have zero visibility, which is one of our key requirements. Um. When we want to then output these private key and CSR, we can sign it using the attestation. This will allow us to verify that the outputs from this ceremony, from this nitro enclave is the exact same code that ran from that git repository. So we have an exact Backtrace all the way through what we wrote, what we ran, what came out. We'll upload that to S3. The engineer can then pull it from S3 and upload our private key to our vault instance. Because it's encrypted once it leaves the Enclave, no one can see that private key, and that's how we generate our uh private key pairs. We do have other examples of key ceremonies, but this is just one to illustrate. Um, just to recap what we've done there, we've generated a secret and it's had zero visibility. No one, no engineer, nothing has been able to see that secret other than what's inside the enclave, which is a high assurance workload and vault itself. Um, we have a reproducible build so we know exactly that the code that we wrote to generate this private key is the code that ran, and we can use that attestation as the authentication if we need a uh key from KMS. In the previous example, we didn't need a key from KMS, but if we did, that's what we could have done. Um, and then we signed the outputs which can verify the whole process. The other use case we had was multi-party authentication or just in time access. And I'm just gonna walk through the flow of how we do this. So we have an engineer who needs to do some kind of modifications to our AWS um infrastructure. Maybe create a new instance. Something modifiable. They'll create a request by logging a request into the AWS Enclave. Another engineer can then review that request and decide is this something that the engineer needs to be able to do. They can approve or decline that request. Let's just assume they approve it. That's another request to the um enclave. At this point, the first engineer can then fetch the credentials that they need. This will tell the enclave to generate temporary credentials using Amazon STS. These credentials are short-lived, nothing more than an hour, and they are elevated that'll give the engineer the permissions they need to do something to our infrastructure. Only the enclave has the permissions to generate these short-lived credentials. No one else in our infrastructure has these admin level credentials. So another user cannot generate these credentials, um, only this enclave can do it. And it's the attestation that is used to fetch the key from KMS that allows it to create these credentials. So what we've done here is we've removed the single employee weakness. No one has elevated permissions at any point in time, and if they do need it, they can request it for a period of time, which means that if for whatever reason, if credentials were leaked or compromised in what in any way, we don't need to worry too much because they'll only ever be short-lived elevated credentials. Normal credentials, they can't do anything with anyway. Um, we have the delegation happening inside an enclave where we are very sure of what is running, and we can verify that what is running is what we intended to run. In other words, the source code that we wrote to broker these credentials, we can match up verifiably to what is running in the enclave at any point in time. What have we learned from using AWS Nitro util like AWS nitro enclaves and reproducible bills? The first thing is that if you really want to understand the security of the tools you're using, you have to look beyond documentation and make sure you understand the security model that the vendor used. Second, that reproducible bills give you the same guarantees as like build provenance at the station without having to manage any of the secret key material involved in those. Just build something twice and check if they're the same. Thirdly, that once you have a secure framework that you can use, in our case, nitro enclaves plus reproducible bills, you can use that as a building brick for more applications like the multi-party authentication and the security keysermons that Greg spoke about. That concludes our talk. Thank you very much. Um, we are hiring. We also have a couple of blog posts on how we did this and more like technical details, as well as a GitHub link to our open source library for reproducibly building enclaves. Thank you.
