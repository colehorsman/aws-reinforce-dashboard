# AWS re:Inforce 2025 - Encrypting data in transit for your Kubernetes applications (DAP341)

**Video Link:** [Watch on YouTube](https://www.youtube.com/watch?v=iCiDjMBLX8w)

## Video Information
- **Author:** AWS Events
- **Duration:** 40.4 minutes
- **Word Count:** 7,506 words
- **Publish Date:** 20250619

## Summary
This AWS re:Inforce 2025 session, presented by Ram Ramani (Principal Security Solutions Architect) and Davey (Senior Software Engineer), focuses on implementing encryption in transit for Kubernetes applications, specifically within Amazon EKS environments. The session provides both theoretical background and practical implementation guidance for securing container-based workloads.

The presenters address key technical concepts including TLS termination options at different layers (load balancer, ingress, pod level), the role of AWS Private Certificate Authority (Private CA) in managing certificates, and various architectural approaches including service mesh implementations with Istio. They emphasize the importance of making security implementation straightforward while maintaining robust protection for containerized applications.

The session culminates in practical demonstrations and code examples, introducing a new AWS EKS add-on for Private CA connector for Kubernetes that simplifies certificate management. The presenters focus on developer tooling and ease of use, providing attendees with ready-to-use GitHub samples and implementation patterns they can immediately apply in their organizations.

## Key Points
- TLS termination can occur at multiple layers: load balancer, ingress, or pod level
- AWS Private CA offers managed PKI services with flexible hierarchy options
- EKS control plane is fully managed by AWS under the shared responsibility model
- Cert Manager is the de facto tool for certificate management in Kubernetes
- New EKS add-on for Private CA connector announced for simplified certificate management
- Service mesh architecture with Istio provides additional security control options
- AWS Load Balancer Controller offers managed certificate handling capabilities
- Multiple deployment options available for compute: EC2 or serverless Fargate
- Certificate sharing across accounts possible through Resource Access Manager
- Tools focus on making security implementation straightforward for developers

## Technical Details
- AWS Services mentioned:
  - Amazon EKS (Elastic Kubernetes Service)
  - AWS Private Certificate Authority
  - AWS Load Balancer (Network and Application)
  - Resource Access Manager

- Key Tools:
  - Cert Manager
  - EKSCTL
  - Pod Identity
  - Istio
  - NGINX Ingress Controller
  - Private CA Connector Add-on

- Architecture Components:
  - Control Plane (managed by AWS)
  - Data Plane (nodes, pods, containers)
  - Ingress Controllers
  - Service Mesh
  - Envoy Proxy

- Certificate Management:
  - CSR (Certificate Signing Request) model
  - Certificate Templates
  - CRL and OCSP support
  - API-based certificate issuance
  - Custom certificate parameters and signing algorithms

## Full Transcript

All right, welcome everyone, uh, to the session. This is called Encryption and Transit for your community's applications. Um, to introduce myself, I'm Ram Ramani. I'm a principal security solutions architect at AWS focusing on data protection and privacy, and I have my colleague Davey here with me. He's a senior software engineer, the founding member of the AWS Private CA team, and, uh, we're gonna be talking communities today. Alright, so just before we get started, show fans, how many of you are cuminators, developers or or manage cuminators infrastructure? It's curious. OK, I can't see anyone here with the lights, but yeah, OK, alright, cool, all of you. That's good. So you're in the right session then, OK. All right, so. Let's kind of start with, you know, a basic cumin cluster. It's probably all of you or those who are familiar with cubinitist. This is very familiar with to you. However, you have, if you go back to first principles, you have the control plane. We have various different components, and then you have the data plane which is the nodes and the workers, and you have pods and containers within those port pods that are running your cumulative workloads and, uh, essentially the control pane is managing these worker nodes and the pods of the containers. Uh, and you have some components such as a cubelet within the data plane, which uses the pod spec and manages, uh, how, what actually gets deployed within these pods as well as the health of these pods. It's very plain, simple cubinators architecture. But you may be wondering, you know, if I'm operating on AWS, which is our managed offering called EKS, uh, what is an equivalent architecture diagram look like? So if you again go back to the control plane and the data plane, the control plane itself is completely managed by AWS. So if you're familiar with the shared responsibility model, we take care of the control plane, uh, from a security and management perspective. But then you have the data plan, which again is the node and the pods and the containers. That is probably running on either an EC2 instance if you want to manage the compute yourself, or you could be using serve as foggit, right? These are the two options. Um, Now This talk is about encryption and transit. We're kind of dialing down into specifically encryption and transit, so that's why we're saying let's say what does terminating TLS looks like at some of the components of Qinators in this specific case ingress. So if you're familiar with cuminator's resources, so you have ingress and then you have a service, and then behind the service, essentially your workloads are running in a pod or within a container within a pod. And uh we find that most customers are terminating TLS at at the ingress, but the ingress itself is a resource right by itself it's just a construct, it's a virtual construct, but then you need to have some kind of a controller which you put on top of it which kind of fronts the ingress. However, the TLS termination itself happens at the ingress, so that's one way to do it. Now, the second way to do it is you may say that I, I would like to have end to end encryption, not just at the ingress, but I also want to terminate TLS at the pod, and that's also possible, right? So you can either terminate at the ingress or at the pod. If you are not using this plain Manila architecture that I showed you and if you're dealing with SSTO or a service mesh architecture with SSTO, you may be potentially using an envoy proxy for proxying all the traffic and then STO policies for defining which port can talk to which of the port or with allow and deny policies and all that good stuff. Um, however, similar to the, you know, plain vanilla diagram with ingress and pods, even with STO you have these controllers, so whether you have an STO ingress where you can terminate TLS or it could be at one of the containers that is running inside your STO service mesh. You could terminate TLS that as well. Uh, in this diagram, as as you can see, I mentioned about a controller, but here I'm showing you an example of a network load balancer which is fronting the ingress or the STO ingress or the STO gateway as they call it. Now Beyond termination of TLS at the Ires. You could have an AWS load balancer controller, right? And this is uh not the EX controller. This is a load balance AWS load balancer controller. What this allows you to do is that some customers say, hey, I would like to just terminate TLS at the load balancer and there's some advantages to that because AWS load balancer is a managed service and as well as a lot of the certificate services that kind of integrate with AWS load balancer. Makes it easy for putting certificates on theirs, and I'm talking about like on the certificates just in case, um, uh, so essentially you can put these certificates and they're managed and renewed automatically so you don't have to do much. So few customers do that, but majority of the customers still terminate at the ingress, which is what we will focus on in this talk. But I wanted to bring it up here just so that you know that if you are going down the path of using a load balancer controller, you can leverage the ABS load balancer as well. It could be either the network load balancer or the application load balancer. Now, so I kind of set the stage for what we're gonna do here, but let's just talk about what you can take away from this talk. This is a code talk, right? We're gonna get into code and demos and all that good stuff. However, so we're gonna focus on how to achieve encryption and transit for your EKS applications. You'll see that in depth. The AWS services that can help you do that we'll get into developer tooling, um, the ease of use while providing the needed security. And then there's a GitHub sample that we will show you and and if you have brought your laptop you can follow along as well and then you can leverage right away. So the hope is that you can take that sample to your organization and, and you'll find that it is really easy for you to achieve encryption and transit for your EKS applications. Uh, just curious. I mean, I know some of you told me that you're, you actually, uh, cumin developers or, uh, manage infrastructure for communits. Um, how many of you kind of participate and go to Cubecon and, and, you know, are part of CNCF standards? Anyone here are developing any few of you, so OK, great. Um, So, as you know, for TLS you need certificates and certificate authorities or essentially a PKI. Within AWS we offer you a service called the AWS Private Certificate Authority. Which allows you to create certificate authorities as well as obtain or issue certificates that you can put on, you know, at your ingres or at your pods or whatever you want to terminate TLS so it's a completely managed service which kind of allows you to build your PKI needs. Now getting certificates primarily uses the CSR model as we call it so pretty much you have a public private keypad that gets generated somewhere and then you generate a CSR out of that public private keyer essentially the CSR itself contains a public key and then it gets signed by the private key and you get a CSR document and you eventually send it to uh AWS private CA and you get a certificate. Most of the services operate that way, for example, on the right you can see I, I'm, we're talking about EKS in the stock, but you could. Potentially use these certificates uh in load balancers. It could be hybrid, you know, you're connecting from either other cloud providers into AWS or from on-prem into AWS. You could be using IM rolls anywhere with trust tankers that are using a certificate from AWS Private CA and then of course, you know, if you're using, if you're in the IoT space you could put certificates there as well. So all of these follow this concept of, you know, essentially the CSR and then you issue a certificate with the certificate authority. And uh in the Qinit world we show I showed you EKS, which is our manager offering, but we see customers on-prem with their native cuminators applications as well, leverage certificates from AWS Private CA so you could do that as well. So as long as you have the ability to connect into AWS and issue a CSR, you can get a certificate. So what is this private CA, right? So private CA, as I said, it is a managed service and it allows you to build CA hierarchies. It could be a root CA, a subordinate CA, or you could have multiple different hierarchies where you have a route and multiple subordinates or a route subordinate and issuing CA, but whatever hierarchy that you need based on your risk profile, you can build that. And alongside that, the good thing here is that it's, it's a one click operation or you can use infrastructures code and pretty much set up the necessary certificate parameters and the signing algorithms, uh, for the, you know, private and private keys and then you're good to go, right? You're able to essentially have a completely managed certificate authority which can do CRLs for you or you could do a CSP depending on your vocation needs and then at the end of the day it is a restful API call of issue certificate with which you can issue certificates. And just like any other AWS service, it's pay as you grow pricing. And uh we also uh have certificate templates where you can customize certificates. It could be you could be generating a code signing certificate, could be, you know, um, whatever you need, right? So essentially it's very customizable, uh, using some something, something we call as the API proxy method where you can actually send in parameters and you can customize the certificate based on whatever template you choose to do or the functionality of the certificate itself and as I, I give you an example of code signing, but there could be others as well. Now, These certificate authorities, they're managed centrally, but they can also be shared across accounts if you desire to you you can use something called the resource access manager and you can share it out between accounts if you, if your workloads, for example, are spanning multiple accounts but you would like to use the same certificate authority, you can share that as well. That's also possible. All right, so we talked about. Cubinators, uh, developers, and if you ever been to CubeCon, there's always a talk about multiple tools being developed by Cubin developers. So if you ever go to QCon, there's there's a lot of, you know, different tools coming up, uh, which are solving various kinds of problems and the tools. Uh, and the ability to use them securely and effectively are the means for you to have a mechanism for your EKS or Qin applications to achieve encryption and transit, uh, easily where security itself dissolves under the hood and you, you as a developer are focusing on actual user experience and application value, right? We wanna make sure that security becomes very easy and in this case. Uh, my colleague Dey is going to show you how this tooling comes together to make it easy for you to achieve encryption and transit for your EKS applications. So Devi, over to you. Hi everybody, uh, I'm Divy. You all can hear me, right? Oh, OK, cool. Um, I'm Divy. I've been with Ava's Private CA for 8 years now, and, uh, Ron's talked a lot about the theory and like how all this comes together and where we're going with encryption transit. I'm gonna talk a little bit about tooling. I'm considering me like your engineering guide as we go through like these demos, and, uh, I want this to be a little bit interactive. So if anyone has any questions, let me know. I do have stickers that I'll give away EPS stickers if anyone asks some good questions, um. I, uh, think the next step here is we're just gonna go through these tools and talk about what we're gonna use as we build up to encryption and transit. So first tool we're gonna talk about is Cert manager. Certain there's a really good chance that you're using Cert Manager today if you are using, uh, Kerns at all. I like to call it the de facto tool for certificate management. It makes it really easy to, uh, major certificates, manage renewals, and you also have plug-ins that, uh, go into Cert Manager. So 8 of us privacy is something we've talked about. 8 of us private CA can be used with Certman as the certificate issuer and the CA. So, um, there we have an add on for that that we'll talk about in a second. Now the next tool is EKS CTL. This is very similar to cube CTL, except you, you, you can use it with your EKS clusters, um, and there's some like sub things under that. One of them is pod identity. So if you, if you have a pod that's running on your cluster and you need to get access to an S3 bucket or Dynamo DB or something else in your A boundary, then, uh, pod identity is just a tool that lets you do that that can be set up with EK EKS CTL, and it'll actually give STS or IM credentials to your pod. Um, the next tool is add-ons, so EKS has this idea of add-ons where, you know, before you would use something like HeLM or some other package manager or your own manifest files to, to deploy whatever software you needed to your Kuber's cluster with add-ons, it's one click go. You can run one CI command, one click install a lot of different tools including Cert manager, um, as well. And the next thing that EKS CTL lets you do is cluster creation and management. Alright, so the next tool is ISTO. So this is something that Rom covered in one of the previous slides, but there's this idea of a service mesh. Service mesh made easy. It's just a really, it's a single place that you can go to have all of your networking policies, throttling policies, manage all your, um, MTLS rules, all those, all those sort of things, and we're gonna use STO in one of the demos, the second demo, to, um, actually enable MTLS and make sure that pods are talking to each other with MTLS. The next tool that we're gonna use is just an E X ingress. Uh, we talked about ingresses already, but this is just gonna be the specific controller we're using is the E X variety of the ingress. All right, and so we talked about add-ons real quick and we talked about how a certain manager has plug-ins that you can use. So, uh, one of the things we're announcing today is the ETS add-on for private CA connector for Coopernettis. This is just an add-on where you can one click install. Uh, a piece of software that will work with cert manager in conjunction with it to issue certificates through private CA. This is really useful to, uh, simplify your certificate issuance and management. It works in conjunction with Cert Man, which you probably are already using, and, um, you can install and update this add-on with seconds and automation it's pretty simple to use. All right, just to show you a little bit how that connector works, um, it's just like we said, it just, it bridges the, it bridges between certain major and a private CA. You can issue certificates of things like your service mesh or your ingress. It's just an architecture diagram that kind of walks you through that. All right, time to get into the demos. So the first demo that we're gonna do is gonna be terminating TLS add an ingress. So this one is pretty straightforward if you, uh, we'll go to the architecture diagram. You have a load bouncer. With that load balancer you're trying to, uh, just traffic gets a load bouncer goes to your E X ingress. Your E X ingress requests a certificate from cert manager, and cert manager reaches out to Ari CA, gets that certificate, puts it on the ingress. So TLS termination is happening at the ingress. So in this case, if you have a client that's trying to reach, you have, you have a service that's running on your community's cluster and you have a client that's trying to reach it, then you will have TLS encryption between the client and the ingress. So let's go and do a demo of that, uh, do with the QR code, yeah. And so let me switch over to. The next laptop. OK, so just to show you. We do have an 8 of a sample, and this 8 of a sample is going to be something that we're gonna go through for all the installation here. So all the steps we do, everything is part of this part of the sample, and it gives you a series of like very easy to use scripts that you can take home, use with your organizations or just at home, and you can set up core PKI tooling. You can set up a private CA. You can set up ingress MTLS, STO, do all that through the sample and we also have this QR code. I'm gonna leave it up like the next. I don't know 10 seconds if you are interested in following along, I will say some of the scripts that I'm gonna run take some time so I've like pre-run some of them, but you can, uh, you can scan the QR code and you can go to that get a page and run some of these scripts yourself, follow along, see how you like it. And I'll, I'll put the QR code up at the end as well. It's part of our presentation. Cool, so this is the 80 sample I'm gonna follow along with and all I did is I just went to. I went here. I just cloned it and I have it here now and um. One of the commands that I run is. I, uh. Create cluster.SH. I'm not gonna run it here because I've already created a cluster. Creating a cluster takes about 15 minutes, so I'm not gonna put everyone through that, but I'll show you back here if I, so this is my Abu console, um, and if I go to EKS. Running that script gave me this EKS cluster. And one of the add-ons that was installed as part of that script was also this pod identity agent. So we talked about pod identity a little bit earlier, um, so this is just the concept of I have a pod, I need I am access for that pod. How do I do it? This pod identity agent will help you. So one of the things the script does is installs that for you. Um, All right, so I won't run that script, but we'll go to the next one. So what else do we have here? We have, uh, deploy core PKI. So this is the next script that I'm gonna run. This script is gonna do things like it's gonna install cert Manager. It's gonna create an AWS privacy hierarchy for you. It's going to, um, set up pod identity to make sure that, uh, cert manager has the ability to actually get that certificate. And then it's also gonna to use that new EPS add on that, um, that bridges the gap between cert manager and Aburivacy. It's gonna do all those things. It takes a little while to run again, so I'm gonna. I'm gonna, I have pre-run it, but I'm gonna run it again here and then while it runs I'm gonna show you some stuff in the console and what's actually going on. So this is running and while it runs, we can head over to the code and just take a look at what it's doing. So this is the code. I think it's big enough. Yeah, this is the code and um this just takes in some parameters, cluster name, region, etc. And one of the things that it does is it sets up this pot identity association. So this pot identity association is for a tool called ACK. So we haven't talked about this yet. ACK is a tool. You can think of it as I like to think of it as cloud formation or terraform for uh Kubernetes, but ACK is a tool. It's Amazon controllers for Kubernetes. There's an ACK controller for um S3 for IAM, and also for AIS Privacy. It's a, it's a tool that lets you deploy via manifest infrastructures code and deploy an AS privacy hierarchy. So what's happening here is I'm going, I'm going to deploy ACK. But deploying ACKA requires the ability for um the controller to access AW private CA and use this IM policy. And that makes sure that it has the ability to actually create the C hierarchy. So here, uh, we install the pot identity association and then next we use this Helm command to, uh, actually install the AC pluging itself. So this helm command installs ACK for private CA and just to skip ahead a little bit, I'll show you this is the hierarchy that it's gonna install. So this hierarchy is going to have a certificate authority. It's going to have a certificate to activate the certificate authority. And it's going to have just an activation resource that activates the certificate authority and gets it ready to use and then later we'll use it with um we'll use the CA with cert manager to issue more certificates that your cluster can use. So this is the hierarchy going back to the script. So yeah, here what happens is once we have um once we've helm installed the ACK plug-in we go ahead and apply that manifest file where we say the private CA hierarchy please give that to me and ACK does and uh you get a CAR out out of that. Next we install Cert Manager. Cert Manager again, very popular tool, and you can do this through add-on. So just, just to show you the difference like if I'm, if I'm installing something with Helm, it can get to be a very complex command. Like take a look at this command, it's, it's a lot, but if I'm using EKS add-ons, a lot of that is done for me. One simple command right here. And this ECS add-on is going to install a certain manager for me and it just makes it very easy without all the extra configuration that you often have to do with home. Next to you, uh, I'm going to just do some basic name space creation and I'm gonna create another pod identity, uh, pod identity association and this one is gonna be used for, um, the connector for Kubernetes. So this is the next add on that we're gonna install and this connector for Kubernetes um. Uh, is that is gonna be used to again bridge the gap between privacy and cert manager, but you need I am permissions to do that. So that's what the bot identity association will do. It gives like permissions like issue cert, etc. So that gets done and then we create the add-on right here. So here again, very simple one line command to create the add-on for the ABS privacy connector for Kubernetes. And that's it. So that's what this is doing. This is creating a, it's just setting up all the infrastructure that you're gonna need all the tooling, etc. that you're gonna need to actually, um, set up the rest of the demo. So that's what we have here. And one last thing I'll show you is this also deploys this er manager issuer. So this is gonna be the issuer that we're gonna use for the rest of the demo and so when we created a private CA um. We created a privacy earlier using ACK. You can the the CARN will end the pair, the region will on the pair so that later when we issue certificates to certain manager, it comes through privacy. Cool, so that's the first script. And you'll see here that the script is done and again this is just the script that's part of the GitHub um demo or the GitHub sample and if I apply this, it'll well again because I did it earlier but it'll create the certificate and uh we can actually take a look at that certificate. By just describing it. And we'll see that the certificate is ready and you can also. Export it into a cert.com and then I can use OpenSSL to crack open that cert. So this is the certificate that I just, I, I just deployed the certificate just to show that like the tooling is working and that we were able to issue a certificate and it's just example.com. Cool. So that is the first script that I run. And we can clear that out. And the next script that we're gonna run is actually gonna set up the um the demo, the demo one, which is with the ingress. I'm gonna switch back so you can see the architecture diagram one more time just to remind you what we're setting up. So this right here is what we're going to set up again it's just an ingress and then we're gonna deploy a certificate, do that ingress and do TLS termination at that point. So moving back to the demo. OK, yeah, I'll show you the IN policy that's being used. So actually, so you saw the port identity where we're able to create the porter identity association with a specific role for permissions within AWS to do certain actions. So what WB is gonna show you is that the permissions itself, what is needed so that AC can can actually do these actions within AWS, right, for privacy issuance or issuing private certificates. Yeah, so I used a manage policy and just to show it to you in code, this is the policy that I set up. Uh The policy that I set up was. This one right here, the privacy connector for Kent's policy. So I showed it to you here, but I'll show it to you in the console as well. Um Or actually, if I copy this, it should show up there it is. So this is the policy. So this is the policy that's actually being used, uh, with pot identity. It just has basic describe certificate authority, get certificate authority and issues most importantly get uh issue certificate authority or issue certificate. All right, so back to the demo. Um, OK, so now I'm going back to deploying the ingress, so deploy ingress and I'm running this again. Uh, it takes a little bit of time for the load bouncer to come up. It takes maybe like 5-10 minutes sometimes. So this is something where I'm running it here and I'll walk through the code and then we'll take a look at the console. So let's go to the ingress and look at the code. All right, so same script, um, in the beginning we're just taking in some parameters. And next we just do some installation. So we install the Engine X controller, so this is just the ingress control that we've been talking about. It'll deploy Engine X to your uh your cluster. And then when the Engine X. Uh, controllers installed. One of the things that it does is it actually spins up a load balancer on your behalf and so. Uh, we give it permissions to actually be able to do that, so we give it this policy, the Amazon EKS load balancing policy, and this policy contains an action that says, yeah, this cluster can or this pod can create a load balancer on my behalf and so we do that and so we, we, we, we do the pod identity association here and then we, uh, install Eng X here. And notice one of the things we told we explicitly tell it during the installation create an NLB for me so that's how the NLB is created. And um that's really the majority of the script so the script is really just setting up that uh that Engine X controller giving it I information still to create an NLB for me and then uh it's gonna just do one more thing where it deploys like a demo app and this app not fancy it's just a deployment that running Engine X and we're gonna take a look and one of the things that it does, by the way, is it when it uh creates the the ingress it um. Calls out to certain manager in one of the annotations. So in the ingress it calls out to cert manager and says, Hey, that issuer that we created in the last step, give me a certificate off of that issuer. So I, I'll show it to you again the issuer that we created in the last step was this cluster issuer and we actually refer to it again and we say, give me a certificate and this cluster issuer is set up to use a private CA through the CAR. So that's how the Engine X um controller is actually injecting or certain managers injecting a certificate into uh the Engine X controller. So that's what's happening there and now if I go to the console. And I go to the load balancer. Oh. Wait, that was weird. Let's go to E2. There we go. And here, if I go down to low bouncers. And you'll see that a low bouncer was created and again, I didn't do this through any sort of like CI command or anything. This was all done through Kubernetti's where a load bouncer came up and um this low bouncer, if I go to it. And actually hit it. it's gonna say it's not trusted and that's because uh I'm using a private CA so that's not like natively trusted. I would have to add that certificate to my trust store, but I can hit advanced and proceed, and it works like I can hit my uh EX controller and it says welcome to Engine X. So that's, so the communication that I did is encrypted, um, just not trusted in this case. I would have to add it to my to my trust store. So that's the first demo. And actually I'll show you one more thing in it um. I have some commands here that will show you the certificate itself that's being used so. This is me just grabbing the certificate that's on the ingress. And taking a look at it, so this certificate is what's actually on the ingress, and you'll notice that um in the SAN you have the DNS for the, uh, the load bouncer that we just hit. So this is just what the certificate looks like. Uh, can you show them the bundle from download from the certificate authority, yeah. So I think ROM is asking how would someone actually do the whole thing where I want my browser to trust it, um, so I can go to the 8 of Private CA and so again by the way this is something where I this 8 of Private CA was not created through some like external command all done through that script earlier where ACK set it up for me. So here you can go to the CA certificate. And this right here is the SCA certificate that you would want to trust or your browser would wanna trust so you can export it and then you know import it back into your uh trust store so that's how you would do it. Cool. So that was, I'll switch back to the slides real quick. So that was the first demo. And now we're gonna talk about the second demo. So this is really end to end now we're talking about, uh, as someone pointed out we're talking about, uh, doing the encryption all the way through to your pod that's actually serving traffic. So what that looks like is a little diagram this kind of like a simplified diagram of how it looks. So you have your external client that's gonna reach out to your NLB, which is similar to what we did before, and this time it's gonna pass through all the way to your ingress. Your ingress is gonna do an initial TLS termination. And then it's gonna get re-encrypted and it's gonna go through your service and now it's gonna be MTLS, uh, all the way to your we call it just hellopod, it's just a hello world pod and, uh, one other thing to point out is that communication happening between pods, so you have that client pod and that helood that communication is also gonna use MTLS. All this is done using the same tooling that we talked about plus we're adding STO now to help set up some of these policies and, uh, use a service mesh. Cool, so let's go ahead and do that demo. So again using the GitHub script that we had before um clear and um we can go and deploy MTLS. This is the script And while it's running again, we'll talk about what it's doing in the actual script. All right, so this script starts out the same. You have some parameters coming in. I just switch the thing here. Oh, thank you. Sorry, thank you. Thank you. OK, so I'll just say it again. Terminal in the terminal I ran uh this script. Or I'll find it. Yeah, I ran this script and while the script was running, I'll run it again. It doesn't hurt to run it twice. um, while the script was running, I'm just gonna talk through exactly what we're doing in code. So the script starts at the same way and here we create a pot identity association and this was one that we saw it on the console earlier but uh this is one for ISTO ISTO itself will create a low balancer so this is just giving IT the permission to do that and so this is the load balancing policy. And, uh, next, what we do is we deploy this STO cert which I'll open up. And this is to assert here is going to be, it's, you know, it says ACA is true this is gonna be used to actually get the um. Get certificates later issue certificates later that are gonna be used for MTLS and so one of the things we do here is we create this ITO CA key pair secret where the key and the the the um the key information is stored. And so when we go back to our script, you'll see that when we install ISTO we actually pass it that key pair and we say, hey, use this as your key pair for your CA. And that certificate itself, by the way, going back to it real quick, that certificate itself routes up to 8 of its private CA. So if you go down to the issuer ref, this is the same issuer that we used in the example before and in the first script, which is, uh, the the ASPCA cluster issuer. So it's gonna route up to private CA each time. And um what we do next is we issue the gateway cert so if you remember, switch back. In the diagram, we actually do termination at the gateway. Um, this is the certificate that I'm issuing here that will give me the, uh, gateway cert so switching back. Um, yeah, so this is the certificate, the gateway cert. And you can see it in. Gateway cert. YAML. So that's the certificate. And again, notice how that routes up as well to the 8 of privacy issue. So this is also a certificate that's being issued off of that, uh, that 8 of Priva CA. OK, and next we deploy the gateway. And so this is, you remember from the diagram we had the gateway we're doing the termination, so this is the gateway itself being deployed that gateway is just configured. It's you see this as TLS mode and we just say simple TLS. This is not MTLS because this is the client, uh, authentication coming in. And so you have, uh, the hello TLS secret, which is the gateway cert secret. So if we go back to the gateway cert hello TLS secret. So the gateway cert gets issued through cert manager. Um, off of an Abu private CA, it's put on the gateway termination happens there, and, um, you can see that all in code right here. And one of the things we do as well is we set up a destination rule that points to a service and this service itself is um using a just a pod that's just a hello world pod. And you can see that in the demo app, so you have this deployment. Service And uh we also deploy a pod. That has. This curl command in it so we can use it to show later like is MTLS working in between pods or not. So let's go back to our script. So we deploy the demo app that I showed you. We also have this file called PR authentication. I'll open that up. This here is actually saying MTLS for anything that's inside the STO name space or the STO system and so here you have strict. And we're saying MTLS for everything. All right, so we deploy the pods and if we go back to the command line. Uh, you'll see that it has a couple of tests at the end of the script as well. It kind of auto runs them for you. One of them is it's testing that MTLS was working. So just to go back to the diagram. You'll see those two pods that are talking to each other at the bottom and it says MTLS, so it's testing. Does that MTLS work? So It runs this command and a test is MTLS working in between those two pods and um that should succeed and it does so it does, it works and you know that because it says it works it actually returns that from the pod. And next we uh test from outside the mesh so one of the things that I did is as part of the demo app. I deployed this extra pod. This extra pod is running outside of the uh the name space that I said all all of the communication needs to be using MTLS. So here I said test MTLS, uh, which is a different namespace, and this is just, uh, deploying curl. And so this test, uh, what it does is it actually test that MTLS is, uh, it's the connection is failing because there's no MTLS and it does fail, so that's good. And the next thing is we can just test that we can hit that end point so if you go to the load balancer similar what we did earlier. Um, or good easy too. Go to the STO. So this is the the low balance that was um generated from this script. If we go to that you know. Same thing as before where you would actually have to go to the Avis Private CA download the CS certificate, have your browser trust it, but otherwise you can go and it says it works. And um. So now what's happening is when I hit this load balancer it it again it gets terminated at the TLS and it goes all the way and TLS goes all the way to your pod that's actually serving traffic so it's encrypted truly end to end this time, not just terminating at the at the BNA cluster. Yeah. Yeah. Um, the listener protocol, I can repeat the question. Uh, is it listing on accept. It does a redirect. Yeah, it's redirecting the 443. Any other questions? OK, so one thing I'll show is the certificate itself, so. Um, actually, one thing I haven't shown is. These are some of the pods that are running on the cluster, so you see you have ACK pod, you have the issuer itself. This is the privacy issuer, also known as the connector for Cernettis. We have Cert manager which works with that connector. Um, we have the Engine X controller. So one thing that I'm gonna do is I will actually grab the certificate. That is on one of these pods and we'll take a look at it. So these are just some commands that I have that lets me grab the certificate. There are A little bit hefty. But we can use open SSL at the end to look at that certificate. So this is a certificate, for example, that's in one of those pods and you'll look at the. Let's find the sand there it is, um, in the sand you'll see, so this is IT actually uses spiffy under the hood or some set of spiffy specs under the hood, and, uh, you'll notice that ITO gave a certificate to the pod that says this pod is in this cluster under this name space which is the uh demo name space that I created as part of my script, and that pod is running as part of this service account which is just the default service account. So that's what the certificate actually looks like that's, um, that's being used for MTLS. Actually we, we also see, um, a few customers connecting from pods which are on-prem which which has spiffy identities into AWS. If you need that, that's also possible. Uh, we have something called IM rolls anywhere with which you can connect into AWS from other cloud providers or from on-prem, uh, with credentials. Um, I'm gonna switch back to the slides really quick. Yeah, OK, here, yeah, so this is, uh, just the architecture diagram what we created. So again, we just created a, uh, gateway termination of the gateway MTLS all the way through after that. This is I showed you this earlier, but this is the QR code if you wanna try it, take it home. Uh, all these scripts are available, the toolings available on that GitHub page. So take a picture if you want or, uh, scan the QR code. It's all on GitHub. And we go back, go back to the side, so we, we, this particular sample which we built recently, it's got, as DB showed, it's got complete automation of building the certificate authority with code and deployment both for your gateways or could be your ingress or it could be on your pods. So really it, it kind of melts away the security components and makes it very developer friendly with as less code as possible and very simplified commands. So if you. You're trying to deploy like, you know, essentially satisfy the need for encryption and transit for your Qin or EKS applications. This sample can, you know, right away do it and makes it very easy. So if you have any, if you're trying to deploy this and if you have any questions, um, next time. Yeah, yeah, sorry, please reach out to us and if you see that there is anything that's not working or you need more help, feel free to uh reach out to us through LinkedIn, and we can connect later on and go deeper into what you're trying to achieve. So that's all we have for you. Thank you so much. Thank you.
