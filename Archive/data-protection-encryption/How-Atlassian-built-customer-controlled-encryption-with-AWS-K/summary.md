# AWS re:Inforce 2025 - How Atlassian built customer-controlled encryption with AWS KMS (DAP324)

**Video Link:** [Watch on YouTube](https://www.youtube.com/watch?v=87P3yjUIh38)

## Video Information
- **Author:** AWS Events
- **Duration:** 18.6 minutes
- **Word Count:** 3,461 words
- **Publish Date:** 20250618
- **Video ID:** 87P3yjUIh38

## Summary
The presentation focuses on how Atlassian built their customer-controlled encryption platform (Cryptor) using AWS KMS. The system manages over 5,000 encryption keys across 23,000 compute instances, handling 25 billion encryption requests daily. The platform implements envelope encryption at different layers - volume/infrastructure, application, and client-side encryption.
The solution was developed to meet growing customer demands for data isolation and key management control, aligning with Gardner's prediction that 40% of organizations will deploy enterprise key management solutions by 2026. Atlassian's platform provides centralized key management while offering customers options for both bring-your-own-key (BYOK) and customer-managed key solutions.

## Key Points
- Cryptor manages over 5,000 encryption keys and processes 25 billion encryption requests daily
- The platform saves approximately $76,000 daily in KMS requests through efficient local caching
- Implementation uses three-layer encryption approach: volume/infrastructure, application, and client-side
- Regional key redundancy ensures service availability with three keys per service
- Customer demand for encryption key control is growing significantly, with 40% adoption expected by 2026

## Technical Details
- AWS KMS for master key management
- Envelope encryption implementation using:
  - Data Encryption Keys (DEK)
  - Key Encryption Keys (KEK)
  - Encrypted Data Keys (E-DEK)
- Storage services supported:
  - DynamoDB
  - S3
  - SQS
- Compute environments:
  - AWS Lambda
  - EC2
  - EKS
- Performance metrics:
  - 256,000 daily generate data key requests
  - 99% hit rate for decryption cache
  - 99.999% hit rate for encryption cache
  - Client-side caching system for key management

## Full Transcript

Good afternoon everyone. Uh, I'm Trevor Mack. I'm a senior principal architect at Atlassian, and my colleague Arun will come up in a second. Uh, today we're gonna be talking about what how we built the customer managed keys in our product, or as we call it customer controlled encryption, uh, using AWS KMS. So we're gonna be talking about encryption today. Uh, our overall agenda, uh, I'll start with some encryption foundations, um, talk about some primitives here, um, I'll then advance into discussing a little bit about our platform. Uh, we call it cryptor internally. There's also a blog on our engineering blog, uh, we published about how we built cryptor and what it does for us, and I'll be talking about that today. Um, and then we'll transition to thinking first about what the customer is wanting in this particular solution that we've built, um, talk about a little bit about key models. So there's different ways that, uh, encryption keys can be, can be modeled and managed, uh, in a multi-party system, and then we'll get into two of the offerings that we've built, uh, bring your own key, uh, and then a customer managed key solution that builds on top of that, and then finish up real fast with just a couple lessons learned that we've had over the years. So to start, um, most of, most of our encryption is using envelope level encryption if you're familiar with, uh, AWS KMS, you've heard of envelope encryption. Uh, there's a couple different keys. One of my favorite topics that my colleagues always mention is whenever we talk about a key, I always ask the question which key are you talking about because there's a lot of them. Um, and so here I wanted to find a few. A data encryption key is actually encrypting the actual data, uh, a key encryption key or usually referred to as a Keck or KEK, uh, also a wrapping key, lots of different terminology, uh, is encrypting that data key. So that's actually protecting the data key, not the data underneath it. And then, uh, those two combined ultimately make an e-decker an encrypted data key, uh, and that's gonna be stored alongside your data. When we talk about encryption, there's also 3 different layers that I want to get into, one of which is volume or infrastructure layer. Uh, this is where you're encrypting an entire volume of data with a data key that we talked about earlier, so that entire volume is encrypted with 1 key. That's the granularity we're talking about. A second one that we've termed internally is called application layer encryption. Some of you might know it as client site encryption. Um, we've we've defined this a little bit differently, and I'll talk about why. So here we have, uh, a compute that's hosted in 3 different hosting environments, uh, lambda, an EC2 and an EKS, so a container system. Um, envelope encryption is that middle box here where we're combi combining a document, some plain text with a data key and encrypting that with a KMS master key or. Referred to as a KMS key that turns into your encrypted data so that has your encrypted data key that I earlier talked about and that has the the cipher text of what that data represents and then we're gonna store that in some system here I've, I've, I've specified 3 Dynamo DB and S 3 objects as well as uh an SQSQ event. Um, that's where your encrypted data is gonna be hosted and of course you're gonna have volume level encryption on your S3 bucket. You're gonna have volume level encryption on your Dynamo DB table, but here we're doing application level encryption. So we're encrypting data that's being sent to those systems. Why is that different than client set encryption? That's a great question. Thank you for asking. Client site encryption for us is referring to the client device that's on the customer's network. Uh, that could be a laptop on a web page, that could be your mobile device, um, and that is doing very similarly client side encryption again we have a deck, we have a document that turns into encrypted data, and that encrypted data then gets sent to our servers. um, that is what we refer to as client side encryption or CSE for short. So those are the three different layers we're gonna be talking about. So Atlassian's encryption platform Cryptor, I mentioned that it provides a few benefits to us, uh, centralized key management. We're gonna talk about a lot of keys and you're gonna see some numbers here shortly. We manage over 5000 encryption keys, uh, using cryptor, and that's accessed across 23,000 compute instances inside of our network. The decks we were talking about earlier, there's gonna be encryption decks and decryption decks. Encryption decks are ones that are actively encrypting customer data. Decryption decks are gonna be decrypting that customer data. And we have 550 million of those in the decryption decks. So How do keys get created? How do they get managed? Here I have a representative service, let's just call it Service A for for all intents and purposes. It's using cryptoor. Cryptoor is two parts. It's a client side library and it's also uh an open service broker. It manages these keys, the permissions on the keys, and the grants that our systems need to be able to access these keys. Service A has 3 keys. Which specific region doesn't matter. There's 3 different regional keys that allows any one of those keys to be able to decrypt and encrypt that data. Service B comes along. What do we do inside of crypto? We create 3 keys so that we have this region, uh, availability to us so that if any one KMS region where these keys are, are, um, accessed is available we can encrypt and decrypt that data. We also create a key policy. We also create grants for the encryptors and decryptors that that service specified, and we create those and inventory them for the service client. What else do we do? We ingest that into a client cache, so I I talked earlier about how we have so so many of these decryption and encryption keys. Those are all cached and encrypted separately inside of S3 for that particular service so they can be ingested and brought to our SDK to be used locally on that compute instance to be able to encrypt and decrypt, uh, data, and that cache is synchronized across all of those instances we talked about earlier. So To bring some other large numbers to this equation, uh, every single day our crypto instances are encrypting 25 billion requests. Or pieces of data, um, to translate that to API requests to to KMS that's 256,000 generate data key requests, uh, where we're generating data keys inside of KMS and encrypting them with those master keys that cache that I talked about on those instances resolved uh 2 9s for our decryption cache so they get evicted after a certain amount of time and we only use them when they're needed. And encryption caches are 5 9s. um, so whenever data is being encrypted, it's always being encrypted locally on that instance with a cache. That ultimately saves us nearly $76,000 a day in KMS requests because we're resolving all of this locally. Now we're gonna transition to talking about the customer use case of customer managed keys, but I wanted to call out a Gardner report from 22 stating that customers, so organizations, um, 40% of them will deploy some type of enterprise key management solution by 2026. 2026 is just next year. Thank you Trevor. Uh, my name is Arun Velaupalli. I'm a senior principal architect with Atlassian. So I'll go walk through, you know, what is our, uh, strategy, you know, in approaching some of the customer requirements, right? So, so you can see a lot of customer requirements that are listed here, some of them, right? So, uh, you know, most of the customers that we, uh, go talk to are interested in how do we, how do we isolate customer data with encryption, right? So isolation not through encryption is pretty important. And also how did we give additional control to the customers by letting them manage the keys, whether it is through the KMS key policy or through the keys themselves or CMK keys themselves, uh, really to kind of, uh, you know, maintain their compliance posture, right? So these three are the important aspects that we look at. And then if you see, so what we built initially was, uh, we call it as bring your own keys and if you observe this is mostly vendor initiated, right, so which means Atlassian, uh, key management system that travel explained, you know, crypto and its components uh are going to go and operate directly into the customer's account by, you know, asking the customer to create a dedicated AWS account in a specific AWS region and then. You know, create the keys within those regions and set the policy. In this case, customer is basically going through set of operations where they uh go set up the KMS key policy in the specific region and then. Atlassian basically goes and creates the keys as you see in those regions, which means we are basically creating a keyRNs and then we do the inventory as the next step, you know, which means we have the, you know, uh the uh administrative capabilities and also the operating capabilities in this model where we call it as kind of a core managed system, right? So, so if you see the, uh, key models that we operate at the moment, so, uh, you know, vendor managed is basically, you know, shared encryption model where. Uh, for multiple customers we use, uh, shared set of keys, right? So in this case customer trusts us to use the right encryption models, and the next one is bring your own key where customer allows us to, uh, use their key resource but they bring the key key material, right? So and then the third one is co-managed where you know customer owns the key model, uh, sorry, a key resource in this case, you know, KMS, but we are co-managing the policy and also co-managing the keys, meaning. We can go. At last you can go create the keys and also operate on them. The last one is customers managed keys where customer just gives us the operational capabilities. Customer creates the keys. Customer also sets up the policies. Customer is full, uh, fully responsible for the key life cycle management, right? So, uh, there's a significant difference between the BUYOK model and the CMK model that I would like to highlight. All right, so, uh, from the transition, right, so we talked about the initial version was BYOK, and then we transitioned to CMK, you know, the, the most of these transitions that I can highlight is, you know, the permissions model, right? So the key management permissions are now. Uh, moved from administrative capabilities to operational capabilities, right? So Atlasin doesn't need administrative capabilities anymore. We simply require ability to operate, you know, encrypt, decrypt, generate data key, and also get the key status, right? So these kind of high level, uh, operational privileges are required and no key creation or deletion anymore, right? Uh, previously we used to support single root of trust, which is, uh, you know, just KMS key. Uh, the AWSKMS as the root of Trust, but we are, uh, looking into multiple options for root of trust, you know, for example, cloud HSM, you know, external Key store and things like that. Uh, and also the big difference is also in the previous model since we have these service rules reaching out to the customer AWS accounts, uh, there is, there used to be like dynamic number of AWS KMS keys that we required. In other words, Service A creates a new key and service B comes in. Creates a new key. So there is a dynamic set of KMS keys that were being created in the BYOK model or in our version one model, uh, which is now basically transition to static set of keys, you know, customer now requires only 2 KMS keys in region A region B if it is to dual regional realm. If it is a single regional realm, you know, customer only need to create 1 KMS key. So instead of dynamic, we move to static key set. Yeah, so some of the key origins that we are looking to support, uh, uh, looking to support, uh, is AWS KMS. We already support that. That is our primary uh route of trust that we already support. Um, the next one in the order is importing the actual key material, uh, the operationally it won't be significantly different, but we detect that it is, uh, you know, imported key material and external key origin, right? Uh, the third group is cloud HSM or external key stores, so we do, we group them as separate because it's, it could be outside KMS, you know, if, if a customer is using some of the route of trust, they would like to operate on the same route of trust and not come to AWS for whatever reasons. Uh, we use AWS KMS and XKS, uh, as a, as a bridge, uh, to basically use the same KMS, uh, origin, right? So. Um, but you see this, so there are two different parameters, right? So for better performance and availability we suggest customers to come on board using AWSKMS as the route of trust, you know, less overhead, uh, for both parties, customer and us, uh, but if customer is really interested in. Having additional control and greater greater ownership. For example, customers might choose to own the actual physical hardware or HSMs or the rule of trust themselves within their own data centers, then, you know, customers can choose to use XKS as the bridge. I Yeah, so So customer manage keys provide, you know, customer, um, you know, least privileged model that I described, uh, with very vendor, uh, very less vendor specific complexity. In other words, the customer doesn't have to know or learn how Atlassian manages the keys, the crypto, and the complexity around crypto. None of this is required by the customer to understand. Um, so these are some of the UX snippets that you can see in the customer initiated model or the CMK model. Uh, where customer basically creates two CMK keys and they set up the KMS key policy and you can see in the, uh, UI, you know, customer creates the keys and then there's only static set of keys and we also added additional controls that customer can apply. Uh, one is network security control through, um, ability to restrict through VPC end points, right? So customer can. Apply KMS key policy restrictions, only allowing Atlassian network to reach into their KMS, right? So basically, they can apply only allow these VBC end points and but not others, right? So that would restrict only Atlassian to call into these KMS resources. Alright, so this is the slide that describes the difference between the BYOK and the CMK models that we developed, uh, for example, in this case, you know, in 3 organizations they are creating their keys themselves, you know, Atlassin is not going in and creating any keys, um, in whatever region that customer requires they create the keys, they create the policy, the KMS key policy. And then further they we reach out to these uh KMS key ARNs to figure out do we have the right policy? Can we operate on these keys, do a couple of dry runs uh before we provision the products and once we determine that OK the key KMS key policy is configured correctly and then they can we can perform encryption decryption operations and baseline drive runs, then we, uh, consider that, you know, configuration is correct and then we provision the products. Right, some of the lessons learned, right? So, um, customers are more interested in understanding the life cycle management of the keys, you know, how often they want to rotate the keys is up to the customer. Um, for example, you know, AWS solved the problem of, you know, uh, rotation period between 90 days and up to 70 years, so you can uh do a key rotation on demand or maybe, uh, on a schedule, uh, period. So this is a. Uh, good thing for a license because now you know we can ask the customer to configure whatever rotation schedule that they would like to configure and we simply uh act like a black box. We don't necessarily do anything special, uh, you know, customer life cycle management in terms of rotation is completely owned by the customer. Uh, there's no, um, activity that we need to perform, right. The next one is key policy template. So this is an interesting, uh, problem that we are working on right now. So imagine various different classes of customers who are willing to operate in various different models. For example, you know, vendor managed BYOK and CMK. These operate at different permission levels. So for example, customer might come in come on board using BYOK where customer is allowing us to operate on. Their keys and also create new keys, but then they might want to transition to a new model they might want to transition to the next model so which means there is a change in the KMSQ policy and then there is a change in the set of permissions that customer needs to change, right? So which means. We as a vendor we need to figure out, OK, is this customer using the right version of the policy that they need to apply? So we are working with AWS in this area to figure out, you know, what's the best model, uh, to apply these templates so that, you know, we can figure out, uh, is the customer using the right KMS key policy that way there is less back and forth between this is the KMS key policy right? Uh, do we are our right and sufficient to meet the KMS key policy requirements. Ah, the other area that's interesting is the revocation detection, right? So, um, When a customer revokes keys, uh, the intent can be a number of things. The customer might want to react to an incident or customer might want to simply test, uh, is the revocation working? or customer might be going through several internal, uh, activities to test revocation or maybe move to a next key model, right? So there are several different permutations. All these intentions from the customer. Uh, uh, around revocation are gonna be hard for a vendor to figure out is this the right intent, right? So, uh, we are trying to work with various different resources, uh, for example, RDS and SC and various other, uh, providers, uh, you know, data store providers to figure out, you know, what's the best way to detect revocation, uh, when a customer revokes the cases, what are several events that we need to capture. And how do we consistently provide uh the workflows that need to be triggered post revocation, for example, uh, Trevor mentioned data keys, you know, Trevor also mentioned some of the data stores that we use to store the data so the moment customer revokes we go through a cycle of workflow activities where. We evoke access to, you know, uh, you know, to the resources to the databases and to the data stores also flush away all the data keys, right? So we want to make sure that all the data keys are basically purged, right? So we're figuring out the consistent patterns, uh, on what is the right event to monitor is also some of the things, uh, some of the interesting areas that we are looking into, uh, working with AWS at the moment. Right, these are some of the highlights that we wanted to kind of share and uh we have more details, uh, we can share with the QR code. Unfortunately, the slide doesn't show you the QR code will be standing here. um, if you would like to talk about uh customer managed case and our journey, happy to share. Thank you.
