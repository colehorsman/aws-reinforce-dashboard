# AWS re:Inforce 2025 - Securing CodeBuild managed runners: Patterns for GitLab & GitHub (APS202)

**Video Link:** [Watch on YouTube](https://www.youtube.com/watch?v=W6ZQKclRcvg)

## Video Information
- **Author:** AWS Events
- **Duration:** 41.2 minutes
- **Word Count:** 6,930 words
- **Publish Date:** 20250620
- **Video ID:** W6ZQKclRcvg

## Summary
Jason MacIntosh and Shalab Gaikwad present a comprehensive approach to securing CI/CD pipelines using AWS CodeBuild managed runners with GitHub and GitLab integration, focusing on SLSA (Supply-chain Levels for Software Artifacts) framework compliance. The session demonstrates how CodeBuild's serverless, ephemeral build environments provide built-in protection against supply chain attacks while offering enhanced security features like fine-grained IAM controls, VPC isolation, and comprehensive logging. The speakers show practical implementation patterns for replacing self-hosted GitHub runners with CodeBuild managed runners, highlighting the security advantages of ephemeral compute, zero standing access, and defense-in-depth strategies.

## Key Points
- SLSA framework addresses supply chain attacks that target build infrastructure itself, not just the application code, as demonstrated by real-world compromises of centralized build servers
- CodeBuild provides immutable source versioning through the start-build API, ensuring provenance tracking and preventing source substitution attacks during build execution
- Debug functionality and SSH access must be disabled in production environments to prevent unauthorized command execution that could bypass source-defined build processes
- Ephemeral build environments in CodeBuild create new instances for each build job, eliminating persistence attacks that could affect multiple builds or environments
- CodeBuild managed runners eliminate the need to maintain GitHub/GitLab runner infrastructure while providing serverless, scalable, and secure build environments
- AWS Code Connections enables zero standing access patterns, eliminating long-lived credentials and implementing just-in-time access to repositories
- VPC integration provides network-level security for accessing private repositories and dependencies, isolating build processes from public internet exposure
- Comprehensive logging through CloudWatch and CloudTrail enables detection of unauthorized access, source tampering, and provenance verification

## Technical Details
- Source version immutability: Once set via start-build API, source version cannot be modified, ensuring build provenance and preventing source substitution attacks
- IAM least privilege implementation: CodeBuild service roles with specific actions (codebuild:StartBuild, codebuild:BatchGetBuilds) and resource ARN patterns to limit access scope
- Condition keys for enhanced security: codebuild:project-arn, codebuild:build-arn, codebuild:source-buildspec, and codebuild:compute-configuration-instance-type for fine-grained control
- Explicit deny policies for production: Disable SSM and sandbox session manager access to prevent debugging capabilities in production build environments
- VPC configuration with condition keys: codebuild:vpc-config:vpc-id to restrict VPC connectivity and ensure access only to approved private resources
- Build cache isolation patterns: Separate cache buckets with resource policies to prevent cache poisoning attacks between different projects or environments
- Reserved capacity options: Persistent CodeBuild environments for reduced startup times while maintaining security boundaries between build executions
- GitHub integration workflow: runners configuration in .github/workflows with runs-on pointing to CodeBuild project instead of ubuntu-latest or self-hosted labels
- Multi-platform support: Lambda, Windows, Linux, and Graviton-based compute platforms with customizable build environments and pre-installed toolchains

## Full Transcript

Thank you for coming today, the most dedicated audience of the day coming to the last talk on the last day, so I appreciate you all joining us here today for the talk. If you're looking for uh raising the security bar at your organization, especially when it comes to security of the pipeline, and you want to know how to do that with AWS services, then you've come to the right talk. My name is Jason Seer MacIntosh. I'm a senior solutions architect, and with me I have, I'm Shalanegum and I'm DevO Solutions architect at AWS. Before we dive into things, I always like to start with some context setting. Security for the sake of security is obviously a good thing. It's the top priority here at AWS, but also what's important to know is that implementing devSecops properly has additional benefits across our organizations. The one that I want to focus on in particular is the one at the bottom right here, recruitment retention. One of the ways to increase job satisfaction is reducing firefighting, so I'm sure we've all been part of, uh, or most of us anyway have been part of situations where we've had to respond to fires. I remember working at one organization where my weekend plans were totally kiboshed by a ransomware attack, not fun. So if we can reduce firefighting, that can help increase job satisfaction which can increase recruitment retention. So it's good to know implementing these things, it's not just the ones and zeros, but it can also have a positive impact on your entire organization. So can salsa conveniently. What we're gonna focus on today is a framework, a supply chain level framework, the acronym of which is SLSA, which we just say Salsa. So I had Nova. Generate this wonderful picture of salsa for us, which is very appetizing. Luckily it's the last talk of the day, so maybe you can get some salsa after this at the, uh, whatever they call it, a thing at the end of the day, forget what it's called. This framework was created by industry in response to Attacks that became public that were very costly. And these attacks targeted the supply chain itself. So rather than target the machines that are running or inject malicious code into the pipeline or have them skip tests. This is about attacking the the infrastructure that runs your pipeline itself. And one such example that we discussed that we'll discuss a build server that was running the build was compromised, and accordingly anything that that build server produced then ended up being injected in this case into customer environments and customer accounts. So this framework was released to address these kinds of attacks. What we're going to do is we're going to dive into a specific subset of the framework and look at how codeBuild is able to help you move towards compliance in this area and then in the subsequent half of the presentation, my colleague here will show how the same underlying code build capabilities can be used when you use services like GitHub and Gitlab with codeBuild in behind as the compute engine. So this is what we're going to talk about today, security of the pipeline. There's different stages that we can concern ourselves with. Today, the focus of my opening part of the conversation will be E, so right in the middle here where you see build. Because we're talking about code build, our focus is going to be on what are the features of code build as close to out of the box as we can get that helps you move towards compliance and then no matter how you choose to use code build, whether or not it's with native AWS services like Code pipeline or with services like GitHubb or Gitlab, you'll get these same advantages no matter where you choose to orchestrate your pipeline from. In our case, just to scope the discussion, we're going to focus specifically on E and even within E, just build process, we're going to focus on the 1st 3. What I mean by the 1st 3, if you go online and you look for salsa, you'll notice there's some additional um entries, and there's one that's labeled NA, so we're focusing on the 2 L3 controls and then the beginning of the L3 control. Um, so this is a subset of E that we're going to focus on and we'll, we'll dive into each one. Before we dive into that, however, what is code build? So I've mentioned it a few times. CodeBuild is a managed AWS service, and what it allows you to do is run compute as part of your pipelines, right? So I can do things like compile your code, run tests, or produce artifacts. In our case, as we said, we're going to look at some of the out of the box uh features and functionalities that it has and how this can help move you towards uh salsa compliance specifically focused on the build portion of the the framework. So here's the first one that we'll focus on today. Which is generating false provenance and getting the trusted control plane to sign it. We're specifically focused on the the first part of this which is generating false providence. What we're going to focus on here is that when you use code built. And you want to start a code build job. So when you think of a code build job, you can just think of this as a predefined set of commands that you want um code bill to run for you. Right, they're diving into the details, you can put, you know, CD LS right, get clone, zip, whatever you want, right? You tell it which commands you want to run, and it will run it for you. You also get to pass it the source that you wanted it to point to, right? So you can say, here's my source code, my source code contains instructions for you to run these commands, go get it, and then run these commands. What's very important from a security perspective is that it's running what it says that it's running. Right, so it's one thing to trust it, but of course we want to know if it's said that it's running this build process against this specific source, we want to be able to know or prove that right because we can imagine that an attacker what they would want to do is they'd want to be able to say, oh yes, yes, you're using good source A over here, but actually you're using malicious source B over here. The built-in mechanism that CodeBuild uses in this case is when you start a new build, so that's L2 start start-dash build, you can pass in a source version. The nice thing about this is that's the only time that you get to specify that value. Right, so that value is then set by the control plane and there's no API call that you can make that says update that source version. Right, so once that source version is set, you are now very confident that this is in fact the source that the job is running against. I put L3 here, maybe I should have put L2 plus. It's an additional consideration I'm putting in here in the, in the code build land, which is another control I'd recommend putting on top of this is also restricting the source that it can pull from. Why is this important, especially in the context of Providence? The reason this is important is because you can imagine, let's say I have my um source code that's running, and then let's say I have a command that's something like get clone from some other repository. In order to get to this point, we might have done a bunch of static code analysis in order to get here. If I pull in code that hasn't been scanned through a get clone command, then now I'm not so sure that the thing that I'm deploying went through all the checks that I meant to. Also, that source version that we talked about, that source version is going to have your primary source for your code build project. If you're now pulling in code from elsewhere and running it on your server, that source version claim has kind of a precarious relationship with the truth. That is the source, but it's not the only source anymore, right? So as an additional level of control, what we recommend is make sure that you lock down access to other source. And this becomes even more important when we move on to our next thread. So, OK, this is good. Our security team says, I trust you now. When you say that this is the source you're using, I trust that this is the source you're using. But now I want to make sure that the commands that are in source are the only commands that you're running. And the attack vector here is say that you have a code build server and it's running a build job. What if someone is able to SSH onto that server as it's running the job and then is able to start executing arbitrary commands? The way that one would accomplish this on codeBuild is through the debug feature. So on the bottom left there you can see you can put in a break point and then you can use the debug feature which gives you console access to your running build. This is very useful for debugging for intuitive reasons. Unfortunately this has the uh. Undesirable byproduct in a production environment of allowing someone to run commands that were not specified in your source. OK, so now your security teams are not so happy anymore. They're saying, OK, I believe that this is the source you're running, but I don't believe these are the only commands you can actually run in this environment. Maybe I SSH into the the build environment and after my source is done building my container and pushing it I then upload new malicious container afterwards because I have all the permissions because I'm in the the the build compute environment and then I push that and if anyone were to go audit me and look at the source, they'd say well there's no malicious push anywhere in your source. The way that we can prevent this is in production environments, and I'm going to qualify production environments in just a moment. We just disable this debug functionality. And And the way that you can do this, sorry, I thought I had another transition there. I do not, uh, the way that you can do this, so you can disable the debug functionality you can also prevent, uh, access to your code build environments through something like Port 22, uh, if you put your code build jobs running out of a VPC, my colleague will go into greater detail about that. But the crux of the issue here is that we just prevent SSH access. We just prevent the debug functionality for our, uh, production workloads. Now I said production workloads a few times. I'm gonna qualify that though. It may be intuitive to think, OK, yes, for my production workloads, I don't want that, but I'm going to permit that in dev and maybe test depending on how you set up your environments and your deployment processes. This depends on how you deploy though. In the case of, keep on thinking I have more transition. I'll go into further details and subsequent slides. In the case of AWS we have something called the deployment pipeline Reference architecture DPRA. And one of the things we call for, which aligns well with the Salsa framework, different controls we won't talk about today. But something that you want to be able to have confidence is is you generate an artifact. And then that artifact gets passed through your pipeline and ultimately is the thing that you deploy and end up signing, right? You don't want to create 10 artifacts and recreate them every time and then deploy 1 at the end, right? That's important to our discussion because. If you start generating artifacts at the beginning of your pipeline, even in the dev part of your pipeline, ultimately if those artifacts are getting deployed into production, then you have to make sure you're secured right from the get-go. I So when we talk about locking down those capabilities, we'd recommend doing it right from the beginning of your pipeline if it ends up going into production if you need that debug functionality, use it in your sandbox environments or of course have great glass processes, but by default just have it disabled to make sure that you're not having more flexible dev environments producing artifacts that ultimately then end up in production. Third one This one is, has the most slides on it, and the reason is because this is the one that's most closely linked to a public example um that you all may be familiar with or you can, you can find on the internet. And the attack vector is, you have a build server, which is great, and your build server intuitively runs builds. Unfortunately, what's happening here is that. A change made to your build server can persist across numerous different builds, right? Or across numerous different environments depending how centralized your centralized build server is. This is unfortunate because if someone is able to make a change to the build server, this means that every build that gets run on that build server is going to be compromised. This is an unfortunate situation to be in. Luckily, as we'll go through in subsequent slides, when you use a service like CodeBuild. You're protected against this centralized build problem when you're implementing these kinds of patterns on prem, it's something to be very careful of because it's very intuitive and easy just to have your build server and run your build jobs on there. Luckily when you go to the cloud, this kind of thing is is built in and mitigated against. So the example here is every time that you run a code build job, and I'll define something here, so you create a code build project and then every time that you invoke that project, you'll have a new code built instant spun up that's going to run the commands that you specified. Which means if I have, I'm oversimplifying here but we'll add. If I have one code build instance that ends up deploying into dev, then only dev is potentially at risk, right? When I go to deploy into test or production, I have a new instance. So if anyone was able to SSH in and make some change to that code build instance, as soon as that's done running, it's gone. Right, so the attacker would have to SSH into every single instance across every different uh pipeline to get um the same kind of attack, uh successfully executed. And it's even a bit better than that. Because if we look here, probably what you have is multiple different code build jobs run even as a single step, and then each one of those is its own instance so you can see by using something like code build which creates new instances every single time you create a new code build project you're making it much more difficult for your attacker to make a change that's gonna persist across environments and also across promotion um environments. So the attack vector unfortunately that was seen in production through centralized build servers was a change made to a centralized build server that deployed into production uh customer environments so every customer unfortunately that went through that build server was ultimately uh vulnerable to this to the same attack. So here we go. We've talked about just the the E category of the salsa framework that we talked about and even within there we focused on the 1st 3, if you go look it up, be the 1st 3, not counting the one that says NA, and we've discussed how codeBuild has features that out of the box will help you move towards compliance in these areas. These green check marks are perhaps overly generous for the sake of this conversation because it's a 200 level talk, we're just focusing on code build specifically and code build out of the box uh capabilities in order to get full L2 or L3 compliance, often there's the need to incorporate additional, uh, services and features. So if you'd like to dive deeper into this, uh, I'd encourage you to come see us after the talk or reach out to your account team who who could help you dive deeper into this topic. But for now what we have are features that we can use. That will help us secure our workloads no matter where we deploy them from. So the last nuance I want to introduce is you'll notice on all of the slides when I referred to an orchestrator, I was very generic. If you've worked on AWS, you may know we have a service called Code Pipeline. Code pipeline is the service that can orchestrate other services. One common service in that space is CodeBuild. I didn't call it code pipe pipeline very intentionally because everything we talked about is equally true whether you choose to use something like code pipeline or you choose to use some other orchestrator. In the case of this talk, the two that we're going to focus on are Gitlab and GitHub. So for that conversation, I'll turn it over to my colleague who will guide you through that discussion. Thank you very much. Thank you Jason can everyone hear me? Thank you. Awesome. That was really informative, Jason. Thank you so much. Thank you again everyone for joining the session today. I know it's super late, but we're almost at the end of it. Um, before we start discussing AWS code bill for manage GitH Action, self-hosted runner, let me ask you all a few questions. How many of you have used CodeBuild? Can I please see your raise of hands? Nice. And how many of you have used CodeBuild with Github as source control? Nice. And how many of you have used GitHub, uh, with could build as a runner project? Super awesome. So I'm Shalab ***, and I'm a desec Solutions architect, and today we'll explore how you can set up code built runner projects with GitHub and the similar experiences for Gitlab, but we'll focus on GitHub today and how you can enhance your security by using different integration patterns with codeBuil runner projects that would help mitigate the salsa threats that Jason discussed right now and more. So let's look at some of the features of code build hosted runners. With AWS code build managed runners, you no longer need to maintain your own GitHub runners. Code build runners provide a serverless, customizable and flexible option to maintain your own, um, repositories. With GitHub action, with Git action pipelines and an ephemeral and scalable run environment with strong security boundaries and low startup latency. You don't need to maintain your own infrastructure or build your own scaling logic as it's all carried out by code bill. These runners also allow you to gain control over the environment where your code is built, tested, and deployed. This reduces the security risks overall and also reduces the cost of maintaining the servers and gives you the ability to use a specific tools and technologies that may not be available in GitHub hosted runners. So using CodeBuild, you can get central visibility into um logs using Amazon Cloudwatch. You can leverage AW Secret's manager to get seamless integration with CodeBuilt to store secrets and sensitive data securely. You can also map users, groups, and uh and roles from on-prem AD or LDAP to specific roles within IAM. You're also able to improve the security of your pipeline by interfacing with Amazon virtual private cloud cloud endpoints. You're able to improve the overall security by getting the support of code built in all regions, and you're able to manage, uh, your CICD processes by using different compute platforms that are available via code build. To get started, simply create a workload to uh automatically trigger the GitHub Action's job in code build. You can do so by leveraging AWS code connections using personal access tokens or an OR app or a GitHub app while setting up a code build runner project. This is different from when you use GitHub as a source control. When you use GitUb as a source control, imagine you have a recipe that is a source control, right, source code. And uh when you're using GitUp as the source control, you are able to retrieve that recipe from your cookbook, which is the GitUb repository. When you're using code build as a runner project, then you're able to get the facility of a well equipped kitchen, that is a code built under their environment. Using code connections, you're able to get the benefits of the code built runner environment, that is the well equipped kitchen, but you get to cook at the comfort and the safety of your home. Bitcode connections to get the ability to either use, um, uh, the bills by GAML files or the GitHub action jobs. Now let's look at some of the benefits of code built runner projects with code, uh, connections, reserved capacity. You can leverage reserved capacity with code build runners to maintain persistent code built environments, reducing build startup times and making it easier to compile software. Diverts compute platforms. Code build offers various compute platforms as I mentioned previously, including Lambda, Windows, Linux and based instances powered by graviton processors. So you can select the environment that best suits your project needs. Native AWS integration. Self-hosted runners and code build benefit from native AWS integration that provides seamless connectivity with other AWS services. So for example, if you want to use IM to secure access control, you can do that. You can use secret management via um AW Secrets Manager. You're also able to get auditability using AWS's cloud trail. And get RDS proxy integration. This allows you to securely access AWS services, uh, during your bills like Amazon RDS or Elastic cash. Managed self-hosted runners, cold bill supports for managed runners hosted on AWS frees you from maintaining these infrastructure. Now you can focus on your source code and be able to run CICD pipelines effectively. Fine green security controls, repository level access controls, branch level permissions, and ability to restrict access using IM principles provides fine green security controls and source code integrity. Encrypted connections using TLS 1.2 or higher. Private endpoint using AWS Privatein provides no exposure of source code to the public internet. If you do not use code built, you have to manage the credentials using STS or OIDC that require you to regu regulate these credentials by rotation or exchange. This is an anti-pattern for code build. With code bill, you can easily use specific roles with least access out of the box. YDC connection is a one-time process for most arcs, but the Cret's rotation is still tedious and is not secure. When CICD was new, we would create a role that would have access to AWS and we would use keys that would have connection to your respective platforms, but that also needed manual rotation. This became better when OIDC connection was introduced, but it was still a high risk activity for most orcs. You can make this better with trust policies, but then trust policies can easily be abused. When trust policy is not tied correctly, you can end up giving full exposure or no exposure at all. Osy still has a wide scope. Bitcode build runner using code connections, N is tokenized using the OIDC connection, but at the same time, O Z is also tied to a specific project or fleet. Using AWS code connections, you get zero standing access, which eliminates the need for long-lived credentials or access tokens and implements the access patterns for just in time access to the repositories or source code. Authentication and authorization as I mentioned before, AWS code connections provide access using OR 2.0 integration with source providers and supports multi-factor authentication. And provides the seamless integration with IM so that you can have the least privileged access credentials. All right, now let's look at some of the best practices for code belt. AWS code built threats integration with IAM helps mitigate several salsa threats, most of which Jason Jason mentioned previously, particularly related to build integrity and unauthorized access. Could build service role with least privilege. B CICD was new. Nobody was concerned about build integrity. Build process has a lot of access, including access to the code engines, build engines, which is a huge target for the attackers. If an attacker has access to the source code, they may also have access to the build process, and they can have the ability to manipulate or tamper with the source artifacts or artifact repository. With the principle of least privilege, you can set up your code bill service role to have the least access so that it, it prevents the attackers from getting the ability to manipulate or tamper with the artifacts. You can set up a specific roles with actions, for example, code build start bid, code bed build artifacts, right, which will prevent the users from performing actions beyond these actions specified in the build role itself. You can also use specific arts and patterns for the resources that the code built accesses. This will prevent the an attacker or a malicious user from accessing any resources beyond the resources that are specified in the code bill rule. Restricting code built actions and resources using IM condition keys. First, we have this project and build on condition keys. You can leverage code build project RN and code build build on condition keys in IM policies to restrict API calls originating from within the bills, bills to a specific project and bills. Prevent unauthorized modification using condition keys like code built source buildspec, you can prevent unauthorized modifications on the buildspec files. Control compute types. You can even restrict the type of compute instances that can be, that are going to be used for your build runs by using condition keys like code build compute, configuration instance type. Securing access to build resources, ephemeral build environments. You can implement ephemeral build environments that get spun up and destroyed every time a build executes. This prevents a malicious actor from gaining persistent access to a code built environment. Build cash isolation. Ensure bill caches are isolated between bills to prevent cash poisoning attacks where an attacker injects malicious dependency or an artifact into the cash that is later used by a legitimate build. Example using principle, you can specify the IM role that is allowed to access the bucket. You can do the reverts as well. Any resource that is being accessed by the code bet can have a resource policy set up so that it only uses the arm of the code bet which it can access. BPC connectivity. If your code built projects need to access resources within the BPC, you can configure BPC related information in the project configuration to enable this access, and we'll cover this in just a few minutes in the next slides. Now let's look at another example here. A scenario that Jason discussed in the session in the previous slides was the debugging capability within code bills by a sandbox or session manager. When we were talking about the salsa threat related to compromise project owner. Though useful, but we do not want the debugging capabilities when it comes to the production bills. This is because these debug bills can often contain information that has sensitive data that would let a malicious user know the internal workings of your application or security vulnerabilities that can be exploited. We can prevent this by adding explicit deny permissions within your code bill service role. You can see that we have the explicit deny permissions for the SSM and similar way you can also have explicit deny for sandbox environments. So using these different IM approaches, we are able to prevent unauthorized modifications to your resources and bills. You are able to implement the least privileged principle. You get controlled access to your build environment and resources, and you're able to enforce organizational policies. You can also leverage IM Access Analyzer, which provides the capability to analyze and uh uh all the access patterns, identify the potential security risks, and validate your IM policies. So leveraging the IM capabilities with code build, you can significantly reduce the salsa threats that we discussed previously, particularly Salsa e-threats around the compromise bill process. And when it comes to compromise project owner or poisoning the bill cash, this can be really helpful. Now let's talk about BBC integration with Code Bild. If you're looking to augment or build security with network security, that is you have your source code or artifact repository within the same network, then and only then running code build within the VPC can provide this extra level of security. Code Bill can modify other resources in the BPC but that is out of scope for this session. I'm happy to discuss with you folks off stage about this. Using BPC for your source code and artifact repositories is important because your source code or artifact repositories can have sensitive data and needs to be protected by network security. The con here is that you will need to manage your repositories on your own. You cannot use a SAS provider. Using a SAS provider causes a network exposure here. AWS code built integration with VPC also helps mitigate several salsa threats. Especially the ones related to supply chain software attacks. Prevent compromise of source code. Code bill can be configured to access resources that is the code repositories or artifact repositories only through private IP addresses within the Amazon network. This restricts the built environment to approve sources and prevents it from pulling code from untrusted or um third party sources which are not approved, thus mitigating the threat of using malicious source code. BPC integration also allows for build integrity. You're able to um have you're able to have your code built access critical resources like build dependencies or artifact repositories, example, Maven, PyPi, etc. within the private BPC. This isolates the build process from the public internet, thereby limiting the opportunities for malicious attackers to inject dependencies that may have um malicious code. You may enhance your build process control by enforcing network security policies that would restrict the build processes access to the external public network. Secure artifact generation and provenance. When code bill generates artifact and provenance data, this data can be linked to a secure build environment within the VPC, thereby providing a higher level of security for the artifacts that are generated during the build process and also provides for the build integrity. You can further leverage condition I'm I'm conditioned keys that we talked about previously within the build role to limit the BPC connectivity. You can make your code built access only specific uh resources within the BPC by using condition keys like code build VPC config, BPC ID. So with VPC extension of code bill, you're able to mitigate some of the salsa threads that we discussed previously. Salsa D thread, which is the build from modified source, including the bill from unofficial fork of code, and you're also able to mitigate the compromise of build process. Now let's talk about logging and auditing capabilities within the code belt. And how code Bill can help you further enhance security using these logging and auditing capabilities. So as we talked before, CICD is a big target for attackers looking to get privileged access or escalation. The best practice is to have end to end security right at the source and at the CICD pipelines as well. This begins with detection. To get a centralized visibility and detection, you need to have the code-built execution locks and VPC locks available. To get a centralized visibility, you can integrate code bill with Amazon Cloudwatch that will give you the centralized visibility for detection. Additionally, you need to have the auditability to be able to see all the events that are related to a build in order to make sure who and what intervened in the build process. This includes the events in the code bill from starting, stopping to also even editing the code bill project itself. Now let's look at uh some of the benefits and some of the uh salsa threats and the threats security threats that Jason discussed with that code built integration with Cloudwatch and Cloudtrail helps mitigate. AWS Cloudtrail provides a record of all the actions taken by user role, or any other AWS service for that matter. Cloudtraillocks all the code built API calls, including the actions, as I mentioned, like starting, stopping, or editing of the code built by a person or by a service itself. Cloud logs can also reveal the source location where uh which was used to edit the build. So by verifying the provenance against this against the specified information, you're able to detect if a build was originated from an unknown place, right? You can determine the IP address as well using the cloud trail logs. Clouder logs document all the artifact publication events. If you combine this with salsa in total attestation format, then you can verify the upload of the provenance data with the expected format. We're not covering attestations in this session, but I'm happy to again talk about it offstage. You can even get the audit trails for actions taken by administrators. This enables organization to detect and investigate if any platform administration has been compromised and made an unexpected change within the code bill. So combining cloud trail, cloudwatch, code build, and in total format for the salsa at stations, you can mitigate some of the threats related to Salsa E which is compromise build process. Specifically compromised build platform admin that we just discussed and built from modified source which is the salsae thread and salsa F thread which which is the tampered with the provenance data and as I mentioned, you can use it in total salsa format to validate if the package or provenance has been manipulated or tampered with by someone. Through these configurations and patterns for code built hosted runners, you can provision defense in depth for the entire CICD process. It it starts with encryption using KMS. We didn't cover KMS in this session, but again, like I'm happy to discuss offstage. That's a completely different talk altogether and would require another 60 minutes. But then we did discuss BPC that provides network level security, and you're also able to augment using, uh, the security of the pipeline using IMD's privileged access. So in addition to the salsa threats that Jason mentioned before that were that were mitigated or at least were reduced in risk when we we were using code bill, you were, you are also able to mitigate the threats related to bill from unofficial fork of code, poisoning of the bill cache, compromising of the bill platform admin, or tampering of the provenance data. So how does the integration look like in GitHub? All right, now let's go through a quick demo. This is the code built homepage. We, we are going to create a new project. We'll just type the name as this project here. And you can see that there are two options to create the project. It's the default project or the runner project. We are selecting the runner project here. You can see that there are options to select different runner providers GitHub, Gitlab, GitHub Enterprise. I chose GitHub here. There are options to select the runner location, which is repository, organization and enterprise. I used repository, and you can see that I had already used the path token to connect using the code connections with GitHub. You can always choose a different method. By using a GitHub app or WhatsApp as I mentioned before. Now if I head down to the buildspec file, you can see that there is an option to either use the buildspec YAML or use the GitUb Actions job which is already present in your GitU repository. So I've already created a project here that uh is a runner project. So we'll head down to that project. And you can see that it's tied to a GitHub repository. That's a test repository. And within that repository you can see that I have some sample get up workflows which we'll come back to in a minute. So if I open this project and go to the project details, you can see that there is a runner configuration added. Within the runner configuration, you can see that there's a webook and there's a repository, as I've mentioned that is linked to it. This webook gets created automatically when you use code connections to create a runner project. You don't need to create this web book manually so you can see it's easily usable when you just set up a code build on a project with code connections. Going down further and looking at the code bill server role, you can see that I have two permissions attached to it. One is the default code bill service role permissions where you can modify and add the least privileged, and the other I best practices we discussed for demo purposes. I have admin access here, but then we, it's really not recommended. Now, going back to the repository, which is tied to the code build project, we look at the workflows. Within the buildjaAL, you can see that I've updated the configuration for Runson to use the code built project itself instead of using Ubuntu latest. This would enable the workflow to run on that code runner, and you can see that I have a job. Again, like a minute earlier, yeah, we have a job for listing the S3 buckets. So using the permissions that I have within the code bill service role, I would be able to get those commands executed. I'm just making a test change within the readme file here to show how the bill runs and whether or not that command executes depending on the service role permissions. I just made a commit here, and we should start seeing the build executing in the workflow momentarily. Here's the, here's the bill that starts right now. So as you can see that the build is getting triggered here, if you go back to the code build runner project, we should see a code build uh executing there as well. So you can see that there's an inres build status for the project that we had set up. Now if I go back to the workflow and look at the build logs, we should be able to see that we were able to execute the AWS S3LS command where we were able to list all the S3 buckets. And again, since I had the admin privilege, I get the S3 buckets, but then if I could restrict it to specific arms, then it wouldn't give me all the buckets but the ones that I have access to. And if I go back to the runner project, you can see that the build execution has been succeeded. And within the logs you can see that I was able to connect to the GitHub using the connections that I set up in the runner project. So this is what an integration would look like when you have a code built on a project running on GitHub, and uh the execution logs are visible here. Moving on So summarizing the entire talk, we discussed the security of the pipeline, we discussed salsa threats we talked about distributed runners, we talked about code connections with code built and how we can use different integration patterns like IAM VPC, and even cloud trail and cloudwatch to use the best out of the security that we can get within Code Belt. You saw the salsa threads that we were able to mitigate using all these integration patterns and by using code built out of the box, and we saw how we can integrate GitHub with code build runners. If you want to learn more about Salsa and or if you want to learn about the tutorials how to configure code built hosted, get a Actionsunner or Gitlab runners, these are the links here. I'm gonna let this slide open for a few more seconds so that you can take a pick or scan the QR code so that these these are available for you later on. Thank you again so much for joining us today. I'm Shallabbnikam and I'm a DeSAO Solutions architect.
