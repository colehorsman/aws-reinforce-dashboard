# AWS re:Inforce 2025 - Coding for proactive controls with AWS CloudFormation (GRC441)

**Video Link:** [Watch on YouTube](https://www.youtube.com/watch?v=_7Cs8fMppRE)

## Video Information
- **Author:** AWS Events
- **Duration:** 44.8 minutes
- **Word Count:** 7,652 words
- **Publish Date:** 20250618
- **Video ID:** _7Cs8fMppRE

## Summary
The presentation focuses on AWS CloudFormation Hooks as a proactive security control mechanism for Infrastructure as Code (IaC). Presented by David Killmon (Principal Engineer) and Joe Allioto (Solutions Architect), it demonstrates how organizations can implement guardrails before resources are deployed to prevent security issues, cost overruns, and configuration mistakes.
The speakers emphasize the importance of "shifting left" security controls in the development process, especially with the increasing adoption of generative AI and other modern development practices. CloudFormation Hooks can integrate with various IaC tools, including Terraform, allowing organizations to enforce standards and prevent non-compliant resources from being deployed.

## Key Points
- CloudFormation Hooks enable proactive controls before resource creation, rather than reactive fixes after deployment
- Hooks can be configured to either warn or fail deployments based on organization requirements
- Organizations can enforce security standards (like SIS-2) through hooks without manual intervention
- Hooks help prevent common mistakes like capacity reduction typos or non-compliant resource configurations
- The feature supports both security compliance and cost optimization use cases
- Developers receive immediate feedback about non-compliant configurations before deployment

## Technical Details
- AWS CloudFormation Hooks integration with deployment pipelines
- S3 bucket encryption enforcement capabilities
- Auto Scaling Group capacity validation features
- Lambda function endpoint controls
- EC2 instance type compliance checking
- Integration with multiple IaC tools including Terraform
- Support for different evaluation modes (warn vs. fail)
- SIS-2 framework compliance checking capabilities
- Resource property validation (e.g., managing Lambda runtimes)
- CICD pipeline integration points for hook evaluation

## Full Transcript

Morning y'all. re:Inforce. Welcome to re:Inforce. Um, my name is David Killmon. I am a principal engineer on the AWS cloud formation team, and joining me today is Joe Allioto. Yep, and I am a specialist solutions architect that focus on cloud ops here at AWS. Yeah, uh, and today we are extremely excited to talk to you about cloud formation hooks and how to do proactive controls in your IAC. Um, I am. Like I said earlier, a principal engineer on the AWS cloud formation team, but even I recognize that cloud formation is not the end all be all of IAC. So Joe will actually be showing us how we can use cloud formation hooks with other IAC tools like Terraform today as well. All right, so let's just kinda dive into it. All right, so this may look familiar to some of you. This is, you know, generally what provisioning with IAC looks like, uh, talking about cloud formation right now. Um, you start off with your code, you know, you commit it to, um, your repo, run some CICD pipelines, do the test, the deployment, make sure that, you know, everything's functioning as well, and you get resources, right? Uh, a lot of us are really familiar. With those patterns, but how do we implement some guard rails around that, right? So kind of shifting left some of the responsibility, or I shouldn't say the responsibility, but, uh, shifting left some of the guard rails to ensure that what you're deploying is what you should be deploying, um, whether that's related to security, whether that's uh related to cost and making sure that when you deploy something you don't get a call after hours, um, see if it goes there goes the little car keeping you in the guardrails, right? Um, and so that you're not getting those calls after hours or saying, hey, you deployed something that isn't within the requirements, um, for this specific environment, um, so a lot of the IAC development has been changing a lot lately. um, we've all heard of generative AI that we're not gonna talk a lot about that today in this talk, um, but. Developers are, you know, commonly experimenting with that, starting to develop, um, using that and maybe vibing a little bit here and there. So we need to make sure we have guard rails that can be more to the left that as you're trying to build and deploy that IAC you're notified before those resources are created or, um, uh, those resources are stopped from being created, um, so that you're maintaining the specific requirements that your organization has. So, this is where we bring in cloud formation hooks, right? And we're shifting those controls more left, right? So you have your template on the left, that's just a cloud formation template. Um, you know, that generally gets uploaded to S3. Cloud formation can have hooks configured which can have different controls related to resources and the different properties like for lambdas you can manage run times. You can also manage specific security frameworks, um, like SIS-2 for example, like you could deploy a hook that is managing your resources at that level, um, so it's a lot easier to maintain those standards. And so as you try to deploy that you can choose various levels which we'll show you in a bit um to where it can be assessed, um, and either warn or fail at deployment and in this example we're showing that you know you tried to deploy this resource, it failed and so you're notified before that ever got deployed so you don't have to come back and you know build it again or destroy it and then build it. You can build it right the first time. And this is where cloud formation hooks like comes into the control narrative, so it's right below uh preventative controls right under proactive controls. Proactive controls are specifically around resource creation and so what we're doing is we're providing the guardrails around creating those resources so only the proper resources for your organization can be deployed, um, or you're notified that hey you need to maintain these standards, it's kinda up to you. And what I'm gonna do is I'm gonna go ahead and pass it over to David who's gonna go through some use cases, um, and I'll let you take it away. Cool. OK, um, so I wanna do a quick survey of the room, uh, who here like considers themselves like platformy security people like you, you're in charge of writing rules. Yeah, we got a few. Oh, we got a lot of you in the audience, nice, nice, um, who, who are my fellow developers, uh, the people for whom those rules evaluate against. All right, we got a couple of y'all in here too. All right, um, have any of your developers been paid for creating something like 15 minutes after the fact? Um, this happens, I feel like all the time for me. I remember specifically when, uh, Lambda launched its functioned endpoint feature a few years ago, I was so excited. I went into my little AWS console. You'll see it soon. Uh, I turned it on and I was like, this is great. And then I went home and I was like I was riding my bike home in Seattle. And uh my phone just starts going off like crazy and it turns out, uh, function endpoints were not something that we're supposed to be provisioning in our own accounts. Uh, so I just pulled over on the side of the road and pulled out my laptop and had to delete my lambda function. Um, so that. After that day we all got together and we were like we have to find a better way. uh, and so that's what hooks does. Hooks do you like prevent bad things from happening. So there's lots of different types of things hooks can help you prevent from happening. Um, in this case it's sort of a security related thing. This is similar to the story I just told you, um, so like. I'm an organization. I wanna make sure I wanna stop seeing COEs where people don't have bucket encryption enabled, right? So I just create a simple guard rule or a rule that says no more buckets can be provisioned through cloud formation unless they have bucket, um, logging uh bucket encryption enabled. So that's that's one. Really like great example of how hooks can be used. Another example is sort of targeted to people like me who are really prone to creating typos. Um, so this is a real life example, uh, of an auto scaling group where I accidentally set the max size of my auto scaling group from 100 to 10. Um, if this change got deployed into production, my auto scaling group would have lost 10 10x its capacity, um, and all because of a silly typo. So this is a real, this is a real rule for my team where, uh, we have this check that makes sure that, um, resources with provisionable IOPs like auto scaling groups or Dynamo DB tables or EBS volumes don't have a dramatic reduction in capacity, um. This book is really interesting because uh it can fail, uh, you know, it can say hey like this failed the rule, but it also doesn't have to block provisioning. It can provide me as a developer a warning saying, hey, are you sure you want to remove all of your host capacity in production? Um, so this is a super useful, uh, example of how hooks can help not just stop bad things from happening but stop accidents from happening. Um, and finally, another example is, uh, following sort of organizational best practices. So in this example, uh, there's a certain type of EC2 instance that my organization wants me to use because we have a savings plan for it, um, so when I try to provision something, you know, if I just go to stack overflow. Or like find like how do I create an EC2 instance uh and I just use the M3 XLRs like everyone in the entire planet does for all of time. Uh, my hook, my organization can say, hey, actually David, before you provision this like $10,000 an hour EC2 instance, maybe try one of these other instances first. Uh, so. These are super cool. Uh, we, we are working on hooks a lot in the past year was sort of our focus and confirmation on the security side. We've launched a lot of new features, uh, including different times when hooks can run. So running them, uh, the core of hooks is we stop bad things from happening, but you know, Hooks is built by developers, so we also are trying to improve the developer experience by. Surfacing those errors super early on in the development practice, so offering different places where those hooks can run earlier in the development process, but also expanding beyond just cloudation, we totally understand that cloud formation is amazing and generally considered a perfect piece of software, uh, but it's not the only thing people use, right? So expanding that to other IC tools like Terraform. Um, cool. So talking is cool, but coding is better. That's, that's what they pay us for. Um, so I'm gonna press the HDMI button and take you to my AWS console. OK, um, cool. Alright, so let's create a hook, everybody. So by the end of this like little code talk, I'm gonna show you us creating a hook. I'm gonna show you how it catches like terrible, awful things and how to debug using that hook. Um. So let's just get into it. So I'm gonna go to cloud formation. This is, this is my like play account in at work, uh, so you can see I have some fun stacks here. Could you zoom a little bit? Yeah. And you can see on the left there's this section called hooks for hooks, um, with a hooks overview, and this hooks overview page is super useful. It provides a much less colorful version of what I just described to you, hooks being a tool that can stop bad things from happening. It can help enforce organizational best practices, cost saving stuff, um. uh, stop your developers from accidentally fat fingering their entire auto scaling groups, uh, but, uh, so, so it's super useful, but now we're actually just gonna go ahead and go create, uh, a hook. So there's two ways you can create a hook. Um, you can create a hook with a lambda. So basically you give us a lambda function and you return yes, no, and we provide you all the information we have about the resource being created or updated, um. That's super useful, but I'm gonna just, I'm gonna use GAR, and I'm gonna show you why in a second. So GARD is um AWS's declarative policy as code language. It's a pretty, uh, concise DSL for describing, uh, what can and cannot happen based on certain rules, but my favorite thing about GARD is that, um, I don't have to ever write guard because, uh, uh, sorry. Uh, in guard, uh, we have this open source registry on GitHub called the AWS guard rules registry which has a ton of rules already defined for a bunch of different resources. So let's find a resource that I, I feel is often, um, a place of some concern. Uh, so these, these are all, uh, a bunch of rules targeting IM resources, uh, so one of my favorite. Uh, policies. So every year we get a bunch of new interns at Amazon who are really excited to go build stuff and in their eagerness they are trying to find the quickest path to success. The quickest path to success for our interns often includes creating an IM role with an administrator access. Policy, uh, so this guard rule, for example, makes sure that, uh, there is no star star policy allowed in IM, uh, for creating roles, uh, and, and there's a bunch of other exciting policies too. Uh, so, uh, I actually went ahead and cloned this repository earlier and I chose some of my favorite rules. So I have a Dynamo DB, a couple of Dynamo DB rules, an IM rule, um, some for Lambda, some for S3, and what I did is I, um, zipped them up. guard rules. And I uploaded them to S3. So I have, I have the, I just uploaded that same like set of guard rules from that repository. I didn't look at them. I just looked at the title. I was very lazy and I zipped them up and I put them into S3. So now if I go back to my hook, my guard hook, um, I can actually just say I can put that zip file from S3 into this configuration. And guard has a very verbose logging. It will tell you so much about what went wrong and why a rule failed or succeeded. And so I'm gonna tell GAard to write the results of its evaluations to the same S3 bucket just for convenience. Cool. And a really amazing guard hook. I'm gonna create this hook. I'm gonna call it the really amazing guard hook. And now in hooks, uh, this is sort of getting back to what Joe was talking about earlier. There's lots of different places in which your hooks can run. So today, uh, right now we're gonna target resources. So when your cloud formation stack is creating or updating a resource, the very first thing it does before it does anything with the underlying service is it's gonna call this hook, and it's gonna pass the content of this hook uh of that resource to the hook. Uh, for evaluation. We're gonna talk about these other ones soon too, don't worry, they're part of the, they're part of the act. Um, and we're gonna tell this hook to only run when resources are created or updated. Uh, I'm gonna tell this hook that if it detects a problem or if a rule fails, rather than warning me and letting provision continue, I'm gonna have it hard fail. This hard fail is gonna stop the thing from happening at all. And then I'm gonna call it, um, my very good guard. Uh, I'm gonna create a roll, and that role just allows that guard hook to write and read from S3. You can tell hooks, uh, just that, uh, target specific types of resources, but because I have a bunch of different rules for different resources, I'm just gonna have to evaluate every resource that cloud formation is provisioning. And I'm going to activate this hook. Oh, sorry, oops. Yay, let's see, did I do it. Cool, um, So I have my extremely good hook, uh, here, and we're gonna play around with it. But before we do, I wanted to show you something that I worked very hard on. So, uh, earlier this week, I asked, uh, a Gen AI agent who will not be named to generate a cloud formation template. Joe said there's gonna be no Gen AI in this talk. He's wrong, uh. Uh, I asked GI generated a super simple template, a confirmation template with an S3 bucket, a lambda function, and a Dynamo DV table, and that lambda function has permissions to talk to that dynamo DV table and S3 bucket. So this is a really simple template. we'll just go over it real quick. You know, it has a lambda execution role, a lambda function, an S3 bucket, a Dynamo DB table, and look, the Dynamo DB table even has a point in time recovery turned on. So it's not, it's a very, it's a decent template. It will work if I threw this into cloud formation 10 minutes ago, it would generate all these things. Um, but we're gonna see how this holds up against the, uh, Hook that we also just created, so I'm gonna create a a stack. I'm gonna upload the template, so. From the web, don't look at the the fixed ones. Um, this will probably work. I'm gonna create a stop. I'm gonna impress all the buttons. to create the Co. So, uh, Now, you can see cloud formation, I'm gonna zoom out a little bit just to show us the map. So the very first thing cloud formation started to do was it was noodling on which resources it was going to create. So it's gonna create a lambda execution role, a Dynamo DB table, and S3 bucket. But, um, when it, the first thing it did when it tried to create, for example, this S3 bucket, I'm gonna zoom over here, is it started invoking a really amazing guard hook. So you can see it's like, OK, like this uh resource matched the hook, um, the hook filtering, so I'm gonna run the hook first. And then, uh, when it tried to create all these resources, it failed because the hook itself failed. So, In this case, the uh guard hook the hook failed, and you can click it, um. And it has this little message saying like this hook failed, the template failed validation, the following rules failed. S3 bucket, default lock enabled failed. OK, that's a lot of words. Uh, but we can tell that this S3 bucket that we created did not pass that hook. And so let's dive into why that happened. Um, so I'm going to go back to S3 where, uh, the guard hook, uh, wrote its validation report. I'm just gonna take a look. You can see that a lot of different resources failed my Dynamo DB table, my lambda execution rule, my SG bucket, they all failed, uh, validation. I'm gonna check that logs to see what happened. OK, so this is, uh, when you run guard, you get this like really nice JSON output. Um, when we write the logs to S3 from the guard hook, you get a really, really detailed um explanation of what went wrong. So, in this case, the rule S3 bucket, uh, default lock enabled failed, um. And it could not find the object lock enabled property of my S3 bucket. And It's saying that in order to fix it, I have to set object lock enabled to true. OK, I don't know what object lock enabled is in S3, but I'm gonna go look at my template and I can see that I have my S3 bucket. There are literally no properties. So what I'm gonna do. Because I'm gonna add a property, and I don't know what this property is, it's telling me to set it to true, so object lock, enabled must be set to true. OK, cool. So I said this to true. So let's see what happens if I try to create that cloud formation stack again. So I'm gonna upload my. This will really work. Recruit my staff. Boop boop boop. OK. OK, so you can see that confirmation tried to do a bunch of stuff again. This time it still failed. Why? Why did it still fail? So let's go take a look. Um, OK, so this time it failed but failed for a totally different reason, right? SV bucket public read prohibited is not set. This makes sense, right? If I have a bucket, I probably don't want it to be publicly accessible from the internet, and I want to be able to say like this bucket is prohibited from um. Uh, being read. But this developer experience kind of sucks a little bit, right? Like having to go through cloud formation and try to upload a stack and then wait for it to provision resources one by one and wait for the results of this hook to happen. Um, it's really slow, right? It's just so slow and especially when. Once you start throwing in resources that take longer to stabilize, right, like your ECS services, your cloud front distributions, things like that, you don't wanna have to be using like, um, upload, like your development cycle should not include updating a cloudation stack and waiting for it to finish. So luckily, uh, hooks can help with that too. So I'm gonna go back to our cool guard hook. I'm sorry, a really amazing guard hook, and I'm going to edit the behavior. So Right now this hook is stopping bad things from happening, right? I couldn't provision an S3 bucket that was not, I didn't have object lock enabled. I couldn't provision a bucket without read uh access block, um. But I actually want this hook to run earlier, so I'm gonna tell this hook to run whenever I create a change set. And now I'm gonna show you what that looks like. So, I'm gonna go to, I'm gonna try another stack. Oops. I'm gonna choose the same template uh that I was just looking at. Um, Hopefully this works. I'm gonna tell it it's we're chill, and this time instead of pressing submit and creating the stack and going through that whole process of cloud information actually trying to provision, I'm gonna create this thing called a change set. Um, quick show of hands, has anyone here used Change sets before? OK, cool. Lots of folks. Basically a change set is a plan that cloud information generates before it starts to do anything. It's gonna tell you, here are the resources I'm gonna run. I'm gonna try to create, here are the resources I'm gonna try to update, and here are the properties I'm gonna set, um. But you can see when you have a hook that blocks, uh, that targets the change set, before that change set becomes executable, your hook can actually run and evaluate um Your set of proposed changes as well. So I took the same exact hook I had, the same exact code, the same exact rules that were targeting my resources and had them run on the plan that the change that was going, was, um, generating. And so now you can see I get all of the error messages up front like it evaluates every resource that's gonna be created, updated, or deleted. And you can see it's like, oh, OK, great. My Dynamo DB table must have encryption turned on. Uh, I have a IM roll with administrator access just like our interns, and my S3 bucket still has, uh, doesn't have read prohibited turned on. So, um, this is a much like faster development loop for me as a developer because I can just in one place see all the rules that were evaluated and whether they passed or failed and get all the details um in one, in one file. So, I just want to show you real quick. This is sort of where we were, so I had this lambda function. It's really cute. It seems fine. I have my SV bucket. I had object lock enabled, uh, turned on, and from this, I'm gonna use a little bit of movie magic to actually fix this for us. But now, like, because of those hooks telling me, hey, David, you're trying to create crazy things, ah, um. I was able to go through and in response to all those rules failing update this template. So in response to the IM role having administrator access, I put in a least privileged policy so I gave it a basic rule, uh, role that um policy that allows that lambda function to run, um, and gave it specific access to the S3 bucket and the Dynamo DB table being used in this template. Um, my lambda function was totally fine and perfect, so I have no critiques for that at all. It's a work of art. Uh, my S3 bucket, we saw I added object lock enabled earlier, but now I also added this public uh access block configuration. And in my Dynamo DB table, um, I had a point in time recovery turned on, but I also turned on server side encryption. Uh, cool. So, with this new, new and improved template, I'm gonna go and try one more time. To create my template. Um, I have my movie magic version. I love um policy as code. OK No. Next, I'm gonna create a change set. And now you can see that like our hook is running. And this time, the hook passed validation. So I can go and actually look at all the changes and um uh sorry, here are the changes. I'm gonna add all these resources. They've been pre-vetted, they're compliant. I'm gonna execute this change set, um. And now, you know, even though the like hooks ran at change that time, they're still gonna run um when creating the stack as well when the resources themselves are provisioned. Um, so that's a super quick rundown of going from 0 to like pretty decent policy enforcement in my account using cloud formation and cloud formation hooks. Um, I'm gonna hand it over to my buddy over here to show you how the same hooks and policy and all that stuff works with terraform. Cool. OK, awesome. Go ahead and just I'm gonna switch it over. We're back. All right. So as I get set up here, um. Has, has anybody written a guard policy? Anyone? one couple? Actually, I'm surprised that's great. Um, does anyone use Terraform today with either their platforms or anything else? Yeah, awesome. Great. Let me get in here. Just give me a second, make sure we're good before I switch over. I'm gonna refresh this. All right, awesome. Cool. Let me get connected and we'll be good to go. All right. Demigods, yes, we're in. Awesome. All right, so, um. What I'm gonna do is I'm gonna cover actual like the creation of a guard policy, uh, something you may have noticed if you're looking very closely at, um, David's cloud formation template, he was deploying a lambda function that was on no JS 16. That's a deprecated run time. Uh, you probably don't want to be deploying deprecated or soon to be deprecated run times that you're gonna have to update soon. You probably want to control that and have something a little bit more recent when you deploy that. Um, so first off, I just want to show you, I'm not gonna create it again. Oh, whoops. One second. North Virginia All right, so I already created it. We're gonna look at what this guard policy looks like, but I just wanna show you something a little bit different here. So when I go to this, Um, what I'm using is the cloud control API. We looked at this previously, right? We looked at the resources and the change sets, but, um, with Terraform we offer not only the provider that's the AWS provider, but there's also the AWS cloud control provider which is the AWSCC provider, which will enable you to be able to utilize hooks. We're doing the same thing looking for the actions of Creator update and we're gonna fail on those. And so, uh, before I jump into the policy, I'm gonna deploy it now to give it time to deploy the resources and fail and then we'll look at the policy. So let me go ahead and do that. Hopefully my credentials are still saved. We'll see. Alright, we'll give it a second. Just wanna make sure we see. All right, it's doing things. All right, great. OK, so I'm gonna just switch over here so we don't have the scrolling and we're gonna just kind of block out one thing at a time. Um, so what I have here is that guard policy that I created, um, some of this may look a little familiar like what we're doing to start off is we're creating a variable using LE called lambda functions, and what that is is, um, we're looking at the resources in a cloud from like in, in the, um, cloud control. Uh, provider, right? If you think of the cloud formation template, there's always that resources section and then you deploy uh define what those are. This is basically using that same, um, like methodology, but like where do you find this, right? How do you know what resources you're defining and so let's take a quick look at that. We have the AWS resource and property types reference, and so I know I want to do a lambda function, so I'm gonna go ahead and go to lambda from when within here I found the resource type, right? AWS lambda function. What you'll notice, and I'm gonna click through here for the next part, is that is exactly what I have to find here is the resources are all resources that match the type that AWS lambda function. So that's what I'm looking at first. Now next, What I want to look at and let's make space. I'm gonna try to focus it because that way we're just looking at what we want to hear is what we have is now we're defining the guard policy rule, right? We have the rule. And this rule is called the lambda already deprecated run times and so we're looking at when all of those lambda functions that variable we defined before any of the resources that are lambda functions are not empty for each of those functions we're matching the properties when the run time exists, right? And so how do we get that? Where does that even come from? So if we come back to the resource provider, what we have, if you notice, remember the type I mentioned before type lambda function that's where we define that the properties is from, you know, the property for that resource and then specifically the runtime version, right? So that's how we're defining. This specific area of the code. So next what we're looking at is, you know, when the run time does exist and the run time is not in these specific versions that the rule will pass, right? So these versions are deprecated run times. Where did I get that right? How did I know what they are? Back to the documentation, if you look at the allowed values, we can see all of the allowed values for that property. So we can start to define that to say if it isn't matching these rules, right, we are gonna pass this rule, but if we do match it, we're gonna output a message like we saw previously that says lambda function is using a deprecated run time, right? And so and and the way you just open and close it is kind of those brackets, right? Um, additionally, these are already deprecated run times. I want to know when something's soon to be deprecated. It's the exact same thing, but I'm using specifically no GS 18 and this provided run time, right? And then I have a different message that's saying lambda function is using a run time that is targeted for deprecation, so it's not deprecated yet, but it is soon to be, right? And so using that rule and using the resources guide, we can go through the various properties we wanted to find very granually and understand exactly what we want to allow or not allow, and be able to create those rules. All right, so let's take a look at what we have. And I'm gonna zoom this up actually. I'll just, I'll just go up all the way. Oh, we have an error. Can anyone tell me what that actually is telling us? Anyone? I mean, because I can't tell either. OK, so we're actually working on improving this integration with the AWS, um, cloud control API so that you'll actually get the message, but key thing that I'm gonna show you is we can get what the information is that's saying like what that failure is based on this ID. So what we have is, I'm gonna go back over to this little read me I kept, so I wouldn't typo, is you can look up the hook results for the cloud control provider with the ID provided for the failures. So I'm gonna copy that. All right, we'll come back over here. I can, if it wants to paste for me, we'll paste. There, there we go. I'm gonna grab the ID which is right here. All right, and then we're gonna paste that and when I run that, you can now view and let me do more and I'm gonna shrink it a little bit so we can read it. You now get more of an idea of what happened. So you can see that it was during the pre-provision process it failed it, right? It was the lamb time run time checker guard policy, right? It shows that it failed, it gives you that reason, um, that the lambda, uh, the lambda already deprecated run time. Um, you know, failed validation. If I wanna know more, if I'm a developer, I don't wanna like have to go into the console and change. I wanna do it from my terminal, right? So what you can do, and this is a little cool trick if you've never seen it before, is you can go AWSS3 where it saved it. You can copy the location and if you put this little dash, it writes it to standard out. So it's gonna write that file to your terminal so that you can read it. And now if you remember, what David showed previously from the JSON, you can just view in your terminal. Um, I think. The, the one thing like I mentioned before, is we are looking to be able to have the errors output a little bit more cleanly so you know what's going on when you initially get that output. But what I'm gonna do now is I'm gonna go ahead and fix that. So let's, let's fix it. Let's look at the, the TF again. So, um, this is my main terraform, very simple. It was the exact same thing that David had deployed, uh, but if you notice, I'm using that AWS cloud control provider. I'm gonna go down to the lambda function. We see where node JS 16. Let's change that. Let's just change it to 22. We'll save it, and then I'm gonna clear screen. And then we'll just, we'll just maximize this. We're gonna go ahead and apply again. We'll see what happens. And so this time you'll see when we get here, it's only deploying that new resource that it couldn't deploy before. It is Node JS 22. And then it's just gonna go ahead and create and it should be successful. Fingers crossed, demo gods please. And so we'll give that about a second to go, um. But I think as that's going, and we'll, we'll come back to this in a second. The the resource guide really is the most simple way to find exactly what resources you wanted to find if you need to do something a little more granular. Um, the repository that David showed before, um, as I, I hinted at, um, um, previously was that not only does it have specific resource types, but there are also different security frameworks that are already available that you can apply using those pre-built guard policies, um, and so. Instead of just having to deploy individual like IM, uh, guard policies or like going through the specific ones, the framework's already built and kind of ready to deploy and you can test and see where that um meets for your business requirements and then you can modify those effectively by using these specific resource uh resources which will go back up one more in the resource and property types reference, right? If you need more granular controls around one specific access or if you need to loosen it up a little bit for your environments, you can do that as well. So let's go back over here. All right. The apply completed. We can see our outputs, we have that Dynamo DB table, we have that lambda execution arm. We have the lambda function and the S3 bucket. So not only have we shown you could do it with cloud formation, um, specifically in the console or programmatically you could do that, uh, but also with Terraform and being able to use the cloud control provider to manage the same policy as code for your environments, but, um, we definitely acknowledge that you know the error is is not very clear and that's something we are working on and we wanna make it just as clear as it is in the console today but from the terminal tomorrow. Yeah, um, does anyone here use organizations for bootstrapping their accounts? Um, cool. Would folks be interested in seeing how to get a hook distributed to your organization using stack sets? Yeah, that's what we're talking about. All right, let's go. We're gonna switch back. Yeah, cool. Let's go. I'm gonna switch this over. All righty. Um, while I use a computer, does anyone have any questions right now? Cool. Um, yeah, sweet. So I'm gonna show you one of the nice things about, uh, let's go here, um. One of the nice things about hooks as like a thing in cloud information is they are also cloud information resources. So we can actually provision a uh uh hook in cloudation the same way we would any other thing that we're gonna create. Um, so in this example, um, I'm gonna create a lambda hook, uh, and as part of this lambda hook, um, I'll just show you, let's create a lambda hook. So, we're going to create a stack. I'm going to upload a template. Mm. So uh number. Um, so now, uh, when I create a, uh, I told you earlier there's two ways to create a hook. One is using guard and that uses our policy as code language, and the other one is using, um, lambda. And so if I go and create a lambda function right now. Mhm. Let's see, this one seems good. I scanning, cool. Um, so I have, I have this really cool hook that I wrote earlier. We can look at it in a second, um, but if I paste that hook function on in, we can call it, um. Or lambda. You've also see, uh, cloud formation will go ahead and create that, uh, lambda hook for me the same way that I was doing in the console, right? So just a normal regular cloud formation resource you can provision it in a stack, um, but what that means is that if you use stack sets, um, so if I create a stack set and I upload, uh, this hook. My rats set. Um, and I give it the same, I'm sorry. Could be So, uh, Crown or. And the hook. Um Is it? Yeah, so now since this is just a normal cloudation template and I'm using stack sets, I can choose to deploy it to my entire organization or to my organization units, right? And so I don't have any organization, uh, an organization set up in this account, but you can see that just using stack sets, uh, and the fact that hooks are themselves regular cloud formation resources they can be distributed across the org, uh, to all of your organization, um. The other thing, uh, that, that means is that um when you create a a function like a lambda function for example that you want to be used crossed org you do have to have a cross org policy set on it so that people, uh, a resource policy on your lambda function that says anyone in this org can execute this lambda function um you can add an additional con uh condition key to your IM policy. Are your resource policy of your lambda function that says and like anyone in my org can execute this lambda function and it's coming from hooks we have I'll um populate that I am condition key um that's how you can have one hook, uh, get, um, blasted to your entire OU and start enforcing things, um. You can use tools like SEPs to stop people from being able to disable hooks in their account, um. And sometimes it's nice to give people uh the option to disable certain hooks in case they need to do things like overrides like my friend was saying, um, for non-critical things, but, uh, the, the same ability to blast, uh, your hook across your entire organization works with the guard hook as well similar thing, uh, you boot up it with an S3, um, file that has your guard, um, dip file in it and you can put a, um. Object policy on that that allows anyone in your organization to read from that S3 um file. Um, yeah, so that's how you use stack sets, uh, to blast hooks to your organizations. Um, we've been using this internally with some, with some, um, fun kind of information land, uh, to make sure that people aren't overprovisioning their, um, Dynamo DB tables. We had a bad habit. of when folks join, um, Dynamo DB used to have this pattern where in order to like have it sharded across like to pre-warm your Dynamo GB table you would over provision it so it would create lots of different shards and then they would um lower that um provision throughput or switch to um. Uh, on demand throughput, but sometimes people forget to do that and they'd end up just having these Dynamo DB tables with 10,000 read and write IOPs provisions just hanging around in their beta accounts, um, so we've been able to like blast hooks to those accounts to make sure that they're not doing that anymore, um. Dynamo be fixed like they have a feature so you can pre-warm tables now, um, so that's a real life example of how we've been able to shift like across the cloud formation organization like this uh bad habit of accidentally leaving Dynamo DB tables over provision. Cool, um, do folks have any other questions? Does that make sense on how to distribute it across organizations? We just use stack sets, um, it's a pretty, uh, simple thing. I will show you one fun thing because speaking of managed run times being kind of bad, um, so I have, uh, I wanna show you my lambda function that I created real quick, um, so this, I'm not gonna go over the code of this too much, um. Uh, I will show you, uh, we have this documentation for creating lambda hooks that's, uh, pretty good. It basically I, I mentioned before that when you create a lambda function, uh, we give you, uh, basically this JSO blob that you are free to use to evaluate whether something is, um, a resource is compliant or not, um, and in my function I'm targeting uh any uh resource that has something that looks like a container URI. Um, and, uh, if it is a container URI that's registered in ECR, I can actually call ECR, um, to see if the image that's being deployed has any critical findings. Uh, so is anyone here use containers on the reg? OK, sweet. One of my favorite features in ECR that ECR has launched, um, I'll show you real quick, it's super great. Um, I, um, like when you publish an image to ECR, um, it can scan it for vulnerabilities and so you can see I have this, um, this image called Mega good API. It's a really amazing service that I'm writing in my spare time to make my first billion, uh, but when I push it to ECR it automatically scans it and it's like, oh, there's a bunch of critical issues here. That's really cool, but basically up. Until now no one cared. No cared, right? Like cloudation doesn't care. It's like, yeah, sure, if you want to provision like an ECS service with um an image with a bunch of uh critical vulnerabilities that's totally chill. And eventually we get back into that situation that I was talking about earlier when I was on my bike ride home and I deploy this and everything works and then like 20 minutes later I get paged because oh no, an image with vulnerabilities has been deployed, um. So this image scanning function that I wrote, all it does is it like extracts the um image URI from my template. It looks to see if it looks like an ECR image, um, and if it's an ECR image, it calls describe image scan findings and if it finds any critical um findings, it fails the hook. And so like I could take this now and um. Distribute have distribute that across my entire organization like while I was sitting here talking to you, we could have my entire organization no longer able to deploy images to ECR with critical security vulnerabilities um cool so that that's kind of all the fun stuff that we had prepared. So thank you all thank you all. Take care.
