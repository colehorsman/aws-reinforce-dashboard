# AWS re:Inforce 2025-Implement app authorization in minutes with Amazon Verified Permissions (IAM306)

**Video Link:** [Watch on YouTube](https://www.youtube.com/watch?v=Hblyw--Fnw4)

## Video Information
- **Author:** AWS Events
- **Duration:** 51.3 minutes
- **Word Count:** 8,252 words
- **Publish Date:** 20250620
- **Video ID:** Hblyw--Fnw4

## Summary
AWS demonstrates how to modernize application authorization by externalizing authorization logic from application code to Amazon Verified Permissions using the Cedar policy language. The presentation shows how developers can move from complex, entangled authorization code to declarative policies that are human-readable, auditable, and centrally managed. Through a live demo with the new Express.js toolkit, the speakers illustrate how authorization decisions can be implemented in minutes rather than weeks, reducing over 120 lines of authorization code while improving consistency and security across microservices.

## Key Points
- **Authorization Complexity Problem**: Traditional authorization logic embedded in application code leads to spaghetti code, inconsistent enforcement across microservices, and broken access control (OWASP #1 vulnerability)
- **Cedar Policy Language**: Open-source policy language that balances expressiveness, performance, and provability - designed specifically for authorization with human-readable syntax
- **Externalization Strategy**: Following authentication's evolution, authorization decisions move to specialized policy decision points, similar to how AWS IAM handles 1.2 trillion requests per second
- **Amazon Verified Permissions**: Managed service that provides Cedar-based authorization with deep AWS integration, centralized logging via CloudTrail, and enterprise-scale availability
- **Express.js Toolkit**: New open-source middleware that maps OpenAPI specifications to Cedar policies, drastically reducing boilerplate code needed for authorization integration
- **Dramatic Cost Reduction**: New pricing of $5 per million authorized requests (97% reduction from $150 per million) makes fine-grained authorization economically viable
- **Policy Analysis Tools**: Cedar Symbolic Compiler and Analysis CLI help ensure policy correctness, identify conflicts, and support least privilege journey through automated reasoning
- **Developer Experience**: Authorization logic removal allows developers to focus on business value rather than security scaffolding, improving signal-to-noise ratio in codebases

## Technical Details
- **Cedar Policy Structure**: Policies contain effect (permit/forbid), scope (principal/action/resource), and optional conditions for attribute-based access control with implicit deny as default
- **Middleware Integration**: Express.js toolkit includes authorization engine client and middleware that intelligently maps API endpoints to Cedar authorization requests
- **Policy Store Configuration**: Verification requires creating policy stores with strict validation, uploading Cedar schemas, and connecting identity providers for token verification
- **OpenAPI Schema Generation**: CLI tool automatically generates Cedar schemas from OpenAPI specifications, creating natural language actions (create_pet, delete_pet) from HTTP methods
- **Batch Authorization**: Performance optimization through multiple authorization requests in single API calls, particularly useful for UI element authorization
- **Identity Provider Integration**: Works with Amazon Cognito and other identity providers using standard protocols (OpenID Connect, SAML) for authentication tokens
- **Observability Implementation**: Centralized authorization logs through CloudTrail enable audit trails, policy impact analysis, and security correlation across application landscapes
- **Symbolic Compilation**: Mathematical formula representation of Cedar policies enables rigorous analysis for policy equivalence, conflict detection, and refactoring safety verification

## Full Transcript

All right. Hello. Welcome everyone. So imagine you are a developer and you are developing a new application. And of course you want to secure your application and you want to build in access control as well. And if you go with the traditional way of how you did this, is that you would implement this in application code. So you would start maybe with a simple ifL statement which checks what is a user allowed to do. Maybe as your application evolves, it is more um evolved and it gets more complex over time. So it gets harder to manage, harder to update and harder to keep track of what's actually implemented in your application and who can do what. And maybe you want to think about if you can make this better and if there's a more modern way to do this. And today in this session we want to talk about a modern way, how to do this, how you can modernize your applications with cedar and with verified permissions, and how you can get started more quickly to integrate this into your applications rather in minutes rather than days or weeks. So my name is Manuel. I'm a solution architect with AWS. I'm based out of Germany, and with me today for the second half of the talk is Richard, who's also a solution architect and who is based out of Sweden. And Richard will do a demo for you to show you how you can modernize your application and what you can do with this. So let's get started. First, we will talk a lot about authorization. So let's have a look at authorization, what is it all about and why is it important? So authorization is about the set of rules that describe what a user that interacts with your application is permitted to do and also enforcing those rules. And it's important to get this correct because you don't want some user to do some action that is not intended. And there's also a list of the top 25 most dangerous weaknesses in software identified by CWE, and 3 out of those 25 are related to the management and to the application of authorization rules. So it's really something that we need to take seriously and that we need to consider. Authorization is hard. It's hard for several reasons, and we, I want to highlight what some of those reasons are. When you think about authorization, it's ubiquitous, and you need to enforce it everywhere. So maybe you have different API calls, different API endpoints, and of course for all of those API endpoints you want to authorize and have the right access to the right users. So we need to do this for every request. And there's also performance impact that you need to think about in an overhead that might occur. Next is the dynamic context. So there are different users interacting with your application. They want to have different endpoints and they interact maybe with different resources. And there's maybe also environmental context like how they are locked in that you want to take into your account when it comes to enforcing authorization rules. So it's dynamic in nature. There might be also inconsistent implementations across your workload. You might have different microservices managed by different teams with different programming languages and different paradigms that they want to do. There might be inconsistencies that you don't want to have, of course, when it comes to authorization. And lastly, spaghetti authorization or spaghetti code, that's hard to read when it comes to authorization, that's building up, that's complex, that evolved over time. So this is also something that we need to fix or need to think about. And all of this also leads that broken access control is the number one vulnerability or risk according to the OAS 10, the Open Web Application Security Project that calls out the top 10 risks that you should think about when it comes to web applications. There was a survey done which asked organizations what are the main obstacles that they face when it comes to a resilient identity infrastructure, and the reasons or the things that they struggle with were manifold. So 60% of the survey respondents said that the complexity of their identity and access management environment was the top thing that they are struggling with. Also outdated technology and technological depth that they acquired is something that they are struggling with and over half of the respondents said that this is something that they care about. And there was also a lack of bandwidth in their team in order to manage those systems. And when you think of identity and access management, authorization and the rules which govern your application is mostly the most complex part. So we require a new way to do this, one that reduces this complexity that was called out, one that eliminates the technical depth, and one that also requires less team bandwidth to manage. And this is also where cedar and verified permission comes in, which I will show you later. In the beginning, I shared a story about a developer who develops an application and the complexity of their authorization decisions evolves over time. And I want to showcase this here with a small code example and how this evolution could look like. And bear with me, even if you don't understand code, don't write code whole day, you will still understand the point that I'm trying to make here. So what you see on screen here is a function, a simple function that gets a book from a database based on a request from a user. After the book is fetched, you return the ID, the title, and also the rating of the book. And as you can see here, we don't have any access control. Any request will allow you to get the book and to return it. So maybe you think about hm. What could be a good thing to check. So one thing that you want to check if the owner of the book is also the user that requested this book. And if that's not the case, we send access denied. Otherwise, we let the request go through. And then you think about maybe I have some admin that should always be allowed to access books nevertheless, if he's the owner or not the owner. So you add some more. So if it's an admin, you can always do and request the book. And then you think, just maybe I need to also check if the user requesting this access is also authenticated using multi-factor authentication. Otherwise I will also send an access denier. And then lastly, maybe some books are public and if they are public, I don't care about anything else. I just let the book, um, go through and let the request go through. And if you have now a look at this, you will not be immediately or if you have a look at this the first time, it will not be immediately clear what this does. And also you see that the business logic, which is a very simple business logic here, is falling off the screen. So the developer focuses more on creating those logic and creating those access control logics than focusing on the business value for your customers. And if you think about this, can you spot the difference between the left and the right? There's only a small change which changes the whole authorization logic that we just um programmed here. If I show you the intendation of the code, you might see it. So here we have a bigger intendation compared to this, but this small change, maybe this was an error, maybe this was a mistake, changes the whole authorization logic. So we really have the demand to have a better way in order to solve this. So let me just summarize what this legacy or this traditional authorization state looks like and then build upon there how we can modernize this. So in our traditional way, we have our authorization logic built into our application code, so it's entangled with our business logic and inside of there. We might also have inconsistent enforcement, so different programming languages, different users, different teams managing those and implementing slightly different logic. This is also difficult to update and to audit. If you want to update this, you have to go into your application code, update it, and then deploy a new version of your code. Also, the audit part becomes not so easy because how do you lock the authorization decisions? Maybe one app does it the one way, maybe the other microservice does it the other way, and you might want to have a centralized repository of those access logs. And of course also it slows down the development of new features, new business logic and new value for your um users. So the question is how can we improve it and what can we do in order to make this better? And before we go into um authorization, let's have a look at authentication. And authentication is happening before authorization. So while authorization discusses what a user can do, authentication is about who is the user and proving the identity of the user. If you think about the way that you do this when you interact with an application, you do this by providing your email address or your username and your password, and then you are logged in. Maybe you also have multi-factor authentication, then an app demands and then you proved that you are who you say you are. In the traditional way of implementing this, you would also have this within your application code. If you go back several years, when you build an application, you might have a table for your emails, for hopefully hashed and sorted passwords, and you managed this and managed the session as well. You also manage things like sending email to a user when they are registered, sending a password reset email, and also thinking about the flow of user registration. The modern way of doing this is using an identity provider. So you externalize this decision to a specialized provider who specializes in managing user credentials, and managing this authorization, authentication flow, and manages everything around this like sending password reset emails. So you don't have to think about that anymore because you are externalizing this to an identity provider which focuses on this. How do you interact with this? You interact with this using standardized protocols like Open ID Connect or Assemble. So this gives you more mindshare to focus on your use cases, your value for your customers, and providing new features. So the question becomes, can we do the same for authorization as well? And the thing is, yes, we can, and this is the modern way. But before I tell you how you can implement this in your application, let's have a quick look at how AWS does this. So we are now back to authorization, so who can do what in the AWS environment. If you would think for a moment that every of the 200 services that you can use with AWS would implement their own authorization logic, it would be quite complex. Maybe different services would have different syntaxes to use this, and it would be quite involved for the service teams to manage this and to keep up, and it wouldn't be such a good user experience. But we don't do it this way. We do it another way. One service that you're probably all familiar with is AWSIAM Identity and access Management, and this is where you define users and roles and also what access they have with policies. So what we do in AWS is also we have externalized this to AWS IAM and the services, for example, S3 or Dynamo DB, they integrate with this and basically ask, should I um allow this request or should I not allow this request? And if you have been to the keynote, yesterday, you saw that IAM handles 1.2 trillion requests per second. So it's really built for scale and for, um, yeah, for allowing this externalization to happen within AWS. And the same thing is what we can also do for your application with CA and with verified permissions. So to summarize what you saw is now with this sentence, authorization is following in the footsteps of authentication. So before for authentication, you did that within your application, this was externalized years ago and this is now the new standard. And the same now also happens for authorization where you do this and where you externalize this. Let us think for a moment what are the components that you need in order to be able to externalize your authorization decisions. So there are two things or two main things that you need. One is you need a policy language in order to express your authorization logic as policies that are easily readable and that you can update and that you can share or that you can use within the application. So that's the first part. The next part is an authorization engine that takes in these policies and basically you can interact with this authorization engine in order to get a decision, can a user do something in my application? Yes or no. And in your application, you would then enforce this decision and um yeah, let the user in or not. And this is where CEDA policy language comes into play. And CEDA is exactly that. Let's have a little bit deeper into Cedar and the components that make up this. So Cedar is an open source policy language and SDK. So with Cedar you can define the policies, and Cedar also comes with an authorization engine, the two components that we need in order to externalize our authorization decisions. CETA is also purpose built for authorization. So we thought about it from the beginning. Um, what do we need in order to make this possible? Cedar also balances three critical aspects that we need to think about expressiveness, performance, and provability or analyzability. So the first is expressiveness, as you see here on the slide. So applications are different. Your application might be different than your application have different actions, have different resources that you interact with, or different user attributes. So what we need is an expressive language that can mirror or that can model all of those things. And if you think about what are some common models, role-based access control and attribute-based access control is, for example, something that we want to model and be able to represent in the CDA policy language. Also performance, of course, if we externalize something, we need a performance system that gives us the decision back very quickly, and Cedar is built for that. and Cedar is built in rust and built for speed and scale in order to externalize this and centralize this decision and to integrate it with your application. And lastly, provability or analyzability. So CEDA is designed for analysis using automated reasoning. So this enables you to include tools that are capable of optimizing your policies and proving also that your security model is also what you think it is. And lastly, to for a good developer experience and for good management of those policies, it needs to be human readable, so you need to understand it. And if you think back at the beginning in the example in the beginning, it wasn't very readable when we implement this in code, when you have nested FL statements, so we need a better way, and CEDA allows us to do this. And this is also more auditable because now we externalize all the decisions we have our policies in the central point. Every application can now integrate there and you have a centralized mechanism to do the logs to know what's going on in your application and to get decisions if there's an allow or deny statement. I said CEA policies are human readable, and I want to show you a CEA policy here and go over it. I bet if I showed you the CEDA policy and you haven't heard of CEDA before, you could still tell me what this is all about and what this policy does. So let's go in and dissect this policy a little bit and see the main components. So first we have an effect. You can either write permit or forbid statements, and if you don't have any policy in your authorization engine, you would get an implicit deny because this is the default. When you have a permit statement, you would then get a permit back from your authorization engine and could do something. Forbid statements just like with IM, overrule the permit statements. Then we have a scope. Here we define what kind of actions the principal is allowed to do on which resource. So in our case we have a principle. If the principal is in a group called admin, he can do the action create pets only if the resource is in the collection of all pets. So you can think about this like a folder. Ricker Richard will also tell you more about such policies in the demo, and we have prepared a demo where we have a pet store where we can create, delete and update pets, and we will demo different policies and different use cases with this pet store application. And below you have the conditions. This is an optional thing where you can further restrict or define the policies, and here you can define things like attribute-based access controls. So this permit only applies when the principal has an active account and when the principal's department is in pet care. So the conditions you can define attribute-based access control and in the scope you can define role based access control. And we also have a cedar playground which you can use in order to create policies to evaluate policies in order to test policies and test what they evaluate. So cedar is the foundation for all of this. Cedar is open source. You run it in your own infrastructure and you manage the scaling, the availability and the logging. What customers have asked us is also a more managed service and a more managed experience just like you are available with all the other AWS services. And this is where verified permission comes in. Verified permission is this managed service that you can use that builds upon the CEA policy that allows you to for this deep integration in the AWS ecosystem. And yeah, that allows you to integrate this quickly and have additional features on top of that and also availability and logging provided out of the box. So let's have a a closer look at verified permissions. So verified permissions has this notion of a policy store. When you use verified permissions, you can create a policy store which is basically the container for all your ZA policies that you're writing and storing in your application. In your management console, as with the other services that we have, um, you can manage permissions, you can test permissions, you can create policy stores, delete policy stores or with the CLI or um or API. Here your application comes into play. You let's say you created a policy store, you stored permissions or policies in it. Your application would then integrate with this policy store and basically ask, I have this request from this user who wants to access this resource. Please verified permission. Tell me, should I authorize this or not? And verified permissions will give you a yes or no decision, and then you would enforce it in your application. And this all allows you to integrate fine grain access control into your application. Let's come back to this picture that we saw before. This time it's about your application. So as I told you, the traditional way was to baking the authorization logic within your application. With verified permissions and with cedar, this now changes. You created a policy store. And you created CA policies, so you externalized all of those decisions to the policy store and integrated this from your application. So for the requests you basically ask or call the is authorized function, the authorized API, and then verified permissions will give you back this decision. And this is very close to what we saw before with the AWS use case or the authentication use case. Coming back to the picture for the legacy authorization state, what changed now that we made these changes? The more authorization externalizes the authorization decisions in a specifically in purpose-built policy store that we created with verified permissions. We now also have consistent and policy-based enforcement. Think about your microservices, they can now all integrate with verified permissions. Um, you can create the policies there and now you will have a more consistent experience throughout your um application landscape. It becomes now easy to audit and update. If you want to update your access control decisions, you would just have to go into your policy store and update the policies rather than update your application. Also, it becomes more easy to audit because now every decision is sent to verified permissions. Um, the decisions are locked in cloud trail and you can analyze those logs and get more information out of this centralized repository. And more importantly, developers can now focus on customer value and creating features rather than thinking about the access control logic that they have baked into their application. I always think that pictures tell a better story more than 1000 words, that's why I also have created an architecture which shows this journey with some services that might be familiar to you. So here we have an application which might be written um based on lambda or based out of EC2 or based on EKS um it doesn't matter at this point. This application integrates or stores the data in a dynamo DB database and externalizes everything by an API gateway so users can interact with this application or this API. We said before that authentication is solved, so we integrate Amazon Cognito, our identity provider that you can use out of the box in order to handle what I just told you in the beginning, which is the storing of the user credentials, the user flow, and sending, for example, password reset emails, and so on. We get a token after we logged in and this session token we can then validate using a lambda authorizer in order to see if the user is signed in or not. At this point in time we might still have our authorization logic within our application. Of course we want to change that. So what do we do? We would create a policy store with verified permissions, and this is a policy decision point. This is sometimes called a policy decision point because we make the decision or the decision is made within this policy store in verified permissions. We then move our authorization logic away from code into policies, into see the policies that you see here, for example. Here we have an example of a principle which is in the user group employee. In our demo application we also have two user groups that we use employees and admins, which have different rights to do in our application. And here the action is listing pets, all the pets that we have in our database. You can also see that the resource doesn't have any definition. This is basically um saying that this, um, yeah, this policy applies to any resource. And of course we also need to integrate verified permission and the externalized policy decision point within our application, and we can do that from the lambda authorizer or also from the application. In the application you might have more context, you can get more fine grain access control decisions, and in your Lambda authorizer it might be more in the beginning of your flow. Of course containers are very popular nowadays, and you can integrate this whole thing also within containers. So here you also have different ways where you can integrate this, for example, at the API gateway level as we saw before, or also in Kuberneti's native constructs like Kerniti ingress controllers or Kernitis services. If you want to move closer to the application and maybe have more context for your access control decisions, you can also do this within the application container or within a sidecar proxy container. We have also written a blog post on this that I will share with you later at the end of the talk. So customers have asked us to simplify the journey to use verified permissions. So last year, what we did was we released and made it easier for you to integrate verified permissions in API gateway-based applications. So we released a wizard within the management console that you can use in order to get started quickly and in order to create policies out of the box. But what we also heard was that you wanted to have your authorization decision closer to your application and use frameworks and have an easier integration into frameworks and want to make it simpler for you. So today we are happy to announce that we released the Express JS integration, the Express JS toolkit that you can use in order to integrate verified permissions quickly in minutes rather than days or weeks within your application with less code to write because of the middleware that we provided. With that, I want to give it over to Richard to tell you more about this Express JS toolkit and to also do the demo with you. Thanks Mona. So As we said, we wanted to come closer to developers, and one of the things we wanted to bring to you is allowing you to accelerate the adoption of these technologies. We know that we're in a fast moving world, and we want to make sure that we're getting this into the hands of you and that you can benefit in a much, much faster way. One of the options that we had also was we had an ability to reduce the scaffolding that we needed to implement in order to get this into your code. So we hope that this to reduce the amount of code that we need to integrate this. We also wanted to benefit from the trend to specify your API using open API specifications. So open API specification is a common schema for declaring and defining your API. So we're able to benefit from that kind of declarative language in order to accelerate and map this thing. So the Expaci toolkit is, is an open source project. It's gonna be available and launched. You might find it in our GitHub organization. There's gonna be more information about that, uh, in some of the blog posts that have been launched today. Um, if we look at, uh, what we're trying to do, and Manuel positioned this quite well, uh, so, We have a traditional application, an Express application. Uh, it has a number of users we all see like customers, employees, administrators. It's a very typical scenario for, for this. Um, they all store and manage their data in the Dynamo DB database with different kinds of permissions. In this case, there's a restriction on what employees are allowed to do compared to what administrators are allowed to do. Uh, we protect this, uh, application using an identity provider. In this case, it's Amazon Cognito. Um, and today our authorization logic is actually embedded into the application, co mingled with the business logic. Um, so what we wanted to do here is to work with eliminating this, you know, and get it more manageable and auditable and consistent, you know, and allow developers to focus on innovation rather than focusing on integrating or upkeeping or housekeeping of the authorization logic within the applications. So what we're trying to do here is to add AVP in a very efficient way into your development life cycle and move this authorization logic up into the policy decision point that is ABP and thereby reducing the complexities and the signal to noise ratio that some developer finds is challenging as your application logic becomes more complex. So, by transforming and extracting the authorization logic from your application into CDA, we believe that you will benefit from a number of advantages, reducing the number of deployments that you need to do in order to change the authorization logic. Um. So if we look at the example, and I think we showed it a little bit earlier in this presentation as well, where it can be quite complex, you know, now we have a simplified set up for you, but you can already see today that compared to some of the operations we're going to show, there's a significant signal to the lowest ratio when it comes to authorization logic compared to the business logic. So we wanted to take a step back and look at what if we could remove this burden from you as a developer and could make you allowed to focus more on the business logic. What would that look like? So, if we now have the option of saying, we don't want the authorization logic in our code, uh, what can we do? Well, what we did, we developed a middleware to accelerate adoption and simplify integrations. So by using this middleware, we're drastically able to reduce the amount of code or boilerplate that you need to do in order to implement authorization. So by simply adding it in middleware, that maps and uses mappings were able to extract from the open API specification, uh, we can radically simplify and allow you to focus more on the business logic. So one of the things we want to do in the demo is demonstrate this in a little bit more of a simplified way, uh, so you can experience and see how we can move from having our authorization completely within the application. And instead moving it into AVP. So before we show the demo, um, this is a pet store dashboard. It has customers, it has employees and administrators. Employees today are not allowed to delete pets. Administrators are. So we're gonna show a little bit of the simplified method for showing you how our back can be made, uh, much more palatable and easier to implement uh with AVP. So in this case, I'll just switch over to the demo. So here we have a demo application, the similar one that we talked about. So, I'm logged in here as an employee. Might have different permissions. In this case, as we explained earlier, I'm allowed to create pets, but not allowed to delete them. So, I is gonna showcase the behavior here. Let's create a um pet called petting. Let's say it's a cat. Siamese cat, age is 10. So now I'm able to create. It's nothing particularly unique with that. But what I'm also restricted about doing is deleting pads. So if I try to perform that action. You can see that it fails. Now, what powers this authorization logic under the hood? Well, if we go back and we look at the authorization code, it might seem simple in this scenario that it's not that complex, but we've just briefly look here. It uses almost 50% of the state in our code. It adds complexity. It adds sometimes confusion, and depending on the language you use or how you implement it, it can also have deficiencies and weaknesses, as we showed earlier. Sometimes it's very easy to make larger refactorings and miss things. I think we'll all be in a situation where we have a complicated setup and logic, and it takes a time and it's an undue toil on developers in navigating this and making sure that we have a consistent implementation of authorization and maintaining that logic. So what if we instead would completely remove this logic? What would actually happen? Now we have the clarity. We have a much more fine-grained understanding of what the authorization logic should be, but we have removed it from application. Let's just see the behavior that we have when we have no authorization and try to get back to a state where this is implemented, but first we just show the effects. So previously I wasn't able to delete Petty. Now that all authorization logic has been removed. A successfully did that. But right now I don't have the authorization logic that I expect, right? Employees are not supposed to be able to lead pets. So how can we radically simplify reintegrating this logic in a much more finer way? So, um, with that, I'm gonna go back and I'm gonna talk a little bit about how to implement this, um. So If you then go forward and we look at how to integrate um the middleware into your application, there's a number of steps. First of all, um, Express is a very popular framework. It's, uh, one of the most popular frameworks that we see developer use, and it's, it's only relevant that we start with it. So if we look at what we need to do in order to implement this is that we have to, of course, install the millerware. We have to create the see the policies and schema that Manuel talked about that gives you clarity on how to define your policies. We also need to configure verified permissions. And we also need to integrate this in our toolkit into our application. Throughout this demo we'll show you how you can achieve this in just a couple of minutes, and this gives you a good starting point for where you can build on and reintegrate and as Manuel said, it's very important to start with simple in this case, um. So, uh, first, if we look at installing the, the middleware. What we have are two components. It's the authorization Eion that communicates with AVP from your application and is performing these activities against AVP. We also have the Mwath ExpeS which takes the policies that you have and that we've generated and the schema and integrates that and intelligently maps the activities or methods that you're performing against this endpoint and allows us to route that intelligently to AVP. So in this case, how do you install this? Well, It's composed of two modules. One is the authorization client. One of the authorization for expaias. So, what we have now is that we've um removed the authorization logic from our application and we're reintegrating the middleware into our expatiate application. The next step is preparing your schema and see their policies. How you do that is we, we wanna really for you to be productive and be able to expand and quickly adopt this. So as part of this toolkit, we also have a CLI for generating that uh seedar schema from your open API specification. By also using AVP and uploading your schema, you also get a visual representation of the type of actions that you can perform against your resources. In this case we move from seeing put post statements in your open API specification, and we, we have a much more unique experience by having you know a natural language. We are now a create pet, delete pet, get pet, which are much more easily to work with. So we also go in and we look at the authorization logic and we perform these clean up activities. Maybe for the first time we're discovering and understanding, you know, exactly what we want this authorization logic to be. So there are some activities that we need to do in order to to move into a state where we can have our policies defined. If you then look at uh what we've done now is we've uh added uh the CDA schema, we generated that. We created our CDA policies. And our authorization logic is now defined, so now we can go in and integrate this with verified permissions. And to recap what we need to do in order to do that is, as Manuel said earlier, we need to create create this container for our schema and policies. So we create a policy store, we upload the schema, we upload the CA policies, and we connect that. So how do we do that? You have multiple options. We've spoken about that earlier. You have the console access, you might use infrastructure as code. In this example, we're just gonna use the CLI. So we're creating a policy store and we're also putting in a validation statement of strict, which means that AP will verify the correctness of the policies that we have and the syntax that we use in our application, minimizing the issues where you have maybe human mistakes or misconfigurations based on an unclear schema. We also upload and put the schema into ADP using our portalsis store as the target. We also upload two of our policies, the employee policies and maybe the admin policies that we saw earlier. We also connect the identity provider, which allows us to verify the token that's being issued, in this case the identity token of the user, which contains the group memberships, in this case employee, admin or customer. So by moving this and adding AVP into the uh um uh architecture, what we could do was is we connect the identity provider and then we upload the schemas, the policies into AVP. And we also now have our schema defined clearly in the CEA policy language. Next it's of course of uploading and updating our application code. So how do we perform that action? Well, first, of course, we need to import the packages that we have. So we have the authorization engine and the and the uh express middleware. But then we need to configure. They work together to implement this, so the authorization and is configured to target uh your policy store. Um, and also the authorization middleware here is taking that authorization engine and the schema to be able to tell express how these requests should be mapped. So once we protect the endpoint, it will be able to route that intelligent and understand which authorization actions it should request to be verified against AVP. So with that said, so how does the application look like? Well, now we integrated Amazon Verified permissions to our application. We also upload the other authorization logic to AVP. So in this case I think it's time for us to test this integration. To see how it works in action, um, so I'll just switch over to the demo now. So if you go back now and we look at the integration paths. So here is a much more real life scenario of how we can integrate. So we have the authorization engine. We start with that. We configure it with our policy store ID and in this case, the user is authenticating with Cognito. So we tell it that we're going to use the identity token. Then we use the schema that we generated, uh, and we add that together with the authorization and to configure the middleware. The middleware is then being added as a mapping towards this API PET slash endpoint, which consistently makes sure that all of the authorization requests and the policies that we implemented get processed through AVP. It gives us the comfort that we know that authorization is now being effective in that part, and we know that there will be no misconfigurations in terms of the logic inside this request, because if we then look at the Um, uh, delete operation which we want to prevent for employees. It no longer contains this logic about the employee or admin. So it also allows you to maybe perform more radical, uh, refactoring software application code without risking that authorization logic to be misconfigured. And as we talked earlier, that is one of the biggest risks that we see when people are implementing authorization in their applications, uh, this common weakness that we see. So, uh, let's go back to this application now and see what kind of behavior we have. We spent just a few minutes modifying the code. So if you go back now and we'll look at, uh, for example, trying to delete Rocky. Ideally, what we see here is that it's no longer possible to delete rocket. And again we're back in the known state. Now we have recovered all of the authorization that we have, but I also want to highlight that this is just one operation. This is the delete operation throughout the sample that we have now with the logic, we removed over 120 lines of code in this application, reducing the toll of the developers, improving the signal to noise ratio, and also improving auditability. Um, so with that said, really happy to have shown you this, and this sample product is also available on GitHub and also mention is some of the blog posts you're gonna see. So with that said. I'm happy to give it back to Manuel, and he'll talk a little bit about the practices that we've seen being successful for customers. Thank you. Thank you, thank you, Richard. So thank you, Richard, for showing us how quickly you can get started with this new Express JS tool kit from an application with authorization logic in code showing you the commands that you can use in order to get started quickly to actually integrating this in your application. And of course this is a demo application. The authorization logic we had in the code was quite simple, but just imagine how this could look like for applications with more complex authorization logic and how clean the code could look like then. If you externalize this and represent this as CEDA policies. And we try to simplify the journey there by making it easier and quicker for you to get started. Our perspective is that authorization has a place in the modern infrastructure that you use, and we also think that it's a fundamental building block that you should use in your application. It's just like you use compute to run your code, storage or databases in order to store the data and networking to connect to it. We also think that verified permissions has a place here as well for the authorization logic. And the service here is solving the problem of making it easier for you to get started and. Below that, we are making it easier for you to get started. And with that, in the spirit of reducing the overhead and the code that you need to write, we also reduced the price and implemented the new pricing. So I'm excited to share with you the new pricing, which is $5 per million is authorized request that you send two verified permissions. This is a 97% price reduction that we make available for you coming from $150 per million is authorized requests. So think about the mental modeling model here. We reduced the lines of code that you need to write in your application. We reduced the time that you need to get started, and we also reduce the price of verified permission to integrate it. Let me share some best practices with you that you can follow when you, um, yeah, embark on this journey for this new authorization um methodology. So first is for policy management or in general start simple. So you can create complex logic within your CEDA policies. The best practice is to start with a simple application, maybe start with role-based access control, then make your way into attribute-based access control and the relationships that you can model for in verified permissions or policies. Next is think about performance. Cedar and the authorization engine is built for speed, as I told you, but you can even increase the performance when you do batch authorization. This is where you send multiple is authorized requests in one API call to verified permissions. This could be handy, for example, if you show UI elements based on the user and what they are able to do or what they are able not to do. So you can also use batch authorization. And lastly, if you think about security, of course, the principle of least privilege comes up. So you should only allow the users to do what they need to do and know more and no less. And when it comes to all of this, observability is also something that you can now think about. So we now have a central access log on all the authorization decisions within our application environment. You can use that for several reasons. You now know what the users are doing in your application and use that for thinking about how they interact with the application and which features are, for example, popular or not. You can also observe the policy changes when it comes to policy management and see if your app still works. You can observe the performance or also the quotas that you use within your AWS environment, and when it comes to security, you now have those centralized locks that you can correlate with other locks and see if you think or if what your application does is actually what it also does when it comes to access control. Least privileged least privileged is a journey, and customers have asked us to help them on this journey to least privileged and to make it easier also when it comes to verified permissions. And we also released tools for analyzing CA policies that makes it easier for you to see what a change in your policies would look like and what the effects would be. So what we released is open source tools, the Cedar symbolic compiler. This symbolic compiler allows you to represent cedar policies as mathematical formulas which you can then analyze rigorously and see what they do. And we also have the Cedar analysis CLI, which demos what you can do with the Cedar symbolic compiler in order to answer common questions. And this could be. Are these two policies equivalent? If you have more evolved policies, they might not look the same, but they might be the same. You can also think about if you change something in your journey towards least privileged. Will this policy refractoring break any of the existing access control patterns that I have in my application, or are any of my policies ineffective or conflicting? So this is also helpful, and you can have a look at this Cedar symbolic compiler and the Cedar analysis CLI. I want to send out 3 additional resources that you can have a look at. So the first is the blog post where we explain the release of the Express JS toolkit. So the commands that you saw here will also be in this blog post. You can get started. You can try this out with our sample application and get a look and feel yourself. In the center, you see the blog post for our release for the. Cedar symbolic compiler and our CEDA analysis tools which are showed on the page before. You can have a look at this and try them out as well. And the last blog post that I want to highlight is the blog post on integrating verified permissions in a containerized environment. This was the pictures we saw earlier on the 4 different ways you can integrate verified permissions in a containerized environment. You can have a look at this. So let me end the session with 3 key takeaways that you can take away here. The first is authorization is challenging, so it might lead to complex, inconsistent, and difficult to manage code if you went with the traditional way. If you move to a more centralized and externalized model with verified permissions, this provides more consistent enforcement and easier to audit, and you can have your developers focus on application code. Then I want to highlight CEDA. CEDA policy language provides this human readable and auditable way to externalize your authorization code, which follows the path of authentication that we saw before. And lastly, with our Express JS toolkit and with the release that we did here, you can get started quicker. We make it simple for you to integrate verified permissions in your application using Express JS in minutes, and we reduced the complexity and with that we also reduced the pricing. So have a look at the sample applications, have a look at it, get started, get started with an application, and test it out yourself. With that, thank you so much for your time, have a great day and please give us feedback in the survey. Thank you.
