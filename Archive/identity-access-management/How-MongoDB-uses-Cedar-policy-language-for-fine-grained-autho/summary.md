# AWS re:Inforce 2025 - How MongoDB uses Cedar policy language for fine-grained authorization (IAM301)

**Video Link:** [Watch on YouTube](https://www.youtube.com/watch?v=Ui7cFy23Y9o)

## Video Information
- **Author:** AWS Events
- **Duration:** 58.5 minutes
- **Word Count:** 8,685 words
- **Publish Date:** 20250618
- **Video ID:** Ui7cFy23Y9o

## Summary
The presentation focuses on Cedar, AWS's policy language for fine-grained authorization at scale. The speakers, Neha from AWS and Jim Sharf (CTO of MongoDB), explain how Cedar helps organizations manage complex authorization decisions by separating authorization logic from application code.
The presentation uses relatable examples, starting with conference badge colors, to illustrate authorization concepts before diving into how Cedar implements fine-grained access control. It emphasizes Cedar's ability to handle complex scenarios while maintaining readable, declarative policies that can scale with business needs.

## Key Points
- Cedar separates authorization logic from application code, making policies easier to manage and maintain
- Policies are both machine-executable and human-readable, facilitating better security auditing and review
- Cedar combines role-based access control (RBAC) with attribute-based access control (ABAC)
- Traditional approaches require duplicating authorization logic across different programming languages and applications
- Cedar policies can incorporate complex conditions like time-based access and location-based restrictions
- The solution scales effectively from simple use cases to complex enterprise scenarios with millions of permissions

## Technical Details
- AWS Verified Access: Uses Cedar for zero-trust access to enterprise applications
- Policy Examples:
  ```
  permit(
    principal,
    action,
    resource
  ) when { conditions }
  ```
- Supported Conditions:
  - Time-based access control
  - Location-based restrictions
  - Device compliance checks
  - User attributes
- Integration Capabilities:
  - Works across multiple programming languages (Java, Python, Swift)
  - Supports mobile and web applications
  - Can be implemented without code deployments
- Use Cases:
  - Session registration management
  - Expo area access control
  - Role-based permissions
  - Fine-grained resource access

## Full Transcript

Welcome, uh, everyone. I'm very excited to share how today how MongoDB is gonna is using cedar, uh, to power their fine grain authorization. My name is Neha and I am an applied science director at AWS where I lead efforts to apply automated reasoning and formal methods to create secure and scalable authorization systems, many among many, uh, other things, and it's my great privilege and honor. To be speaking today with Jim Sharf, who is the CTO of MongoDB uh, Jim has deep expertise in a lot of things including authorization, distributed systems, databases, and has had a lot of experience running large systems at scale. So I want to take a moment and say, authorization is all around you. Authorization is also on you. It's the badge you're wearing. And one of the things you'll notice about the badge you're wearing is the color is not the same for everyone. Different people have different color badges. The colors are part of an authorization system that we use and reinforce. Orange badges are for AWS employees like me, which gives me access to staff areas. Gray badges like the one Jim has are for executives or our customers. It does get him into some really nice lounges and. Others like a lot of our customers have like you have black, uh, badges red is for press that gives them access to briefing areas, press and analyst review areas, and sponsors and partners have their own uh badge colors. And this simple example can show how authorization is so omnipresent in our lives. But it goes deeper than color. Not every customer can access every session. A lot of you got access to this session because you registered for the session, and that is the notion of fine-grained access management. And of course authorization isn't just about conference badges, it's present in our everyday lives when you go home you take out a key and get inside your front door that is authorization. You go into your workplace, you take your work bad, scan it, get in that is authorization. You walk, uh, when you travel, when you walk up to immigration and show your passport to uh to board a flight that is authorization. And that is also present in all the software that we build every day, and authorization is crucial for security and compliance. And today we will explore how Cedar helps us manage these authorization decisions at scale and specifically how MongoDB has implemented it for fine-grained access control. Cedar was AWS's answer for authorization at scale for your applications. And let me paint a picture here. You have a simple banking application, a few 100 users, a few 1000 permissions, that sounds very manageable. But then if you're a US bank and you wanna expand to Europe and Asia, suddenly you're dealing with hundreds of users, thousands of applications, millions of permissions, and very complex regulatory requirements. And now you have to have a different mobile app one for iOS one for Android, your permissions are scattered across a dozen code bases, possibly dozens of programming languages, and that is where the homegrown authorization systems often break down. We built Cedar, a way to define authorization as code that is separate from your application code. And Cedar is designed with security first principles. It scales as your application and your business needs scale. So let's look at Cedar with some real policy examples, and these three policy, the goal is to show what the power and the ease of which you can do these use cases with Cedar. The first policy is really simple. Here it says everyone can attend lunch and the expo. It has no complex condition, just straightforward access. The 2nd policy shows any customer can register for sessions. And finally we have speakers like myself and Jim who can access the speaker ready room. If you take a moment to notice these policies, they are pretty readable. They're not just machine executable, but they are human readable. This was a key feature as we thought about the design when looking at cedar. It's also crucial for security administrators like you who need to review and audit permissions. It becomes a self documenting artifact. Anybody who can read the policies can understand what the policies are doing. Now if we expand this to fine grained authorization, what does that mean? Let's take a look we have this policy that says customers can attend sessions which is very similar to our previous policy, but it has an additional when clause. The policy only permits access when the customer is part of the sessions registered attendees. But here it's not enough to say you are a customer, so you can attend a session. You have to be specifically registered for the session to attend it that is fine grained authorization in action. Now this is a particularly powerful example because it combines both role based access control you being a customer that's your role with attribute based access control being registered for that specific session that specific session being the attribute. And Cedar makes it very easy to express these complex relationships in a very clear and maintainable way. Let's take another look at another example. This policy controls access to the expo area predicated on the when clause, and it checks if the current time is within the Expo's operating hours. It checks is the current time between the opening and the closing. This is giving you a flavor of the types of things you can have your policy check and do. And you can extend it for every sponsor if you're a sponsor, you may need access for extended hours. You may need to set up your booth, take it down. This has to be outside the expo hours so the organization nurse can. Say hey, let's create a policy so that the sponsors can get access 2 hours before the expo opens and they can stay 2 hours later after the expo is closed so they can take down their stuff, secure their area, and make sure they have everything that they need. How are people doing it today? I've, I've talked a lot about these, uh, Cedar policy examples, but I haven't talked about what people are doing today. If you look at how application code is written in Java or Python. You can have for the iOS app you have to recreate that same permissions if you're writing them in application code you'd have to do it in the same permissions model now in SWIFT because your iOS app is written in SWIFT. And what ends up happening is that the application code gets intermixed with the permission code and it makes it hard to know, hey, where are the sponsors who have I given access to if I want to now change uh sponsors having 3 hours access instead of 2 hours additional access I'd have to go change code in multiple different applications. I'd have to go change some Java codes, some Python codes, some SWIFT code. And I'd also have to check that they don't get out of sync which am I deploying first? Oh, that's another thing I have to deploy code to ensure that my permissions are actually, you know, spread across these things. But if you're using Cedar you have a very clean separation you have a clean separation between your application code and your policy code they're declarative they are separate from your application. They're easy to review, easy to audit, and it ensures that there is consistent enforcement and you don't need to do code deployments to have policies. As I said, we've built cedar for your applications. But I also want to talk about how we are using cedar internally at Amazon. AWS verified access provides you zero trust access to your enterprise application. With cedar, it uses cedar. It even exposes cedar to end customers. You can specify access based on who is the user, whether their device is compliant, what time of day it is, what the what is the location that the request is coming from. So even if it's an enterprise app that's not on the VPN you may say, oh it's OK if you're coming from a location with uh within the US but oh if you're coming from a location that I don't recognize then access is denied Cedar provides this ability for applications to help users do that. Now, we talked about authorization being needed everywhere on Earth. But authorization is also needed by satellites that are running in space and this one's a particular favorite of mine Project Kuiper is um. Is sending satellites in space and they are using cedar and it's a very vanilla use case it's saying hey, the agent needs to restrict uh what it can see and what it cannot see based on the business tier it's part of very straightforward authorization request it goes to our story that authorization is indeed everywhere around us. There's dozens of internal applications that are using Cedar. They're doing it through Amazon verified permissions, which I'm gonna come to a little later. It's our managed cedar offering, but if you look at these examples that are using cedar, there's probably similar applications for your company. All of the companies you look at they'll have some notion of HR they'll have some notion of uh marketing advertising, the supply chain recruiting, as well as risk and compliance. So for all of these internal applications that are using Cedar, I wanna, as you go back to your day jobs, think about, hey, what is the authorization system that's being used? Is it permissions and code? Is it duplication? What can I be doing to help streamline this? Talked a lot about cedar. And the natural question is we already have AWSIAM, so why did we end up building Cedar? That's a very, that's a question that it's we we really thought about and I'm gonna talk about what our thought process was. Now if you look at the shared security model, there's security in the cloud and the security of the cloud. And that is a similar story for authorization that happens here. If you look at how what you do today is you are running applications in the cloud. And Cedar is the authorization for things running in the cloud while AWSIEM is the authorization of the cloud. Cedar gives your users access to their files, notes, photos, tax returns, those are your resources. While IAM gives your applications access to AWS APIs, AWS databases, queues and analytics. But there are similarities between the two, and we took lessons learned from IAM and incorporated them into cedar. There are deliberate differences as well because we designed Cedar to work for your applications instead of the AWS infrastructure. There is a lot that makes IM and Cedar look similar. Again, that's very deliberate, but understanding the parallels and the differences is very important. There are certain key security principles that both CEDA and IAM support. Deny by default. Security first. Nothing is allowed unless you explicitly grant permission. Deny Trump's allow. If there is a single deny statement, access is blocked. You don't want somebody to go add an allow statement and now worry or if this allow statement is added somewhere here will suddenly access be granted but if you add a deny statement somewhere as a security administrator, you know Jim can never access those IPA if if that deny statement exists. That's a that's the assurance you have and it's a security principle. They both follow the PA model principal action resource condition. And in both cases policy order doesn't matter all the applicable policies are evaluated. Now, we should also look at the differences between the two. In IAM AWS is the one that enforces all IM authorization decision all principles, actions, resources and conditions are defined by AWS AWS provides you the managed policies that are the built in, uh, policies that allow you to do what you want to do. And but in Cedar you enforce the decisions you define your principal action resource conditions you decide what's what's the nouns and verbs of your applications? What are your actions? What are your resources and everything is sim simplified to a single policy type. Now this distinction is important because while Cedar gives you the power and the security that IM gives you, it, it provides you the flexibility to say here is what authorization should look like for me. And I've talked about a lot of similarities and what a lot of differences between IM and Cedar, but there is one thing that I've actually not talked about. There's one similarity that I've not talked about, and that is related to what I call provable security of both the systems. And I'm gonna tell a little story. Let me take you back to 2011. This was one AWS IEM was first launched at the time. AWS had maybe a dozen services. Cloud adoption was just at the beginning. It was a newfangled thing, like the new buzzword. It's, I actually think it was the moral equivalent of the AI term back then, cloud. Nobody knew what the cloud was the cloud, cloud computing, is it real? Who knows? But one of my favorite Easter eggs in this early blog post is example names. If you look at the example names, they're actually all IM team members from back in the day. And you see this gym right there? You wanna take a wild guess who that is? Just a wild guess. It's none other than my co-presenter Jim today. Jim was the leader when AWS launched IAM in 2011, not that I'm trying to date Jim, um, but, but he's still at the forefront of authorization talking about Cedar and MongoDB. So you know it's you gotta, you got that authorization train going, but even more important, there is no neha in that blog post. Because in 2011 I was at NASA applying formal verification technique to correctness of aerospace systems. And I joined AWS in 2016 when the cloud had expanded to hundreds of services it had become the norm and when I started in AWS I started at AWS security where at the time my charter was, can you figure out how to use formal verification to help raise the bar on security? And one of the first things I ended up working on was how to ensure that there was no unintended access to resources and this led to a series of uh innovations in applying formal verifications to security and that's what we end up called provable security. The very first step in our provable security journey for IAM was policy analysis. In 2019 we launched IM Access Analyzer. With one click you could turn on IM Access Analyzer for your entire account or your organization. It mathematically verified that your resources did not grant public access. With one click, you had mathematical assurance that your S3 bucket had wasn't granting unintended public access. With one click you have the assurance that only your trusted organizations had access to your lambda function. The reason this was powerful was because you could leverage the power of mathematical logic without being an expert in logic or in IAM. We continued on our journey beyond analyzing policies customers said hey we need help writing these policies from the start, not just analyzing them afterwards. This led to another important advancement policy validation. We added capabilities that helped customers like you catch syntax errors before deployment, identify overly permissive policies, fix security issues, and validate the policy structure. This was like having a security and an IM expert looking over your shoulder while you were writing policies. Then came another major milestone. Applying proval security to the IAM evaluation engine itself. This wasn't just some incremental improvement, it was fundamentally changing how we thought of security at AWS. It was the mathematical verification of the authorization engine itself, formal proofs that the engine behaves correctly and verification of the security properties of the engine verification of properties such as denied does trump allow when you have so many different policy types across all the different code paths. It's not just hey we've tested it really rigorously no this is about having proved the correctness of it. And I wanna take a moment to recognize this incredible journey from 2011 to 2024. The evolution of authorization of IAM and provable security AWS tells a fascinating story of innovation. Now I want to look at Cedar in context with this entire history in mind. While I am evolved over 13 years with AWServices, Cedar represented a fresh start for application authorization, so Cedar launched in 2023. Now it didn't have to go through the same journey that IAM had to. From day one, Cedar launched with a proven correct version of the authorization engine. The theorems and proofs are open source. Cedar provides you a built in validation from the start. But you notice there is an empty box here. And I'm super excited to state that today we launched policy analysis for Cedar. It provides you the ability to analyze Cedar policies in the way that you've been able to do for IM policies. It uses the same mathematical engines under the hood that drive the innovation and power of IAM access analyzer and us three block public access. And the way it works is the cedar symbolic compiler transforms cedar policies into mathematical logic. It converts human readable policies into formal mathematical representations. With that representations we can prove who has access to what for your applications. And built on top of all of this is the Cedar analysis CLI. This is the powerful tool that you can use to answer the questions. It helps you understand what does this policy actually allow. Who who can access these files who can delete these tax returns it provides concrete examples of what policy outcomes are and it helps identify unexpected combinations that's resulting wait why did this end up having access? So some of you may say, wait, what's a symbolic compiler? You may not have heard of one. So I'll talk about it in the context of a traditional compiler to compare and contrast. A traditional compiler, as most of all of us see, takes a program and generates low level code either in assembly or bytecode, and that is optimized to run efficiently. While a symbolic compiler takes a program and generates logic or math. But you cannot run that program on your machine. But there are different engines, automated reasoning engines that reason over symbols and variables in that program. So what does it let you do? In a traditional compiler you can efficiently evaluate a single request uh with respect to a host of policies and say hey is access granted or denied. But with symbolic compilation you can reason about infinite requests that could happen that could be made to the policies to make statements such as there is no public access to your private photos. This is important to understand these two key differences. That is what makes the analysis feasible. That's what makes us able to say what might happen in the future, and that gives us the assurance of what may will never happen given the set of policies you have. I've mentioned this before, but Cedar is open source, but not just the code, but the scientific research that goes into it. This is the semantics of how traditional compilation works for cedar, and this is the semantics for how symbolic compilation works for analysis cedar policies. Before I head off to gym, I'm gonna give you a very quick taste to. I've said the word proof and logic a lot, but what does the proof actually look like? So this is a proof that our symbolic compilation is correct with respect to the concrete evaluation. Which, which is the semantics of cedar. This says, given a symbolic version of the concrete environment. Any result we get from symbolic evaluation matches every possible concrete evaluation. Many to many. And we can prove it. So this is a proof written using lien and again for anybody who's interested, uh, please reach out uh go to the GitHub repo these proofs are open source. And I'm gonna put that in the context of what does it mean? What about me? How does, how does it help you? Let's take a look at what the policy analysis does in action. This is our, you know, example that we've been using the reinforced attendee permission. This is the the policy on who can attend the sessions. Uh, the first condition needs to be that you're registered for the session and walk-ins are allowed only if the session is in full. We could write the same policies split into three different policies you may want it, right? Like you may want it for better maintainability or for whatever reason. The first policy says you can attend if you're registered second policy says you can attend if walk-ins are allowed, and the third policy says you can't attend if the session is full. OK, take a minute to look. Does it the question you wanna understand is Is the refactoring correct? Is the policy on the left equivalent to the policies, the combination of the policies on the right? I see some shaking their heads. You may be tempted to think the answer is yes. But the answer is no, as I saw some of you shaking your head and no, I see on the 3rd row, very vehement nose there. The one on the left is more permissive, and the reason is that the forbid statement will not let registered attendees into the session either. Forbid Trump's permit. Say, how do we fix it? We actually have to combine policies 2 and 3. We can permit walk-ins only when resource is not fully allocated. So after we make that change, is the left equivalent to the right? Yes. But the key here is like the takeaway. This was a simple example, right? But even with a simple example, we sit there trying to do the logic in our heads. Now imagine this is spread across hundreds and thousands of policies across millions of users, and even doing a simple refactoring when it comes to authorization can be difficult. You wanna ensure you're not breaking your customers as you you wanna ensure that you know agility is maintained availability is maintained, correctness is maintained. And the best hope without the analysis is like hopefully you've got good test coverage and you're able to catch it but with policy analysis you get a definitive answer and that's the power of it it gives you this ability to ask things like are these policies equivalent? Does this change to my policy grant any new unintended permissions? Can this policy grant access to this resource? Will this refactoring break anything for my users? All of these questions you can ask using the CLI. And I really wanna emphasize that we took a security force approach we prioritize security over expressiveness if somebody comes to me and saying, hey, I'm using this X and it's more expressive it lets me do these things that Cedar doesn't and I'm like. Yes. That's by design. I'm like this is not a Turing complete language that's by design and. I, I, I say other things too, but like the point is. And it's like you want you wanna provide guard rails, right? Like you you you actually wanna say this is what the box in security looks like. This is where you should operate your authorization system. And which is why it was a big decision in us making this open source we want democratize this part of security, make it easy for people to see and use, and I'm personally very excited to see how Mongo has made uh Cedar part of their security and how they make security available to their customers and with that I'd like to introduce Jim to talk about Mongo's journey in using Cedar. Cool, uh, thanks, Neha. Uh, thanks for inviting me here. I'm excited to talk about how Moga B has been using, uh, cedar. So first, uh, a little bit about uh manga to B in case you don't know, it's a modern horizontally scalable database. It's document oriented, uh, which can be far more flexible and easier to work with than traditional rows and columns of a relational database. It's uh scalable by design. It horizontally shards, uh, so it can handle uh much higher availability and performance, uh, for even very large data sets. Uh, you can run it anywhere, so we have, uh, Monga to be Atlas is our managed, uh, database as a service offering, and, uh, what is interesting about that is customers can with a few clicks of a button run at top, uh, over 117 select from over 117 regions across 8RS uh environments. Google's in GCP environments or Microsoft Azure environments and that plays in as I'll get to in a minute is we need to be able to uh model access control and enforce uh authorization decisions across these three cloud providers and not just data that so that that makes our needs a bit more unique um and I'll talk about that. And then last, uh, it's very integrated so uh we provide uh a bunch of additional functionality including things like streaming support, full tech support, and, uh, vector search all, uh, is part of Atlas and so this plays in because now we're evolving our product space and we need uh an authorization engine that can model increasingly complex and and new uh resources. So when I moved, uh, Sneha shared, you know, I, uh, earlier I was at Amazon Web Services, uh, and when I moved to Moga to be one of the first things I noticed were, uh, we had very familiar customer base, uh, so some of you may know Moga to B, uh, you know, originally became very popular among developers earlier on, but it really grew and matured over the years and now, uh, over 50% of the Fortune 500 are Manga to B customers. Uh, so amongst our customers, I recognized banks, healthcare, uh, organizations and government agencies that I had actually worked with and supported when I was at Amazon Web Services. Uh, including customers such as Wells Fargo, Intuit, Stripe, and GE Healthcare. These are very demanding customers from a security, uh, and compliance, uh, point of view. And so in my experience working with these companies taught me that security resilience, scalability and performance really take precedence over any new shiny features, uh, basically you only earn the right to talk about new uh features once you've addressed their, uh, needs on things like security. So, uh, you know, when I came to the Manga DeB team, I really tried to instill that security had to be built into everything we, uh, do at Monga to B. And so you know I'll talk now about how as we looked at some architectural changes we're doing, how we looked at that and why we evaluated Cedar and how that went. So you know, first a bit of history on the manga to B side. So when Moga to be Atlas launched, it had a role based access control. So very similar to the Layard example that Neha was talking about, uh, earlier, you can, you know, say, hey, this is an, uh, administrator, and they should have access to, you know, starting stock clusters. This is developer they should have access. You know, to, to write data to clusters, etc. um, and this can be very usable and has been for a number of years for our customers, um, it's, uh, intuitive, easy to use, understand, oh, I'm a gray badge. I can go in or my gray badge is off, but, uh, uh, uh, I can go into the executive lounge or or what have you and oh I can't go into the, uh, keynote lounge or or or something like that um so it it it's very easy for customers to get started. But over time, uh, you know, our most demanding security, uh, customers have even higher demands on top. Uh, they wanna manage access control across, uh, many users, uh, both human and, uh, uh, systems, and they need to set, uh, uh, guardrails, uh, on resources, uh, you know, for example, prevent any user from deploying clusters on cloud provider, uh, let's say Azure, uh, since we're at an AMS conference, I'll just, uh, or require, uh, a recent TLS version for a database connections regardless of a user's role. Uh, and so that's, that's a requirement we're hearing from our customers. Uh, and roles aren't the greatest for that. Uh, roles aren't also aren't a great solution for more fine grain entitlements which are needed in cases where, uh, OK, well, you know, I'm a, uh, I'm a speaker, so I should be able to get into only this room and only 15, you know, 15 minutes before and 15 minutes after my talk. Uh, now you create a different role for each room and speaker and session or whatever it can get very complex and very unwieldy and hard to manage pretty quickly. Uh, so you know we basically said, hey we gotta develop something different. And uh you know, we, so the, the Atlas team uh before I arrived, they took a look they're smart people they looked and they said, hey, in some of the same symptoms that Neha shared, uh, uh, previously, the code, uh, the authorization logic and and checks were embedded directly with the application code. Um, so when, when the, you know, compliance folks come in or security folks come in and say, hey, who has access to what or prove to me or whatever, it can be pretty complex because you have to basically trace it through all the application code. Uh, it also was fairly scattered. It was implemented in multiple places across our code base. So it was uh imminently clear that our system had to evolve. So you know the team knew right away that they had to uh separate out our authorization logic from the rest of the code that was the easy part of solution um but what to build, so they needed all the components of an authorization system you know policy administration information, uh, decision enforcement, but they hadn't, uh, ever tried to implement these standalone components, uh, but you know they thought it'd be hard but they figured, uh, they could figure it out. They evaluated several third party solutions at the time, both free solutions and paid solutions that offered pieces of the puzzle, um, but as it got deeper they ultimately concluded that none of them was uh really, uh, had the right mix of things, um, both the features and level of support that we needed because again, you know, we're running, uh, you know, databases from for some of the large banks, uh, and healthcare and, and, you know, enterprises in the world. Uh, so reluctantly they proceeded to start down the path of building their own authorization solution in Java. And so we had, you know, great engineers, but, uh, hadn't done this before, so they looked out at industry looked at prior things including the, uh, ASIM access control language to kind of get inspiration of hey, what should, what should they do, um, uh, they, and they went and started looking at the business modeling as Neha said one of the more first things you need to do just from a business perspective is just kind of model what are the resources, who are your principles, who should have access to what, these kinds of things. And they succeeded in building an authorization engine along with policy offering policy storage which was kind of easy because we're we are a database uh uh and uh entity storage are entities like, uh, you know, objects in the system like organizations, projects, database clusters, etc. But as it got deeper they could see it was gonna be increasingly challenging to add more features uh to the engine. It was taking longer uh than they thought like no software project ever before in history so as you got deeper it got a little bit more complicated than they thought. Uh, so for example, areas of complexity is like, uh, you know, they had a new boss come in, uh, and say, hey, what about, uh, uh, conditions or policy hierarchies or name spacing and the more they built, the more they saw the complexity, uh, that they were gonna have. Uh, And then, you know, as I, uh, was asking about uh the security requirements around this, I was like, OK, how do you test all this as Neha said, uh, the AOSIM team learned starting in, you know, 2011 and proven over, you know, trillions and trillions of authorization requests. This stuff is hard to get right and originally uh because the just the science of automated reasoning which just wasn't there, you know, uh, AOSIM couldn't prove it was secure from, uh, by default, uh, and, and so we basically the team in the AOSIM had to evolve and learn and add tests over time, uh, you know, sometimes hard earned lessons there, right. Uh, and so, uh, coming into Moga to be I was like, hey, I don't want to repeat, uh, that pain in learning both for us and our customers. How can we ride at top, uh, the learnings and advancements in the technology of automated reasoning, uh, and that, uh, Cedar has, uh, built? So I asked the team to, uh, evaluate Cedar, and this is hard because our team had gotten decently far along, uh, at, at building a, you know, pretty good, uh, take at their own authorization engine. Uh, so they took a, a, a, a look at Cedar. And you know, first they found uh you know it was it was a pretty good uh strategic match for manga to be for a couple of main reasons. uh, first is part of the AOS ecosystem Moga to be inherently gains from the extensive, uh, security and automated reasoning. Investment and expertise that AS invests into Cedar on an ongoing basis, um, and that so you know, so things like Cedar being provably secure, uh, that that investment, uh, makes it sustainable and it's really an asset for us and then as I go to our customers who are banks, governments, Fortune 500s, these kinds of things as well as individual developers thinking the next startup idea. of us being able to say you know this is provably secure from the start, uh, really helps to trust with customers, right? And then knowing that ASS, uh, uh, uh, and, and Amazon, uh, like the Kuiper example, they're using Cedar itself, um, you know, it really gave us confidence that the rate of innovation was gonna continue and the more companies like Monga to B and others that we invite others to uh to do can really spin the flywheel of this open source, uh, project and you know the more we we all contribute the more uh things learn and grow. Uh, and then, you know, the, the other thing is Cedar's open source nature mirrors MongoDB's original, uh, DNA, allowing us to use it but actively contribute back to the growing ecosystem. Uh, and then, you know, as I mentioned before, this is important too because we're not just modeling resources on ARS. Our customers, you know, many choose to deploy their, uh, database clusters on HRS, but many also deploy on, uh, Azure and GCP as well, and we have to be able to model on those. And so from a developer perspective, a few positive aspects certainly immediately stood out to the team. So, uh, you know, Cedar is designed to be able to express any of the authorization uh requirements we could think of both present and future. So so it includes, uh, built-in support for conditions, uh, as well as both role based access control uh role based access control and attribute based access control models, uh, so really showed that hey, as we go forward and our needs expand and we need our customers need us to get more advanced, Cedar can be right there with us. The other thing is because we had started down the path of building our own policy engine, the Cedar core library is, uh, uh, really we were able to swap in fairly easy. uh, Cedars built in rust, but it just provides the Java bindings that made it simple for us to invoke from our existing code base, which was very nice. Um, and then Cedar provides and enforces a simple data model and clear syntax, relieving us some of the challenges of trying to define these things in a futureproof way. Also, as Neha was pointing out, uh, Cedar being very readable, uh, uh, as, as policy languages go, Cedar is quite human readable, and that's gonna make it easier for documentation, training, and our end customers as well. So there's a lot of, a lot of benefits. So let's look at the first place we're using the power of to address Atlas' customer needs, Atlas resource policies. So in April we released a solution to these challenges, uh, to some of the challenges I talked about, uh, in terms of adding guard rails, etc. uh, Atlas resource policies, and they allow customers to set guard rails at the organizational level in Atlas to enforce configuration standards, uh, maintain consistency and provide, uh, prevent misconfigurations across all clusters. And so a few facts about resource policies, they're very similar in purpose to AOS's resource control policies in the sense that both are designed to express limits that apply to an entire organization. Uh, they apply to all users in that organization. Uh, and there are their guard rails implemented as forbid statements, uh, using the cedar language enforced by Atlas, uh, I gonna to be code at run time for all users. Uh, they set resource policies set hard boundaries on what configuration options are allowed. And then they do not grant access to users uh for users to have access to any resources, they must be explicitly granted appropriate permissions via uh user uh policies. So now I'm gonna get into a demo of how customers can use resource policies based on Cedar to achieve these goals in their environment. Now, So, uh, for this example we're gonna do a demo of implementing org level, uh, guardrail using Mo to be Atlas resource policies. We, uh, for this scenario we're gonna ensure that, uh, our DevOps team can only create Atlas database clusters, one in Amazon Web Services cloud, not in Azure or GCP. And then 2 in two specific regions that that we want as a business to operate US East 1 and US West 2. OK, so first we're gonna create a policy, and here we're giving it a name and a description so that we'll know you know the, the human intent as we're start offering this policy. And so as we get going, we're gonna next step after this we're gonna then author the Cedar policy to uh oh by the way this is all within the uh Mo to be Atlas uh console so now we're gonna basically forbid and we want to forbid all users human users and service accounts. Uh, the ability to modify a database cluster. And the scope will be global. It's going to apply to all clusters. And then it, uh, unless. Uh, it's in the two regions that we trust US East One and US West 2. And so we can see there the policy has been applied. And then we're gonna go to the test project and create a cluster. And you can see there that uh the users getting information that uh uh policy a research policy may apply which is useful because sometimes when they have issues uh they don't know why. So here the the user is saying hey I wanna go US East to us. And we see that they're forbidden because that's violating uh the the Cedar policy that we offered in the prior screen. So now this was perhaps just unintentional, uh, so they go back and they can go back in and now if they choose a region that is in our list. Now creates deployment And now you can see in the bottom left hand corner the cluster is processing and uh it succeeds so that just was a short example of of cedar inaction in Moga to be Atlas uh to uh do uh guard rails and so you know these are, you can see these are clear declarative policies built with cedar enforced uh in Atlas all easy to manage in the uh Atlas uh command line and UI. So you know, key learnings we had as a team is building an authorization system from scratch is hard. There is hidden complexity is a big issue, as Neha's little example of debugging or comparing two policies here in the room shows, even something simple can actually be more complex than you think. Uh You know, uh, like, like any security security technology, you know, build what you must, but defer or build upon experts wherever possible. And then you know we also had the learning you know we we kind of happened on this, uh, just given the way of our project happened but we invested up time uh up front to dig into deep into the entity models, actors, resources and actions, uh, the business modeling really is a lot of work and getting that right is really critical to implement implementing something. And so, uh, what's next, uh, well, our customers already are using resource policies, and they're asking us for more features and enhancements to that, um, we're completing the engine upgrade, uh, you know, currently we have cedar, uh, used for authorization in a number of places in code. We're basically making that, uh, to 100% to enable, uh, more work to come. Uh, customers are asking us for more flexible policy assignment, uh, so maybe not just at an org level but in different parts in the, uh, hierarchy. Fier grading access control and custom uh roles uh support and then access analysis and recommendations as Neha had on customers are also asking us for things like that. And with that, I'll turn it over. Back to you. Thank you Jim. That's I like to me I'm very fascinated by, you know, this instance of MongoDB going through very much the same experience that we've been talking about in previous version of the uh in you know in the beginning part of the talk and I. I imagine and I can bet on the fact that there's many others you in your companies or others that are going through that same process and really the lesson learned is that like as Jim said building an authorization system from scratch is hard. And my corollary to that is building a policy infrastructure from scratch is also hard because like MongoDB, most of your businesses are probably not doing databases for a living. And it goes to what does it mean by policy infrastructure and what does it mean for your core business to not be databases it's, it's about saying how do I centralize, how do I manage the Cedar policies in a central way you needed to create some space, need to put them and verified permissions is that managed service that provides you that single central location. You create, manage, evaluate, audit, and log your policies all through APIs. It makes it easy for you. It's the easy button. My analogy for this is Cedar is like the engine and verified permission is the ready-made car powered by the engine. Mongo and Jim took that Cedar engine and built their own custom vehicle around it, but verified permission gives you an easy to use, ready to use car without needing to build one. And there are benefits. So what are the benefits you get out of it? Some are native to using verified permissions. How do you select the policies that are applicable? How do you do fast evaluation? How do you ensure that the, uh, propagation from the control plane happens to the data plane. Then there's integration benefits into AWS. They have native integrations for Cognito and API gateway that you can just use AVP right within the rest of your AWS ecosystem. And finally there's the standard AWS benefits such as IM controls who can create a policy store who can delete it? There's cloud trail logs for the different policy changes all the things there's tagging, all the things you get right out of the box for uh for an AWS service. Now let's look at a quick demo to see what benefits you getting this card gives you. How does AVP actually integrate with some of the other services? All right, so the setup for this demo is I have an API on API gateway with uh attend and register end points and to prove that this is a real API I'll call it here so I'll call register it says that that action happened. I can call attend. That will happen. This is just a public API endpoint. You could call it. Please don't. Um, but what I'm gonna do now is I'm gonna add verified permissions on top. So I go to the verified permissions console. I say create a new policy store, and one of the options here is to set up API gateway with an existing identity provider. So I'll click next. Here's my API from API Gateway, the reinforced API that looks good. Now I picked the identity source. I can pick an external one. In this case I'll use Amazon Cognito because I have a Cognito reinforced attendees user pool. Next, And then in this pool I have three groups, uh, customers, speakers, and sponsors. So at this point I can assign some, uh, permissions to them so customers can attend and register, speakers can attend but not register, and we'll say sponsors can also attend but not register. Click next and then finally I can pick if I wanna start authorizing now or later I'll pick now. And go and so the first thing it does is it creates a policy store and we'll go look at what that looks like. So here's my Amazon verified permissions policy store. This is kind of like the notion of a bucket S3. It's where you put all your things. So here's where you put all your policies. In this case, I have 3 policies in here. The first one is the policy for the speakers' group. You can see it says that uh these users are allowed to perform the attend action. Next policy is for the customers group. They can attend and register. And the last policy is for sponsors who can attend but not register. One of the things that's nice here is it creates a schema. So schemas are useful whenever you attach a policy, it gets validated against the schema. So in this case, based on the API gateway set up, it created a schema for me with the user, uh, two actions and resource applications. So for your application you would eventually extend this with other types of resources like sessions or the expo or lunch, uh, but this is enough for us here. And the other thing that it does is it attaches an authorizer in API gateway. So if I look at my API over here under authorizers, here's this AVP authorizer that it deployed. And now if I switch back and call the register. API it should give me access denied, but there's like a 2 minute propagation delay, so we're gonna see how well, uh, I've stalled for time not well enough, still allowed. Uh, it takes about 120 seconds for API gateway to stop caching authorization responses. So if we give it about 10 more seconds, I think it'll, uh, give us access denied here. Um, one last thing, so the way this is all done behind the scenes, this authorizer is deployed through cloud formation, so there's infrastructure as code for, um, the lambda that's behind it, how that connects to Cognito, and how that connects to API gateway so you can, um, make that part of your pipeline and deploy it, um, in a more standard way rather than just clicking through in the console. Well, it's taking longer, that's a good sign. So now you can see it's denied and if we pick attend instead, we, oops. Uh, attend should be allowed, but that one I must have also clicked the wrong button because that one's also getting denied. Well, it's denied by default, so all right, back to you, Neha. OK, thank you for the demo and That really goes to show how we're thinking about authorization being having its place in modern infrastructure like the fundamental building blocks of your application you need compute to run your code you need storage to keep your data you need databases to organize it these pillars of modern infrastructure. And with the economies of scale allows us to provide you authorization as an infrastructure building block you can benefit from our scale from our investment in it and get enterprise grade security. And you get to not have to reinvent the wheel for something that is not your core business and for that I'm super excited that we are making this enterprise grade of uh service available to everyone with a price reduction with $5 million for $5 per million authorization requests. Uh, we, we, we led to a 97% price reduction because we've invested a lot in making this scalable and providing it in a way that comes to you at, uh, comparable to your other infrastructure, uh, costs and that you never have to roll your authorization again. So ending up, how do we end it, uh, if anything, the lesson is. In what Jim said, building your authorization system is hard and again to my corollary, so is managing the whole authorization system and you have so many interesting and exciting problems to be solving for your customers so you cedar and verified permissions for your authorization whether it's your green field applications or your brown field application. Get started now. There's the Cedar policy playground. It's all open source and we have the Amazon verified permissions, uh, system. Please go fill out the session survey, um, how you liked and we, we, we always love to hear feedback from our customers what you liked about the session, what you didn't, um, you know, what would you like more of, so we, we very much read every bit of the feedback we get so please, uh, take the time and I wanna thank Jim again for, uh, you know, participating and co-presenting with me and thank you all for coming. Hope you all have a great rest of your reinforced. Thank you.
