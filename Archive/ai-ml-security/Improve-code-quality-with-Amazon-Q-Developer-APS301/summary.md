# AWS re:Inforce 2025 - Improve code quality with Amazon Q Developer (APS301)

**Video Link:** [Watch on YouTube](https://www.youtube.com/watch?v=INaOtmBe0lM)

## Video Information
- **Author:** AWS Events
- **Duration:** 56.2 minutes
- **Word Count:** 10,265 words
- **Publish Date:** 20250618

## Summary

This comprehensive technical session demonstrates how Amazon Q Developer integrates throughout the entire software development lifecycle (SDLC) to enhance code quality, security, and developer productivity. Presented by Daniel Beimmer (Global Services Security) and Brian Beach (Next Gen Developer Experience), the session covers five key SDLC phases: plan and design, develop, build and test, monitor and respond, and upgrade and harden.

The presentation showcases Amazon Q Developer's evolution from simple autocomplete to sophisticated agentic capabilities that can autonomously execute complex multi-step tasks. Key demonstrations include threat modeling integration with organizational wikis, automated security scanning using Inspector and CodeGuru detectors, autonomous code generation for feature requests, and streamlined incident response for Kubernetes security events. The speakers emphasize that while developers typically spend only one hour daily writing code, Amazon Q Developer addresses the remaining seven hours of "undifferentiated heavy lifting" including documentation, testing, code reviews, and security analysis.

Practical scenarios demonstrate real-world applications: automatically generating CloudFormation templates while enforcing organizational security policies, performing comprehensive threat analysis using STRIDE methodology, implementing features across HTML/SQL/Python with automated testing and documentation, and conducting sophisticated security investigations in Amazon EKS environments. The session concludes with transformation capabilities for legacy code upgrades, showing how Java 8 applications can be automatically upgraded to Java 21 with detailed migration plans and code refactoring.

## Key Points

- **Full SDLC Integration**: Amazon Q Developer covers all software development lifecycle phases from planning and threat modeling to production monitoring and legacy code transformation
- **Agentic Evolution**: Evolved from autocomplete to autonomous agents capable of multi-step reasoning, file discovery, and complex task execution without manual context management
- **Security-First Development**: Integrates organizational security requirements from wikis and knowledge bases, automatically enforcing approved services and generating security-compliant architectures
- **Comprehensive Code Analysis**: Combines composition analysis (OSS vulnerability detection using Inspector), static analysis (security pattern detection using CodeGuru), and AI-powered peer code review
- **Developer Productivity Focus**: Addresses the reality that developers spend only 1 hour daily coding by automating documentation, testing, reviews, and other "undifferentiated heavy lifting" tasks
- **Multi-Platform DevSecOps**: Native integration with GitLab and GitHub for automated code reviews, security enforcement, and autonomous feature development from issue descriptions
- **Advanced Incident Response**: Demonstrates sophisticated security operations including Kubernetes investigations, playbook automation, and multi-environment command execution
- **Legacy Modernization**: Transform capability automatically upgrades legacy applications (Java 8 to 21) with detailed migration plans, dependency updates, and code refactoring
- **Enterprise Security Standards**: Maintains code ownership, provides 99.9% SLA, ensures SOC compliance, and doesn't use customer code for training purposes
- **Proven Performance**: Achieves 66% success rate on SWE-bench real-world issue resolution and delivers 40% development speed increase with 70% testing efficiency improvement (Deloitte case study)

## Technical Details

**Amazon Q Developer Architecture:**
- Built on AWS generative AI stack with three layers: infrastructure (SageMaker, GPUs), foundation models (Amazon Bedrock), and applications (Q Developer, Q Business)
- Available through Q CLI, IDE integration, and AWS console with agentic capabilities for autonomous task execution
- Enterprise-grade security with code ownership protection, no training data usage, 99.9% SLA, and SOC compliance

**SDLC Phase Integration:**
- **Plan and Design**: Wiki integration for security requirements, threat modeling with STRIDE methodology, organizational policy enforcement
- **Develop**: Code completion, documentation generation, unit test creation, security scanning integration
- **Build and Test**: CI/CD pipeline integration, automated code reviews, composition and static analysis
- **Monitor and Respond**: Security incident automation, playbook execution, multi-environment investigation
- **Upgrade and Harden**: Legacy code transformation, dependency management, automated refactoring

**Security Analysis Capabilities:**
- **Composition Analysis**: OSS vulnerability detection using Amazon Inspector detectors for known CVEs in dependencies
- **Static Analysis**: Security pattern detection using Amazon CodeGuru detectors for hard-coded secrets, SQL injection, and other vulnerabilities
- **AI Code Review**: Large language model-powered peer review for readability, maintainability, and security best practices
- **Threat Modeling**: Automated STRIDE analysis with custom prompts, severity assessment, and mitigation strategy generation

**DevSecOps Platform Integration:**
- **GitLab Integration**: Merge request automation, security enforcement, automated fix generation and application
- **GitHub Integration**: Issue-to-PR automation, autonomous feature development, automated security scanning
- **CI/CD Pipeline**: Automated reviews, security gate enforcement, composition analysis integration

**Incident Response Automation:**
- **Kubernetes Security**: Amazon EKS investigation automation, pod analysis, service account management
- **Multi-Environment Commands**: AWS CLI and kubectl integration, automated forensics collection
- **Playbook Integration**: Automated execution of security runbooks, containment procedures, network isolation
- **Reporting Generation**: Executive summaries, IOC extraction, timeline analysis, remediation tracking

**Code Transformation Framework:**
- **Language Support**: Java version upgrades (8 to 21), dependency management, API compatibility analysis
- **Migration Planning**: Detailed transformation plans, file-by-file change analysis, impact assessment
- **Automated Refactoring**: Code structure updates, dependency version management, compatibility fixes

**Performance Metrics and Benchmarks:**
- **SWE-bench**: 66% success rate on real-world GitHub issue resolution
- **SWE-bench Test**: High performance on unit test generation benchmarks
- **Customer Results**: 40% development speed increase, 70% testing efficiency improvement (Deloitte case study)
- **Security Detection**: Outperforms publicly benchmarked security analysis tools

**Integration APIs and Tools:**
- **Knowledge Base Integration**: Atlassian Confluence wiki connectivity, security requirement parsing
- **AWS Service Integration**: CloudFormation generation, service policy enforcement, resource compliance checking
- **Development Tools**: Forward-slash agent commands (/dev, /test, /review), contextual workspace analysis

## Full Transcript

Welcome to APS 301. Improve code quality with Amazon Q developer. My name is Daniel Beimmer. I'm a senior security engineer in global services security. I've been AWS for over 5 years now, based in New York City. In my day to day job, I'm working with customers on streamlining security incident response operations and also leading the application security technical field community. So working closely with customer service teams and field teams on ASIC. Today I'm here with Brian Beach And hi everyone my name is Brian Beach. I'm the tech lead for our next gen developer experience community. I work with all of our developer tools and focus on uh developers. I am based out of North Carolina and I've been with Amazon for just over 10 years. Thank you, Brian. So in the next 60 minutes, we're going to dive deep into Amazon Q developer. This is a 300 level session, so we're going to be technical, we're going to show you uh CLI code, um, demos that's based on real world scenarios. We're going to start with a quick introduction about Amazon Q developer. Then we're going to dive deep into each phase of the software development life cycle. And on each phase we're going to show you an example of a challenge, a scenario, a persona, and how we can handle it better using Amazon Q developer. We're gonna start with plan and design. How you can threat model an application before before you even like start building it, how you make, how you, how you make sure that you're building it the right way of walking backwards from your security requirements. Then we're going to discuss the develop phase. Brian going to show you how Amazon Q developer can walk along alongside of your developers to write a more secure code, to be more productive, to understand your code better, to generate documentation and unit testing. Then we're going to touch the build and test how Amazon Q developer can integrate into your CICD pipelines, your GitHub, Gitlarepo generate code based on PFRs, a feature requests, or run automated reviews in order to identify security issues in your code. Then we're going to touch, monitor and respond. You have your application already developed. It's running in production. You have a security event. How you can streamline those security operations, how you can use Amazon Q developer to work alongside your SEOs team or incident response teams in order to react to security events. And in the end we're going to touch upgrade and harden. You have your application already running there. You have a new vulnerability, a new security issue. You have a new requirement to make a major upgrade. How Q and the transform capability can really help you to do this in a more easy and efficient way. So as I mentioned, we're gonna start with like a quick introduction, couple of slides about Amazon Q developer and our uh GI stack. So maybe like if you can raise your hand, please, if you ever used Amazon Q Developer before. Alright, so I see some, some key developer users. Uh, this is our, our GI stack, right? We have like 3 different layers and, uh, each layer represents different type of services that we provide to customers. Starting from the bottom is like all of our infrastructure level services or Amazon Sage maker, the GPUs, high performance compute those can help you to build and train your own models, give you like flexibility and it's like a cost effective and scalable solution that you can use. Then you have Amazon Bedrock, our fully managed service that can serve you foundation models of our models and our partners which you can integrate directly into your applications. And then we have the applications that can help you to boost productivity. Amazon Q Business that can help you to get insights and operations into your business, and Amazon Q developer that is very focused on the software development life cycle, which we are going to focus on in this session. So what is Amazon Q developer? Uh, so Amazon Q developer can help you to run productivity to develop code faster and more secure. Uh, it can work alongside your security engineers, your software developer engineers, your engineers, and really help to to run operations and also generate code and scan it for security issues. We have like uh Amazon Q developer is available through the QCLI so you can run it from the CLI from the IDE or from the console, and it also has agentic capabilities so it can run autonomous actions for you based on the task that you will provide to it and we're gonna see some examples later today. Amazon Q developer is also trained and integrated well with AWS so it can be your AWS expert in any services and things that you want to build on, on AWS. Now this is a security conference. We need to talk a bit about the security features and capabilities of Amazon Q. So, when you develop an Amazon Q, you have full ownership of your code. The code is yours. And when you use the proto, we we're not, we're not using anything for training data, etc. The code stays yours and stays secure. Uh, we have an enterprise SLA 99.9, and we also saw compliance. So similar to other services and other solutions that we have, we insisting on the highest, highest standards when it comes to security, uh, and it's relevant when we talked about Amazon Q as well. So we really like just said like a quick overview about uh Amazon here. I want like to dive deep directly into the different phases of the software development life cycle starting with the plan and design phase, right? And we're gonna start with our first scenario. We have our software developer and he has a he has a task he needs to build a new application. Let's say for this example a new like CSV processing application. And he has a long list of security requirements. Now they can be maybe centralized in a wiki. In our case we're gonna have like uh a wiki, a confluence wiki that has the guidelines from the CCOE. But the the the software developer need to work with the security teams or work with uh Wiki in order to really identify what he needs to build, which services are allowed, what are the best practices, what are the organizational requirements. And we're gonna see really how Amazon Q can help us to to streamline this process. So You can see here that I have my conference wiki so I have my uh my wiki with some security requirements so uh you can see the allowed services that are allowed in the organization, the block services that I that I shouldn't use. And you can see some standards, so like which, what are the transformation standards, what how services needs to be configured, uh, etc. So we have those requirements defined already in our, in our wiki. I'm going to jump into QCLI. And I integrated the M of Atlasian in this in this QCLI, so I can start by asking which tools are available. So I'm getting a list of the available tools and one of them is Atlassian means like I can now get pages for my wiki. I can also write pages to my wiki. So I have this integration with QCLI and, and my wiki page and the security requirements. Then you ask me, OK, what what's next, what we can do. So I'm asking you, hey, if you can go ahead and review the CCOE uh requirements, uh, make sure you're aware to them before I even start to plan and build my application. The key will go and fetch the relevant information from from my wiki pages. Just gonna give it, um, give it a moment. And after a while like we can see the queue already reviewed the the pages and you understand like which services are approved, which services are not approved, so he had this context he can understand how better my uh my security and organizational requirements and now when the developer starting to to to run the the development itself of this new solution, he will have that context in mind. Next, I'm gonna ask you to really develop the application for me, so I want like a CSV application uh to store CSV file, S3, SMS, lambda. So I'm gonna, I'm gonna input it into queue. After a moment you can see that like you like uh will generate a cloud formation template for me but it's also saying that hey you're using a service that is not allowed uh uh you want to use SNS topic and this is like uh not one of the approved services this is a blocked service, uh, so you will automatically will identify that and also suggest a replacement. So in this case he picked SQSQ. And generate for me the full cloud formation template. Based on the application that I wanted to build uh with with the different requirements. OK, I, I build the application and like it's really looks good, it's what I wanted it to do. I, I tested it, it's working, uh, and I'm aligned with the, with the security requirements. I need to write documentation, right? Who likes to write documentation, uh, so we can use Q really to also like uh automate this phase. So since like we also integrated again with our wiki, we can not just generate documentation based on the solution we can also push it back as as a wiki page so I'm gonna ask you to do it for me and uh probably gonna take a couple of moments and then in the end and I expect to see like uh a wiki page with my new app with the relevant documentation how to deploy it, uh which uh how is the architecture and how how the different components are configured. Here we go. So this I hope this like really help you to get like uh some ideas about how you can really integrate you with your uh knowledge bases with your wikis whenever you store your security requirements and really if we can really help to build in a more secure way walking backwards from from your organizational and security requirements and help to bridge the gap between the security and and the developers. I'm gonna give you another example scenario this time we're talking about threat modeling, threat analysis. We have a security engineer that comes to a new application that has been developed by the developer development team. They want to deploy it maybe to production, and we want to understand what are the security risks that we have there, right? So like as a security engineer, I can now like dive into the code base and try to understand the inputs and outputs and try to understand what can get wrong there, but I can use you that will help me to achieve that in an automated way. So now we're gonna show you like you from the ID uh not the CLIs last time. So I have my, my flask here like an example application and I already created a prompt for threat analysis so you can customize and create your own prompts and store them in markdowns and use them, uh, use them against your projects. With you I can also pick the specific context so I can like give you the whole workspace so I can give a specific file or a specific directory. In this case I just picked like the the specific project for Flasker. And we can see that you ingested all of the all of the project files and here you can see right now my mark down with my customized prompt so I'm asking you, hey, I want you to create a threat analysis. I want to, I want you to include severity, uh, you should include also like mitigation strategy please use stride. Uh, and give me, give me the list of the evaluations and give me the, the list of results in this specific format. So he will go and we will run the action against the context that I gave it. And in a couple of moments I expect to see like uh the you you go I can see like the list of severities uh high severities, medium severity, so I can see some SQL injections there and uh improper handling of credentials so you identify those security risks. And he also created a markdown for me with a list of the security findings. So I hope this again like help you to uh to get more familiarity with the with how you can create custom prompts with you uh and how you can run like threat modeling with you and help to streamline the security process with the development process. Alright, so we plan and design our application. We, we made the threat, the threat modeling, we walked from the security requirements, um, and the next phase we want to develop it maybe further. I want to hand over to Brian that we'll walk through about how you can use Q really to streamline the development processes in your organization. Excellent, thank you. All right, so we're we're gonna shift gears a little bit here, um. I want to move into from the planning phase of the SDLC into the developer phase. Daniel's a security guy. I'm more of a developer that's my background. And so I'm gonna look at this from the developer persona. We're gonna talk a little bit about all the things that generative AI can do throughout the software development life cycle to help the developer. And I'm gonna play the role here of a new team member, so I'm coming on to the team working on the same application that Daniel showed you at the end, that flaskar application. And I'm new to the team, so I also have a little learning to do about Flask, about Python maybe and uh about the application itself. And I want to then look at all the things that I can use generative AI for throughout the entirety of first the inner loop of the SDLC when the developer is iterating and then the outer loop when we take that into the devse ops tool in the CICD pipeline. So I'll start first with the inner loop and the developer persona, and I really want to focus here on how we can. Write code faster, of course, but in all honesty I think we overindex a little bit on this idea of generative AI helping you just write code faster, right? It's also about writing better code and it's about raising the overall quality of the project itself and. There's been a lot of studies about this. I'm sure you've seen numbers but what we're seeing is we think of developers as sitting in front of a keyboard writing code all day, but that's not actually what they do. Right, they spend a lot of their time doing undifferentiated heavy lifting. Studies are showing that developers are only spending about 1 hour a day actually writing code, meaning they're spending 7 or more hours, depending on how long your day is, doing other things like writing documentation, uh, going through planning and learning new concepts, unit tests, code reviews, all of that undifferentiated heavy lifting. So I want to look at all of that too and all the ways we can use these tools, not just to write code faster. But to do the rest of the things that are part of that larger um inner loop of the SDLC. So Daniel showed this this Flaskar application already in the last piece of this. um, if you're if you're familiar with flask, you've probably seen the flaskar application. This is the app that you build in the tutorial. It's a really simple, um, microblogging application where you can just add entries to this hypothetical blog. If you haven't ever done flask development, Flask is just a lightweight web framework that allows you to set up routes and, and, um. Configure how URLs map into your project and we'll see that in a moment. So Again, I'm gonna play the role now of a new developer, and I've been I've just joined this team and my job is to add delete functionality to this application. Uh, by the way, the typo, the Python typo is my own. You did not do that. Um, Daniel, Daniel waited till the last minute and told me about that only like a couple hours ago, so I didn't have time to fix it, um, and I've done this demo before and not noticed the fact that Python was spelled wrong, so I, I hang my head in shame. So before we get going, let's just take a quick look at what this application looks like. So I'm gonna log in here again, this is just a simple sample application. I'll log in. And once I do, I'm just going to add a new entry to this blog, and an entry just has a title and a little bit of text that goes with it. And so I'll go and add a new entry. You see it show up at the bottom. If I added more entries, they would just show up in a list at the bottom and notice that there's no delete, right? There's no delete, there's no modify. If you actually did this project and went through the whole tutorial, you would eventually add those capabilities, but I started about midway through. So my job is to come in and do that and so. I'll jump in right this is the Python Flask application. I'm gonna play the role of someone who's new to this. I'll pretend that I, I've never done flask before, so I have some learning to do. Um, you're probably already seeing some security issues. I know this is a security conference. We're gonna do some dev stuff and we'll come back to security. In a minute or two, but I'm gonna start with just some mundane developer tasks. It probably stands out to you that there are some security issues like that hard coded password right out of the gate. You also saw the analysis um that that Daniel did a moment ago. There's a lot of problems with this. It's just a sample app, so we'll have plenty of security issues to fix as we go. But the first thing I wanna do is I just need to learn and so Gen AI is excellent for helping me learn. I'm just gonna come into queue here and ask it, hey, what is Python Flask? Right, I'm new to this technology as a developer, we're new to stuff all the time. And so rather than going out to Google or Stack Overflow to learn this, I can just come in here and Q gives me a nice summary and says, oh, it's a lightweight web framework and you know gives me a page or two of documentation with some follow up links. If I, if I do know Python, I might not know the project. The other thing I can do is just come in and say, Hey, can you explain this code to me? Help me come up to speed on this project more quickly. IQ comes through and says, yeah, let me break this down for you. I'll walk you through this method, help you understand what's happening. And this is really powerful. It's as simple as that demo was, this is hugely helpful when you are joining a new project, learning a new technology. And I might iterate on this, right? I might spend 30 minutes going back and forth and talking to you about this project to help me understand it before I get going. And then after some time, once I'm comfortable. The next thing I'm gonna do is now it's time to actually start making a change to go and implement this delete and before I jump into the demo, I just want to talk about the evolution over the past couple of years, right? We launched this product originally 3 years ago and it started with autocomplete. I start typing and it starts autocompleting for me, giving me the next few lines of code, and then that 2 years ago evolved into chat and we moved the whole thing into the chat experience. And a lot of what you had to do as a developer or as a user was focused on getting the right stuff into context, having the right tab open at the time and giving it the right contextual clues to help you. This year it's like the next iteration we've moved into this kind of agentic chat mode that has a lot of autonomy and is able to make decisions on its own. It goes into kind of thinking or reasoning mode and figures out what to do on its own, so. As I start here, just a contrast, in the old days I might just start typing, and the more I type, the more accurate this suggestion would get, and I would implement delete this way. But that's the old way. The, the way we're doing it now is I'm just gonna come in here and ask you to help me implement delete and tell it I want you to do the HTML, the SQL, and the code. I want you to do all of that and you can see I don't have to have the right file open. If you notice here, Q's just looking through the project right now and finding the files that it wants to read. It's not my responsibility to figure that out anymore. Once it does, it now starts the task of of writing code and the first thing it's gonna do here is make some suggestions for HTML. So it comes in and says, OK, I'm gonna add this delete button into the HTML. Notice there's a little confirmation there. It also gives me a diff each time it does this, so I can review it. There's still a human in the loop making decisions before I commit things. Then it continues along and it says, OK, the next thing I'm gonna tackle is the SQL query. I'm going to need the ID. I didn't need that when I was just displaying it, but now I need the ID to call the delete statement later. That looks good, so I'll commit that, merge that in. And then it continues along a little bit. Now it's actually writing the delete functionality, adding that capability in. And you can see here, I'll I'll look at the diff again now it's actually done the original job, right? Add the delete capability in. So in the old days I had to sort of go to each of those files and start typing and it would finish. Now it's taking control and just doing all of this for me. And at the end of each step here it gives me a nice summary. This is an absurdly simple fix that I'm doing here, but in a more complicated one, this summary is really good to understand the reasoning and all the thoughts that the model had along the way to get here. So let's just go, you can see now coming back into the app at the bottom. I have a delete button. Python's still spelled wrong, but the delete button works. And I can come in here and delete an entry, right? So queues now come in and implemented this whole thing for me, gone through all of the different components of the application. First of all, found the right pieces of the application, and then went in and implemented the change for me across multiple files. So the scope's grown a lot in the last year. Now It's really easy to assume at this point that we've kind of done the work, right? We've, we've done the job. My job, the thing that I was asked to do was to come in and make this change. At some level I've completed the task, mission accomplished. But this is only a small piece of it, right? We said developers only spend about an hour a day actually doing the part where they write the code and make the change. There's all of this downstream undifferentiated heavy lifting that I now have to do. This is the part that I wanna do. The rest of the task is the stuff I don't wanna do. I have to go update documentation. I have to go write unit tests. I have to do a code review or somebody else has to do a code review anyway. And so we've really focused with you on um enabling all of that, making all of those other things as easy as we can and that's the next part that I want to show you. So the next thing I'm gonna do here coming back into the code. I'm gonna go update the documentation. And so I could just start going into the readme file and start making changes, but we've made these really simple experiences. They all start with a forward slash that invokes this agent, and I'm just gonna say forward slash dev. I could create a new read me file. I have one. I'm just gonna say update it. I could also let you figure out what changed. It could look at the project history, but I'm gonna tell it what I want it to do. I'll just say, hey, can you add the remove method that we just created into the docs? And it's going to go now and just like it did before it's on its own scanning through my project and figuring out what it needs to know, looking at the different components, looking at the different files, um. And figuring out what's changed in this project and how it differs from the read me file. Now it's summarizing those changes, it's looked through it all and finally generating the documentation, updating the docs for me. And just like you saw in the previous example, it's going to give me a diff so that I can merge that or review it before I merge it. Um, and of course at any point in this I could ask for changes if I wasn't happy with something, but this looks good, right? It, it's, it's added the delete capability in, um, this is a pretty simplistic change, so of course the documentation updates not terribly profound. And finally I'm just gonna open that in preview. Q did generate this read me file originally, the one that we just edited. I just want to give you a sense of what it looks like. It's pretty thorough. We've got the whole project structure. We've got the installation, configuration instructions, the testing, debugging instructions are all in here, the data flow, how the overall application works, so. This wasn't a huge change. This wasn't a complicated update to the docks. The point is that we're trying to make this really easy. I'm sure everyone has worked with a developer who loves making the changes but never updates the docks, and of course you fast forward a few months and the docs are wildly out of sync with the changes that are being made to the application. We, we all know that person. I think everyone probably can conjure a vision of an individual that never does this well. I know I can. So we're making that as easy as we can. The next thing that I want to do again focusing on code quality. I want to go and update the unit tests and similarly. You have probably watched over time as the code coverage just naturally declines in your projects and what I usually see with developers is they neglect this process over and over again until eventually you fall behind below some threshold that breaks the build in the CICD pipeline, right, usually maybe 80% and if you get good coverage under 80%. That breaks the build. Then we put something in the backlog to go write some unit tests. We derail the whole team for a few days while they bring the code, uh, coverage back up to maybe 90%, and then that process repeats. So just like we did with docs, we're trying to make this really easy. With another one of these agents, so again I'll come in here forward slash to bring up that list. And I'm gonna say test this time. I wanna go and write some tests. And so it's going to do kind of the same process now. It's going to go through and look over the project. It's gonna scan through the files. It found the remove entry method that I asked it to update. And now it's going through and generating tests. It's going to generate 3 of them, so you'll see this in in 33, 66, 100%. And just like before it'll come back with a diff for me to review so that I have an opportunity to look it over before we commit this into the project. There it is. So I'll click on this. And you can see here it went through and edit a few imports into the project and if we scroll down here's a couple of tests that wrote. The first is the success case make sure that it's actually working as it's supposed to, but then it's also wrote some defensive negative cases to say, oh, what happens if the developers, sorry, if the user is not logged in. OK, so all of that's looking good. I'll go and just merge that in. I'm pretty happy with, with the work that it did, right, so. Coming back to the big picture, I like writing code. The first part was the part I want to do. These other steps before I commit are the things I don't want to do, and we're really trying to focus on making you great at and making those really easy for you so that you can do the stuff you want to do. So at this point in the journey, I'm just about ready to go and check in my changes, right? It's time now to go and commit my changes, push them into the, the CICD pipeline. And I know the first thing that's gonna happen when I do that is it's gonna kick off a code review, and one of my peers is gonna go review this thing. Now, I'm new to this team, remember? I don't want to make a fool of myself. I've already seen a few issues in there. I don't wanna add new issues into this. So the last of these agents that I wanna show you in the inner loop. Is the code review capability, which as the name implies is gonna go and do a code review across my project. So before we go and do that, let me talk a little bit about the the different capabilities because really 3 different things are gonna happen as part of this demo. The 1st 2 are security related. The first of these is composition analysis. It's gonna look over my project and all of the OSS dependencies, um, and look for known vulnerabilities in those flag those for me. Uh, this capability we essentially borrowed from Inspector. So if you've gone to a sessions on Inspector, right, we're using their capabilities, their detectors for this. This isn't new, this isn't something new we wrote. This is proven, this has been used in production for years and so this is already pretty mature right out of the gate. The next thing we're gonna do the next security related thing is we're gonna do static analysis. So we're next gonna go through, scan through the code and look for known vulnerabilities in the code, look for for patterns on things like that hard coded password that we've seen a couple of times here. This will pick up lots of things, uh, sequel injection and and a bunch of others. Again, we've borrowed this from in this case Codeguru. So Codeguru's been around for a while, uh, as an AWS service for doing static analysis. They've invested really heavily over the last many years in security detectors and so we're borrowing those detectors again, this is a really mature offering. I'll show you some stats on that in a minute. Those two are security related. The third thing that's gonna happen is we're just going to ask the large language model to play the role of a code reviewer. Say pretend you're my peer and review my code for me, make suggestions about readability. This is nested too deeply. This is going to be hard to maintain all the things that I would normally get from a peer. Before I jump into the demo, there's a link at the bottom here for blog posts, but these are stats from the code review service as it stacks up against other tools and generally we're outperforming a lot of the, the publicly benchmarkable tools those others that that um. Have published data And there's a nice blog post that kind of breaks that down and and shows you some comparisons about how we're performing relative to those. OK, so with that, um, I'm back into that same application and I'm going to come in this time, of course, I'm going to go. And run the review. OK, so I'll come in here and I'll do forward slash again. And I'll run review And I have the option this time do I want to do the current file or the entire workspace? I'm gonna say just scan the entire workspace, even though I didn't touch all those files. I know there's issues in there and I want to go check them out. So it's running those scans? By the way, the the default behavior is that it is always scanning the current file. We're always checking over that current file and providing feedback to you. Um, in this case I've intentionally disabled that so that all the issues roll in at once and we look at them. But the default behavior is that we're always looking at the current file and you opt in to look at it at the project level. So just like in other examples, this is now grabbed my entire application queues deciding what it wants to look at, and after what was that maybe 1520 seconds it comes through and provides a bunch of findings. This is a sample app, so not surprisingly there's a ton of them. There's a lot of issues in here. I'll look at just a couple to give you a sense. The first, this is composition analysis. This particular version of Flask that I'm using has some known vulnerabilities, and so Q has flagged that I can come in and look at details, so we'll come in and and it'll give me a nice description of the issue. Uh, it'll give me links for more reading if I want them. And then it's already in this case generated a fix. So Q can generate a fix. This isn't terribly exciting one, right? We're just gonna bump into the next minor version. Arguably I probably should go to a later version even than this, but uh we, we wanna make the least intrusive fix we can. That was composition analysis. Now this is an example of static analysis where it's come in and in this case found that hard coded password that you probably saw early on. Again, gives me a nice description, pretty self-explanatory here I think we all know this is bad and it's going through and it's, it hasn't finished generating the fix yet, but it's working on generating that fix. It'll come back in a minute and I know from prior examples it's gonna just externalize this as an environment variable so we can inject it at runtime using Secrets Manage parameter store or something like that. OK, so it's done doing it's, it's fix here so you can see right it took that and suggests let's externalize that and we'll inject it at runtime. If I wanted to, I could hit explain which would move this whole thing into chat, and I could talk to Q about like, hey, how would I inject this at runtime? What services are available to me to do that? How would I configure them? In this case I'll just merge it in The rest of these findings here you'll notice are just examples of the large language model playing the role of peer reviewer and making suggestions about readability, maintainability, and other ways to improve my code and so I won't go through all of those, um, but you can see all the ways that generative AI is really helpful here for both security scanning and just general recommendations. So At this point, I've finished my work, right? I'm feeling pretty confident. I'll go through and fix the rest of those issues, make sure that everything's good. I'm ready to go and commit this change. I'm ready to push this. And now we're gonna change to the next phase of the software development life cycle, and I'm also gonna change personas. I'm gonna move from the developer persona and I'm gonna shift now to the DevOps engineer that owns the devsecps tooling that's responsible for the CICD pipeline. And their challenges are a little bit different, right? They Their primary challenges they're probably managing a ton of projects and they don't really know a lot about the details of them, so there's some learning that they can do as part of this, in addition. If the developer's done a good job, they've already run all the security reviews, right? I just did that, but we know they don't always do that. So I also want to use the tools again in the pipeline as an enforcement point to make sure that all those issues are resolved before I continue. So we'll shift into the outer loop here. And I'll show you a couple examples. We first launched this capability in the devsec Ops tooling um when we launched Q 1.5 or 2 years ago, originally in CodeC Catalyst, which is our Devsec Ops tool. We then at reinvent in November a couple of months ago announced this collaboration with Gitlab. So I'll show you that one first, and for Gitlab what I'm gonna do is I wanna make sure that I'm enforcing code quality. So that if a developer forgets to do the thing that they said they were gonna do, that it gets caught here. So back in that flaskar application. And this time I'm looking at it in Gitlab and I'm just gonna go and simulate one of those issues that we had before. So I'll come into the requirements file here. And what I wanna do is, um, I'll open this up and I'll just edit right in, right in Gitlab. You should never do this, of course. Bad form, but I'm just gonna come in here and and hard code that that known bad version of Flask again, put this back in as if the developer had forgotten to fix this before they committed it. And I'll commit that notice into a branch into a feature one branch. So now I've got this in a branch. And I'm gonna create a merge request. If you haven't worked with Gitlab, you probably call this a PR and all other tools. They call it a merge request instead of a pull request. I call this demo, I should fill in a a description, but I'm being lazy. And I'll submit that merge request. So think of this as I'm simulating a developer submitting a change. And now what I'm going to do here is I'm gonna come in here and invoke queue. So I do a forward slash queue and you can see the same agents that we used in the in the IDE testing software development review are all available here. Um, in this case I'm gonna run review. And I'll commit that. So this is just signaling to Q that I wanted to run a code review. You could of course trigger this automatically so that every time a PR is submitted, sorry, a merge request is submitted that this runs automatically. I'm just triggering it manually here and you can see Q says, OK, I'll work on that and I'll run the code review. I'll let you know when I'm done. And this takes about 60 90 seconds for it to do this. It's actually spun up a container in AWS cloned the project, is making the changes there, so it takes a little longer. I fast forwarded, but here's that same description that we saw on the IDE, right? That same detector is running here. And coming through and saying, OK, I found these issues here are some links if you want to read more, um, I don't, so we'll just scroll down a little bit and you can see that Q is now working on making a suggestion for how to fix this so it's run the detector and now it's finished doing the fix and said, OK, here's a fix to address this issue again it's just bumping to the next minor version. This is a simple one. But this looks good, so I'll apply that merge it into my code. OK. So That was an example in Gitlab of running the enforcement of that code review to make sure that developers have done it. The next thing I want to do is we'll shift into GitHub this time. So again, Gitlab was announced that at reinvent back in November, reached GA about 2 months ago, maybe 6 weeks ago that went to GA right around the same time, about a month ago we announced the preview of GitHub. So all those same tools that you saw in Gitlab have been built into GitHub. I could show you the same demo right where I do a code review in GitHub we support that of course, but what I'd rather do here is let's talk about how we can use the software development agent in these tools. And question whether I actually ever needed to check that thing out to make this change in the first place. Do we still need a developer to make a change as trivial as going through and adding delete functionality? That was a really easy change. Could we just do that right in the dev ecops tool? So for the GitHubb example, I'll do exactly that. So again, back in the same application this time we're looking at it in GitHub. This is that same flaskar app. Notice this time though I'm in the very beginning, right? This is the early stages so that I haven't fixed the security issue. I've still got that hard coded password there, um, up at the top of the file. This is the initial state before I made the changes and if we come down, you can see the delete functionality isn't here. We haven't implemented that delete change yet. What I'm gonna do this time is I'm just gonna come into issues and I'm gonna add an issue in the backlog. Could be a bug in this case it's a feature request and I'm gonna say we want to add the ability to remove an entry. And in the description, just like I did before, I'll tell it that I wanted to update the HTML of the SQL and the code. Um, this is still pretty weak. I should have a much longer user story built out here, but it's good enough for the demo. Um, and note here the same agents, right? I've got all the agents that we've talked about are available. I will again manually trigger queue, but I could have this set up to automatically trigger on every commit. I'm sorry, on on every creation of an issue in this case? And now Q has acknowledged that it's working on it and says when I'm done I'll just submit a PR. I'll go work on this entirely on my own autonomously. I'll submit a PR when I'm done. And now it is completed that work. So once again this takes a while. This is not instantaneous, uh, we, we cloned this into an environment in AWS and worked on it. It took about 6 minutes, but it's gone through and submitted this PR for me. We see that nice description at the top just like we saw at the end of all the examples in in the IDE. And we can see here if we scroll down it's actually running the security scan so it did it it will automatically run a security scan even on the code that it writes and if we come and look at the PR, you can see all the changes. So you see the SQL change that's the code written. Here's the change to the HTML. These should look really familiar. They're just the same things that we did in the IDE. It's even written the unit test. I didn't ask it to do that. I could have asked it to do the documentation and the and the unit tests, um, but it threw the unit test in there for me. So Really quickly here, we have now. Done all of this autonomously. There's still a human in the loop. I need to review the PR, but I've taken a lot of the load for these simple tasks off of the developer, so it's not their responsibility anymore. Imagine what you could do with your backlog of all the small issues and things that are being reported, the insignificant feature requests that users are requesting if you could just start handing these off to generative AI right in the devSec Ops tool and do a lot of them in parallel potentially. So, before I turn this back over to Daniel. I just want to talk for a moment about sort of the, the art of what's really possible here. So we publish a lot of benchmarks for Q developer about how it's performing. And we're generally right at the top or very near the top, depending on how long ago we ran one of these for both SWE bench and SWT bench. So SWT is a benchmark for writing unit tests. SWE bench is a benchmark for resolving issues. In this case, we are solving about 66% of real world issues reported against real world, um, open source Python projects that are available in GitHub. Yeah, these are well written. But generally these numbers suggest that assuming you have well written issues in your backlog you could start to hand off 2/3 of the noise to Q and let it do that so your developers are focusing on the really important stuff and you're starting to just offload a lot of this junk to um to Gen AI to take care of for you and with that. I will turn this back over to Daniel to pick it up from here. Thank you, Brian. Cool, so we really saw how Q can help us at the beginning, planning, designing, threat modeling, then we saw how we can use Q in order to accelerate development, run security, uh, next to our developers so we can integrate it with our pipelines to make sure we have governance across different applications and projects. Now we have our application deployed. In the next section we're gonna discuss about like how we're going to run SEOs with Amazon Q and this scenario is a bit complicated, complex, like, uh, intentionally. We have like a security engineer that needs to run a complicated security investigation. In our scenario it's going to be Kubernetti's environment, Amazon EKS. So, uh, how we can really use Q, how we can really streamline and how Q can help our incident responder or set opps engineer to run such such operation. So the demo will start with the guard duty alert. Guard duty is our threat detection service, um, a manage service, you can enable it with a couple of clicks, and you will get alerts when something bad happens in your environment. So we can see here that we've got a suspicious activity about a crypto miner. Right Um, I can read it. I can try like as a security engineer, try to understand like how to start the investigation, uh, how to now connect to my Kubernetis cluster and maybe work with the playbook in order to, uh, try to remediate it, gather the forensics, uh, triage, etc. But I'm going to ask you, So I will start by like just like copying some details from the from the finding of course we can automate that, but this process for the demo is is manual. So I'm gonna just to copy the finding ID and the fact this is a crypto mining uh security event. And I'm going to jump into the into the queue in the CLI now in my environment here I started Q with uh permissions to my environment and I also trust you to run actions against my environment without my approval. Don't do it in a production environment. This is just a demo just just for this demonstration. I also like have my playbooks prettydefined, so I have like playbooks with different security incidents and instructions based on my organization on how to handle a security event when the crypto mining comes up. Again, it might be different in your org or based on a different project, based on sensitivity, etc. And I'm going to just ask you, hey, I have this crypto mining event. This is the finding ID, this is the guard duty detector ID. This is the region. I have some playbooks here. Help me to run the relevant commands in order to start with this investigation. So here we start again like by fetching the playbook so I have the playbooks there try to understand which playbook is relevant for for this specific scenario. And we read and fetch the instructions from there. So this, this might take a couple of moments. Afterwards, Q going to start with the investigation. Now a lot of things are gonna happen now. We'll try like to follow up with what happens on the screen, but you will start to understand like what is the vulnerable pod that was the source for this alert. Start to understand the environment which other pods I have in the name space, how many name spaces I have there. We identify the binary that was used to get the crypto mining, get logs from the specific pod and understand exactly which operations made there. Uh, try to understand how this how this like malicious pot even created from the beginning. So you go to the service account and he found that a service account is attached to another pod which is a legitimate application that probably is vulnerable and our external user external unauthorized user goes from there. So there are a lot of like different phases of the investigations that you just doing automatically for me. He also configured the CUCTL, the Kubernetis environment, and just ran actions against both my AWS environment and my Kubernetis environment. And really got a better picture of what happened. Like, after a couple of minutes, Q has like a better picture you understand like hey we have this uh vulnerable app that somehow like was exposed to the internet and probably was the root cause. This app created the the crypto miner pod, so we know what happened. We know there is a service account that was used. Next steps will be containment, right? So Q will follow with the with the relevant playbook that can be used for for the containment operation. And as again reading like the the relevant playbooks again fetching the information and it will start like with stopping the bleeding. We would like to uh to run different commands. So the first one would be can I so Q is checking if you really can use the service account to create uh pods, and the answer is yes. So we would like to revoke the permissions of the service account again, don't do it in production you might break your application, uh, but this is what the playbook says, and this is, uh, this is the, the solution for this, uh, for this demo. Uh, so after you really identify the, the relevant service account, he revokes the uh the, the permissions there. He will also like make sure that the service account cannot be used anymore in order to run any crypto mining or create any ports in my environment. And you will also like continue with the containment steps that I have there so some of them would be like to delete the crypto miner, so we would like to delete it and making sure we're not like keeping uh increasing costs on the workload by by running those uh crypto miners. Um, here would also like collect relevant logs information from from the from the relevant pods. I will also want network isolation so you can see now that I created a network policy. They just like isolate incoming and outgoing outgoing connectivity into the affected uh pods to make sure that we don't have any connectivity externally. And we are applying them only to the affected ports that you identified in the beginning. So we're not like of course applying them to all of the pods, only to the specific uh affected ports with labeling that we created using Q. Alright, so we really like created, we really like QSQ to to start the investigation. We understood what happened. We run the containment, we stopped the bleeding, we stopped the crypto mining operations. The next step would be like to generate a report, right? We want to share with our management what exactly happened and which steps has been taken. So you created for me here already like um the timeline and and uh what what are the IOCs that were relevant to this event and what was the affected resources um the the the specific details that I can eventually maybe take and like run across my environment to try to identify any similar activity that maybe I have in other environments. And, and the next step Q will also generate for me like an executive summary which will include the again like this information and others for example like which steps you took exactly and which uh which remediation plan it has which maybe long term plan I have that I have to implement in my environment and what was the suspected root cause. So we can see like a lot of information and data uh that has been generated by Q uh again all has been done by uh by Marg on files, playbooks, and automated integration into into the into the AWS environment and also the Kubernetti environment. So I really hope this was useful and you can think about uh ideas about how really Q can help you to streamline SEO's operations. So After the the security event we handle that application is keep running there, uh, but we might have like a new zero day we might have a new security requirements to upgrade the code. Uh, the security team comes to development team. Hey, this Java version is outdated. You need to upgrade it. Uh, it's not that easy. We have like multiple dependencies. The code is huge, uh, we need to start like understand what's gonna be the impact, uh, so we can do it manually or we can use Q, uh, for that kind of operation. So in this in this in this scenario we have our developer that has legacy code and really learn how to use uh Amazon Q developer in order to upgrade and mitigate the risk and answer the security team that that bothering him with this specific outdated application. So in this case we have a Java app as you can see like it's a Java on version 8 and I'm going to use the, the transform transform capability with Amazon Q within the ID. I'm gonna ask him, hey, I want to upgrade version 8 to version 21. So Q will start and analyze my uh will ask me first how how I want it, if I want to create unit test in this case I don't, but it will start and uh analyze my project directory. And this can take a couple of minutes. And then like a couple of minutes later we can see the queue like starting like to create like a transform plan for me so basically again scanning the code repository trying to understand what needs to be upgraded and generating uh a detailed markdown plan with what I need to do so I can see like uh the what I need to be factor exactly which files need to be changed, which which files need to be duplicated, which dependencies need to be upgraded and to which versions. So it really gives me like a detailed um transform plan. That I can use and implement in order to make this upgrade challenging operation in a more efficient way. Um, and then also like get the dips and again this is like uh. This might take a couple of minutes as well, but in the end he will generate for me the new up to date code code repository, um, my new code base, sorry, uh, that will include uh the upgraded code, and I can also dive deep and see exactly which changes have been made, what's the, what's the deal for each uh each file in my project. I can say that in this case I successfully really upgraded uh Java version 8 into 21, uh, very easily. Right, so we saw really that transform capability, this is just an example. There are a lot of like uh different uh solutions and operations you can use the transform and it supports, uh, other, other, uh, programming languages besides Java as well. We have a customer quote. Uh, we have Deloitte that implemented Amazon Q developer in the environment and they saw 40% increase in development speed, 70% increase in, uh, in, in testing, uh, decrease in testing, and really like, uh, better code quality. So if you want, you should give Amazon Q developer a try and maybe you can try to, uh, uh, to run some of the examples that we showed you today, uh, on your environment. Just to summarize what we discussed, we started from the plan and design, and we really saw how you can help you to align your security requirements early on in the software development life cycle, integrating with your wiki pages, wanting threat analysis, helping your developers and your and your security teams to work better together. Then we saw like how really like you can work alongside of your development teams and help them to develop faster and more secure with the ongoing security scans on on uh on the IDE with the code suggestions with a review option that can scan that can runs a security scan across the whole uh the whole project, uh, this is really powerful. Then then we experiment like how Q can be integrated with your pipeline right inside of your pipeline so we can use the GitA Gitlab and include Que there again automated reviews, run maybe automated code generation and and walk backwards from like PFRs or or any security requirements that you have inside of the pipeline. And then we saw like how you can also help security experts, security engineers to just run operations. The example was around instruent response, but it can be like just like running just reviewing the environment or running CLI commands. It can really help you to be more productive for your operations in the environment. In the end we saw like how Q can really help you to make transformation and how you can use Q really to take a vulnerable dupliccated code and in an automated way created a plan and transforming the code with the relevant changes. I hope this session was valuable for you. I will ask you to spend one minute on filling out the survey, and we're gonna be around here if you have any questions. Thank you so much. Thank you.
