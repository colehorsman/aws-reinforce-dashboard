# AWS re:Inforce 2025 - The right way to secure AI agents with code examples (IAM441)

**Video Link:** [Watch on YouTube](https://www.youtube.com/watch?v=PZpiVV3U-m0)

## Video Information
- **Author:** AWS Events
- **Duration:** 47.8 minutes
- **Word Count:** 7,783 words
- **Publish Date:** 20250618
- **Video ID:** PZpiVV3U-m0

## Summary
The presentation focuses on securing AI agents in AWS environments, particularly through the Model Context Protocol (MCP) framework. The speakers, Jeff Lombardo and Fei, discuss the evolution of AI applications from proof-of-concept chatbots to more sophisticated AI agents that can access and utilize various data sources securely.
The presentation emphasizes the importance of implementing zero-trust security principles when building AI applications, highlighting how authentication and authorization should be handled between users, agents, and data sources. They demonstrate this using AWS Cognito for authentication, Bedrock for LLM interactions, and MCP for secure tool integration.

## Key Points
- AI applications have evolved from basic chatbots to sophisticated agents requiring secure access to multiple data sources
- Zero-trust security principles are essential when implementing AI agents in enterprise environments
- Authentication and authorization should be implemented at multiple levels with increasingly narrow scope
- MCP (Model Context Protocol) provides a standardized way to create and secure AI tools
- Integration between OAuth2/OpenID Connect frameworks and AI tools is crucial for enterprise security
- AWS Cognito can be used as the primary authentication mechanism for AI agent applications
- Fine-grained access control should be implemented for each data source and tool

## Technical Details
- AWS Services:
  - Amazon Cognito for authentication
  - Amazon Bedrock for LLM integration
  - AWS CLI with MCP server configuration support
- Implementation Components:
  - JSON Web Tokens (JWT) for authentication
  - OAuth2 framework for authorization
  - Hono library for HTTP server implementation
  - Model Context Protocol (MCP) for AI tool integration
  - Vector databases for storing normalized data
  - Weather tool and travel agency tool as example implementations
- Security Features:
  - Token exchange mechanisms for scope reduction
  - OpenID Connect integration
  - Fine-grained access control at multiple levels
  - Zero-trust architecture implementation

## Full Transcript

So my name is Jeff Lombardo. I'm a security and identity specialist at AWS and today I will talk with my peer over here. Hello, everyone. This is Fei. I'm principal engineer in Amazon for close to 10 years. So I'm the lead engineer of Amazon Carnito on the service team. And happy to be here. Thank you. So today we will talk about a topic which is on to a lot of lips of our customers, which is the right way to secure AI agents and uh thanks to something that we have really we say we will have some code examples in order to show you how you can bootstrap that and you can try to to sort it so I hope you will be interested in that. So first of all, we just want to make like a little bit of a retrospective about what GI is of today because we cover a lot of ground over the last 3 years. We went from just the era of POC where customers were just like starting to create some small example of chatbots and maybe a little bit of rag there and there, OK, to the to the era of prediction. So the ability to start to look forward to find the needle into the haystack and to try to provide more value, more insight to your own end user and your own customer and in order with this added value to expect to go faster on to the innovation and and push forward. But now the customer wants to bring even more value, and we will see how data will be like a very big and important state into into the way that we are moving forward. GEI has been created and is fueled by data, and that's where those GEI agents will play a big role. The idea behind that is to be able to pioneer our new ideas and our new services that you will offer to your own customers. So here we have just put a little bit of schematics about what is a GEI application today. What we found is that we have users, we have authorization servers because those users needs to authenticate in order to be able to operate with our application. OK, and once they are authenticated, they will try to provide an input to our agent, which is the part within the gene application that will have to deal with those prompts and generally what those agents are doing first is that they try to enrich the prompt. With some information that has been pre-normalized into a language that the LLMs are talking which are like vectors, so your data sets has been put into vector database and the agent will grab more information from there. The next thing is that this unreached prompt will be provided to the LLM for the LLM to be able to provide an answer and potentially to also perform some actions through some custom logic against some external services like a communication platform, whatever it is like, or a team or an email system. But what we found with and then for sure to return the answer to the user. But what we found is that there is a lot of untapped data. OK. You have business data, you have employee data, you have consumers' data, local data in some use cases, and what your LLM wants is to be able to use that without necessarily requiring you to normalize all this information which is which is generated. In real time and at a large scale, so that's why we saw the appearance of what we call AI tooling, and those AI toolings are here to create the interface for your LLM to be able to consume from those untapped data stores and to be able to provide again added value outcome and answer to your different users. And the thing that we have is that we see now within enterprise is that we have a need for zero trust into all of that because we have like many users that are talking to many agents that are talking to many data sources and we want to be sure to provide the proper authentication and authorization in between all those paths of the communication. And what we also want to do into that is that while we are progressing from the user to the data to be able to narrow down and reduce the scope of action to be fine grained at each level and to enforce the right mechanisms. So today that's what we will talk about through our talk. We will talk about Jason Webb token uh coming from the 02 framework. We talk about the ability to exchange um those tokens for like more sco token, OK, in order to demonstrate how we can effectively expose those data and use those data with an LL. For that, we will use like something that you might have heard recently, which is the model context protocol, also known as MCP, which is the new technical specification for builders to be able to create those AI tools. So this specific specification is building again on Open ID connect and 02, which are exactly what we will demonstrate today and we will show you the value of this specific framework. If you want to do that after this talk. What we have built today is already available. We will use this specific solution of guidance for MCP server on AWS and we will use the QCLI, which is now supporting MCP server configuration. So you will see all of that in the code talk of today. So let me give a little bit of rundown about what we talked to you about. So we will use Cognito for the authentication part. We will also see how the tools are registering themselves to the agent. Again, the agent and the application in our case will be QCLI. We will see how the user can provide an input. How this input can be sent to bedrock in order to be resolved, our bedrock will make usage of the tool, and the two tools that we will use today are a weather tool and a travel agency tool, and those tools will allow us to enforce the right amount of access control, OK, potentially access requiring a new set of tokens that are more narrowly scoped. And then we will see how we can access to the back end services uh in order to be able to deliver the value to the customer. OK? Sounds like a plan. So, yeah, and do it on the restaurant. So Fay, thanks. Thank you, Jeff. Um, when Jeff was talking about MCP, I saw a few of you are, were nodding your head. How many of you are familiar with MCP or heard about this? Uh, almost everyone. And then, uh, OAS, have you heard about the OAS with MCP as well? OK, that's good. So our team, our team has been working very closely with MCP on the OR spec, and we can talk about that maybe after the meeting and things like that. But to, I think one of the main goal of this, this talk is to help you understand how we would write code to secure your application, user application, MCP client, MCP server, all the process behind. So that's um. That's what this code talk will go through and then we'll have, I will divide it into three phases for to show you. The first iteration or maybe the first phase of the code, um, here we focus on the weather too. So it's the same diagram as what Jeff showed you before. Um, the, we focus on Alex, for example, signing in with the Carnito here. Carnito is an identity provider and whatever you see here, it's applicable to other identity provider as well. So if you want to use others, fine too. Alex was sign into Carnito, get a, get an access token, and Q is the agent here. And then Q will talk to Bedrock. Again, Brock is a LLM model which you can also substitute with something else that if you want, and then use that token to access the weather tool. So it's a very simple flow. The weather tool here is a public service, which means OLs and that's not required, but at least that's the first phase I want to show you, and then we'll get get into more more sophisticated one. Uh, for the code to work, there's a couple of libraries that you will need to set up. Hono is a library where you can use it to to host, um, HTP server, proxy, and it's a, it's a convenient to, to validate OR's token as well. And then you have the handle, um, you have uh sub libraries from the Hono here. So for the MCP to work, this, this, this is the code that if you want to run an MCP server, obviously, um, you need some kind of server in front of the weather too, right? We talked about the four parties, just keep that in mind as we go through the go through the demo. It's very important. You have a user, you have an application. Application is also the agent in this case. You have the MCB you have the MCB server that's a proxy to the resource and then the weather too. So 4 parties because authentication, propagation, all the things they differ across these 4. So this is showing you what would the MCP server do. It will be handling a post request when someone sends a request to MCP. And then inside this post request, um, This talks about the protocol part where it will instantiate transport object from stream of HTTP server, connect to it, and then get a message. So it's more of a boiler uh boilerplate code where you get the incoming message was sent from the agent to your MCP server. You'll be writing that and then the handling will then route to the different tools. Excuse me. And then, um. The MCP server is protected by OAS. This is something that I'm not sure if you noticed that in the, in the, uh, in the latest draft of the MCP spec we talked about OR separating that as as authoring server separate from the MCP. So MCP think about as a resource server where you are taking request to access a resource. And then the token is someone who present that to the MCB server, you know to access that. So here's a code to validate the incoming token before the MCB server said, OK, I allow you to access the weather service. So it's, it's sitting in the middle. One of the, so, um, one of the, the OS token is getting from, from Carnito to the weather to, and this diagram shows how the token is getting, getting retrieved obtained. Couple of steps. QS agent first request it wants to talk to We two. So Wether two will tell you, hey, you need a you need a token, you need to access a token, and then that will route the user is using browser to the Carnito as a as identity provider. User will see the page, please sign in or please register, and then once Alice um signs in, and then the the Carnito will will grant a token, will grant the access code to the weather tool. Uh, and then eventually you will also get an access token from there. We send access token to the weather tool, and then the weather tool will send the token further back to the authorization server. So here we talked about and whether tool is a resource here, and we need an authorization server to protect it, which sit somewhere else. So the purpose of doing 6 and 7 is such that because the carnito token comes in as access token, but it's a different authorizing server from the weather tool's own. So that means the weather to will send this token to its own authorizing server to do the validation and then sign it and then give it back. It looks, it looks probably a little bit redundant from, from the slides, but the important thing here is is that so that it can, the, um, the weather tool itself can trust the tokens that are bided by its own authorizing server, right? Because just because it's server, just because it's asset token does not mean that you can take any access token from the world in order to use it. So you want it to be validated by your own authorized server. OK, and then this is the code that shows how the, how the tools function, how the MCP server tool you would do. It's, it's pretty simple in the sense that you take an input as a two-letter state code and then build a request to your backend resource server. In this case, is the weather, whether to service which is a public. Uh, the, the method here beside this tool method, there's a declaration about annotation. Yeah, so I probably should talk about that annotation, get weather alerts for state. These are information that teaches the LRN model about what tools is available in order for the LA model to give you instruction or give the agent instruction to to to move forward. The next method shows you, that's a, that's a request where you just uh construct a regular request and send it to the construct the URL and send it to the, to the weather uh weather forecast uh service and get a response back. Right. So that's the first part of this uh code talk. I will hand over to, to Jeff to show you the code. OK, so the solutions that we are that we are using, like I said earlier, it's a solution that already exists, which is like the AWS guidance for MCP server on AWS. So for this first step, we will just use that and try to go a little bit more into the detail over here. So the first thing that we know is that if we are looking into the configuration of. Our QCLI QCLI since recently now supports the definition of MCP server definition. OK, so here you can see that I have deployed my MCP server as a lambda function. It is exposed to a cloud front endpoint. OK, and I can make aware of my QCLI of it because I'm configuring this specific MCP.g file, OK. So, so now it means that if I'm doing some Q chat over here, OK, I will just bring that back up. Come on, ready. Over here, let's go back to terminal. So if I'm going over here, I can say for example, book me. Plane ticket to Boston if there is no weather. Alert. OK, we just saw code explanation that we have like the MCP server is capable of giving weather alerts, but we want to do like a full trip. So let's see what happened with that. So QCLA is thinking about the next step, uh, to do is say I cannot book a flight. OK, so I will say that's that's not a function of the MCP server. Can you give. Me the alert weather. Report for Boston and let's see what goes with that because that's a function that. The That's all. OK, let's try again. Beauty of demo code. Uh That's the beauty of doing life demos. Yeah. There's a warning. Oh. Oh, thank you. OK, so it seems that there is an error into into my MCPG file. Thank you for the for the person that follows on to that. Uh, line 11, where is that? Uh, 1917 by bye. OK, let me try to do that. They phone here. Yeah, thank you for that so I should have. If I do that. Thank you. Now it works. So you see, it's starting to, uh, try to evaluate and that's what I was looking for. So now he's sending Mac to Connito and he says, if you want to talk to the weather channel, to the weather MCP server, you should be authenticated. So I will authenticate and he will say, OK, I, I have authenticated you so you can return to the CLI and now if I I didn't make your resume, so give me the weather report for Boston. OK, so you remember he need, he needs either a state or he needs some longitude latitude, uh latitude for information, which is exactly what he got from um for for Boston. And if I say yes, then my LLM, this is just we are just using bedrock over here. So Bedrock has no live information. That's really the MCP server answering. with those information and if we were in Boston, that should be the weather um on top of you. So from what you saw, we have made an authentication through Cognito and we are capable of talking to the MCP server because we have an access token and the LLM can benefit from the information of the MCP server to be able to return the value to the. There's some animation to skip that. OK, so that was the first, that was the first step you saw that the MCB server was authenticating authorizing access. The weather service itself does not need specific ones. It's more of a you your MCP server in the middle is authenticating authorizing the user because when you build some service like that or agent or MCB, you don't want everyone to hitting your end point in the world, right? You, you want to control that to a to a good degree. So that was the first demo. The second one is about. The travel agency, so now let's talk about travel agency. Travel agency is another service out there, uh, and that one, the first method is to list all the travel options. And this, so for this method, it does need uh an OAS protection. And, and you can see that it's a standard open API and then there's a scope that's relevant here. It says MCP slash server slash read. So the name is probably not, not the best. You can imagine that should be called maybe travel agency. List all, something like that, but that serves the purpose. So there's API out there and now you want to add some code to your MCP server in order to interface this while still authenticating user. So the way it works is that um the travel agency API is a it's a stub it's a stop, it's a marked API and what it would do, which is I think this is um this is probably normal or what you would expect, is that it will validate the incoming access token, JDB token that issued by Carnido or by some other IDPs. Especially you look at is the client ID client ID is the MCP server because remember this token is for the MCP server to access the travel agency. It's the second hub, so it's from user to application, application to MCP server, MCP server to the resource. So this the client ID is the. Is the MCP server and then the scope is MPs server.slare, which is equivalent to the travel agency lists. And then the, the sequence here is very similar to the previous one, except that We have another error from 3 to 4, which also uh get not only gets weather alert but also to the travel agency to get all the all the travel options. So it still goes through Alice signing to Carnito. Use a token to access Amazon Q as an agent. Q gets instruction from Bera on what to do. Bera will tell it to get alerts and, and also uh list the travel options from the agency tool. So here are the functions. Here's the what's underlying the hood of the MCP server for the travel agency. Yeah, and then you have a list of, you have a, uh, you have a description of what this tool does about list options. And depending on the, depending on the original destination, it will give you the options here. So this is the method of how it handles incoming requests on list travel options. And what we are doing here is that we will send this specific request to the back end services and as you can see over here, we will do a post and we will use the access token that was provided to the MCP server and we will pass it as a better authorization token to the back end. Yeah, which is something that you didn't see on the first part because first part we did not need to pass the authorization access token to the weather service because it doesn't, doesn't care about that. But this one it cares. So here you see the authorizing header is to passing the access token for for MCP server to access the travel agency, which is the probably you know somewhere in the middle of the of the screen. All right, I'll pass back to you a demo. So we, we already, uh, we have already deployed, uh, the travel agencies that, uh, along the the API specification that uh talked about. So what we will just do over here now that we have corrected the typo in into our um MCP dodges on file is that we will edit it, OK, at the end of that. We just had a comma we just paste. So what we will do is that we will configure this additional um MCP server uh configuration over here and what we do as you see it's uh another uh lambda function OK uh it's deployed beyond another uh cloud front uh distribution. So now if I just register that and go out. So what? inside OK. I'm glad we have people following today. I think we should invite you up here. Yeah, thank you. We are recruiting, by the way. Um, OK, so that should be fine now if it does not work is this gentleman, uh, issue, it's not mine, OK, so now if I do Q and I resume from where I was because um QCLI is capable of um of doing that so you see that my my new servers popped up for an authentication, but because I had a radio session at Cognito. Nothing happened. Everything was done into the into the back end, OK, so now. I have my 2 servers. So you say, you see, we discussed about the weather in Boston. So you keep memory about what I said. So now if I said, OK, if the weather is OK in Hawaii. Um, yeah, I can do some type of, uh, book. Me ticket. From Montreal, which I, I'm based at if you didn't get it yet, uh to there from June 23rd to July. That OK? So let's try to see what happened with that. OK, so first he, he, he understood that he had to check the weather in, in, in uh Hawaii, so he took shortly, uh, Honolulu. He will go over there. We see what happened. So it's looking at the flight condition you see already generated the request for the right date uh departing, arriving, coming back from the right city. So yes, let's go with that. And that's the 2 MCP server, the one that is using the access token and passing the access token to the back end, and you see a return to me, uh, like a certain number of 5 or 3, option in order to be able to go there. This is all fake data. Don't look at those prices. That's not what you will get, OK? Did the book. Did you book it? No, because you don't know how to do it. So, how can we do that? I don't know. Let's get the 3rd to to to get that. OK, so the, so that's the third step is about now we need an action. That's more for right action, right? We saw the, we saw the one without permission, without explicit permission, we saw the one with a list. You do need a permission, however, that's uh more of a read only. The last one is about, let's, let's be, let's ask the travel agency to be able to book a ticket. Uh, and that's the, that's the last number 6 on the diagram where. Uh, Amazon Q task the weather to task the travel agency, uh, to getting the listing, getting the options and then do the booking on number 6. And here is the definition of the API slashbook. The scope is different. There's a scope MCP server slashbook, which probably you will, you'll notice on how we, how we want to use it. The important thing about the 3rd 1, this one is that. The top part about read is the same is how you, how you, uh, how the, uh, um, travel agency listing API is going to validate the request by looking at what is a valid JW token by by Carnito, whether the client ID is the MCP server itself or MCP server who send in the request and the scope has MCP server slash read which we which I talked about it's more of a listing. The second part is where it's different. It needs to do a couple of things. You need to ensure the scope is MCP that server book, right? That's a different action where user wants to take and agent wants to take and And I think there's something that, that, that we will, maybe that's more of a quiz, and you will see whether, whether this is a complete or not. So there's, there's some of these, uh, some of these uh scope that needed, but you can see there's a difference between the book and the list where the authorized server and the and the resource server takes. OK, so from the function's point of view, that's the, that's how you would write the MCP server uh to, to take requests to do some booking. And here the, I think the method that's interesting is to make travel agency book request. The bodies looks mostly the same, passing the parameter from from the inputs of the MCP server back to the back end resource server. And, and then the code here is similar to the previous one, where you have the current OS 2 token from from what from what MCP server obtained from the car needle and then sending in the header, uh, forward the request to to do the booking. All right. Yeah So, so you didn't saw it into the background but I just like it's infrastructure code so I changed the code of our travel agency MCP server uh to to do that. So the things that we will do is that we just quit uh QCLI and we will just. Redeploy through CDK um uh our stack because the solutions that uh we are using again uh in the in the back end over here is the is the solution from the AWS guidance on on MCP server we have just added some elements on to that so it detected that the travel agency code for the lambda function changed because now we have another function onto it. Uh, which is the, the book function and is, uh, currently making the change, uh, to those, uh, different resources, so, um, because we want it to be protected on the cloud front there is uh some war rolling on to that that's what you, you have seen a little bit earlier and then it should, uh, change the lambda function right away. Really happy hour as far as And then we will be able to go back to the QCLI and the QCLI again should have like memory of the previous conversation that we have so I should not have to uh require to ask for those options uh again. I have a question. How many of you are using the lambda function is deploying. And the whole API was already over there. We did not deploy the the API we are just like onto this MCP stack. How exactly OK, so it's deployed, so let's go back uh to our Q chat. We don't need any more uh to um uh change the MCP the GN configuration. We already uh we already um uh have authenticated through Cognito, so he knows where we are. So now I can say book option book option two, and because he knows what I have asked as a travel option. Um, for Montreal to Honolulu, he will try to do it, so let's try. No There there is a, I think, I think there is an issue of uh there is a, that's, I think it didn't work, so can you explain us why can someone help us to say what I was asking someone to help us to oh, can someone help us? Why did it not walk over here? Yes. Yes, we had a scope but not the right scope. We were using the red scope and we need a book scope like this API documentation tell us right. That's one. There's another, there's another reason which I will show as well. So that was the first, the first reason is that it was missing the scope. It was just sending the sending the initial token as this, which is uh not right. so The second reason is that it's missing the user. And so when you, when, when we send the token over there. The token itself represents MCP server talking to the resource server. That's a machine to machine authentication. You got, you got a 20 2 light flow OS token with a machine identity. And when you, when you need to call an API on the back end that has machine and user, don't lose one of them. You need both of them. In fact, there's something that I'll probably talk at the end of the, at the end of the the slides about the importance or or the things that 8 of us are thinking is is very important for people to build their applications. So it's missing that act as claim, which is a user. And, and also the scope was wrong. So this is the part that shows it's more of a um handling the error that if you are writing a resource server on the on your side and then you see that request coming in, there's missing, there's a missing scope on, for example, book, then you will, you will throw a header about uh triplew authenticate, and here's, here's the bear is missing some scope. That's more of a code of what you would write to return some response. All right, so this is one of the key, this is probably one of the key steps of what you could do to fix that. The token that you had was a machine to machine token proving who the MCP server is to the travel agency, but it's missing the user information. So what you can do is that you, you can do an authentication with when you do an authentication uh as MCP server to get its own authentication token, M2M or machine to machine to, it will run the token exchange or similar token exchange where It first gets its own client secret, who it who it is, and then set the body. Um So set the uh the initial user token of representing who Alice who Alice is, that is a token that you send into AWS_cli metadata. So this is a feature where maybe some of you are familiar with the, the Carnito lambda pretoken generation where you have the control of at the time of the machine token generation, you are, you have the control of injecting your own information data to that so that the token will come out with claims that you want. So this is what this function does. By doing authentication and sending AWS client metadata of the current user, the user who initially sign in. Once you run this request, then you will have a token of what you want. So the part that that I was just mention about is is a new feature that that Carnido released probably 1 or 2 months ago, where there is a pre-tokken generation where you can, you can, uh, you can tag your own code to customize the output token. This also now works from machine to machine generation. So it is a good match for, for this type of application where you have an agent and you also want to have a user, it's to combined information into one. And the earlier time we had an impersonation that was probably last year or last 2 years ago using a custom moth. There's a difference in the concept between delegation and impersonation. Maybe there's more of a terminology. I wanna, I wanna talk about a little bit. Impersonation, uh, means you are, you are sending your user's credential as is to some services. And when that service sees this credential, for example, um, when this service, maybe the travel agency, see the credential that let's say I send Jeff's credential to the travel agency. The survey will not know if it's Jeff himself doing it or IMS's agent doing it. So that's impersonation. Impersonation is applicable in many cases, but it's also very risky in some sense because you're missing who the agent is. Delegation is what we show here that the actor who's doing this request, we talked about the machine to machine authentication getting the OS token to represent MCP server is still the agent, but the agent will have an additional claim to talk about Alice, that's in the in the token itself. So that's a delegation. In the agent world, in the agenda world, please, please look at the delegation and that's the, that's the, that's the approach you should um prefer, yeah, as opposed to impersonation. OK, so then this is the part that makes the, takes the request. Once you have that token back, and then you, then you use the token to make the booking with the travel agency. I'll show you the token content on the next slide, which probably this, um, that's after after the OK, after this, let's see the demo. OK, so like last time in the background I just updated my uh lambda function code. OK, so what we will do is that we will just uh deploy this new uh this new stack, you know, uh, you know the drill about that, you know it takes a little bit of of time. So in the meantime while he's doing that, uh, what I will do is that. I will talk a little bit about what Fay just said, how we can enrich uh token, OK, so inside uh Amazon Cognito you have the ability to have some extension Lambda trigger in this case, uh, the pre-tokken generation Lambda trigger which can allow you to enrich access token and identity token. It was only for user. A flow now you can have it for machine to machine flow, OK, and as you can see for the moment our lambda function does pretty much nothing OK the tokens that came in is the token that that goes out. So what we want to do is to be able to uh to upgrade this specific function, uh, to be able to do what we want in our case. So, uh, let me just. So I'll just upload my new zip file over here. We will deploy it and we will pass it very quickly together. OK, so what happened is that when When we are when we are when this function is called out, we will use a token GWT Jason Web token verifier for a certain user pool, a certain type of token, and a specific type of client ID. And if the verification is OK, we will tap into the payload and we should add a specific. Claim inside the new access token which is an ACTAS, and these actors should bear the subject and the issuer of the initial token that was sent as part of the token exchange element. OK. The scope is part of the token exchange request, OK, so it should follow up into that. We will see that later on. So let's go back to our deployment. OK, the deployment is done, so. Let's go back into our resume. So now if everything is OK, uh, our MCP servers that do the booking should be able to understand if the back end IPI is sending a 401 with an indication that the scope is missing to just do a token exchange in within the MCP server and retry the request with the new set of token. So now if I say book option. I don't know why I just one I just change of uh of options so you will again think about memory about what we were discussing earlier if I do yes. OK. Now he's trying to do it he's talking great just just bought our flight. We are ready to go to Honolulu. OK. So Fay, can you drive us through that? Yes, of course. to do that. and thresholds That was just the animation of what you just 5 hours. So the flight was pretty, pretty fast from Montreal to Honolulu. Oh yeah, yeah, yeah, yeah, I should be more than 5 innovation, OK. All right. Um, so, so this was the, this is the what the token looks like after the lambda function where You have the client ID and the subject, those two represents the agent, agent, identity of the agent or the MCP survey in this case. Because they're living together in our example. And then the, the act as is where the user information is and act that issuer issue is this carnito, can need the issue that The subject which represent the user identity and that part is, is uh added to this token and signed. So, so the important thing here is that. Because the, because, because the client in this case, MCP server has authenticated itself. And because the MCP server is presenting a valid user token from a source that you trust, you ask probably you are the application developer, you are the ME who develops it. Once they have these two pieces of information, then you validate and you sign them, put them in a token. That's the one that you issued to the um to the travel agency booking service. So when travel booking service sees this token, it has both information, you can, you can, you can log, you can observe, you can reject, you can scope down. We're not showing some detail over there, but obviously if you see this, is this user maybe coming from this or this department or this this user, this kind of attributes. Is this agent who developed this agent and all this metadata, you can think about that, those can all be part of this information where your travel booking, the API can use this information to scroll down or control access. That's a pre-tokken generation lambda that Jeff showed you where this is doing something that's that's pretty simple. It's more of a look violating a token and then looking at that information from the client metadata that's passed in and then uh and then generate a token and adding those new claims. OK, so, so I wanna summarize a little bit before passing back to Jeff. A couple of things that are, that are important. One is this, um, so we were talking to customers, uh, this morning we have some customers meet up and and discuss. First of all, there's, there's a lot of uh myths about what is MCP server. And what's the security about that? I think the way that I would describe is that if you're building a back end service and access to your resources, would you open a back end service to the world as this without protecting? No, you won't, right, because you still want to authorize that. So I will look at MCP server as authorized as a back end service that you want to protect. And the second way that I would look at that is that because when when there's an agent, whether that's a QCLI or someone rights agent, want to talk to your MCP server in order to to tell the back end resource, assume it's rogue. Do not trust that the agent pass you some parameter as this. That's also the second part that's important. So here the example we're showing is that, why do we spend all the effort of getting uh an OA tokenja token from Carnito to the pre-token generation, sign it and then send to the authorization server to MCP? The reason is that because it will reduce the middle person from tempering it. Because your agent, if you don't trust the agent code or the MCB server somewhere in the middle, you don't want it, you don't want to trust that, it will tell you whatever user ID you want to retrieve. So that's the reason why we have all these things come together. And then the third is that there's always, there's a two, in most of the cases when the agent is acting on behalf of someone, there's two identities in the plate. There's a, there's an agent identity itself or machine identity and there's a user. So make sure you track all of them and then forward them to the resource server. And most important thing is that resource serve is the what matters. So in our discussion with customers, constant thing about how do I make the agents, um. Uh, sophisticated or how do I control that all the things like that. You don't start from the agent, you start from the resource server, you start from the assets that you want to protect your company, and that's asset needs to be able to to look at the request that if I, if you don't show me a request, showing who you are, who you're acting on behalf of the user, and then showing the proof that they are the ones that they someone issued them must be IDP or someone, a third person that's authority that can issue that. If you don't have this information, you as a resource server should reject the request. Simple as that. That's not the same as a lot of microservice architecture we can I can talk a lot as well, where you have multiple services talking to each other, they have a trusted bound, one A to B because it's coming from A. Do not trust just because it's coming from A. So I think this is a, this is about what we are covering. We, we come from the alteration flow from all the way to the user talking to agent and then talking to the the MCB server in the middle and then all the resource the step by step of propagating user identity, authorizing scoping down, and then at the end we also run a token exchange you all to meet them together to present to the to the travel agency booking service. Yeah, I'll pass by to Jeff. So if you want, if you want to to be able to build the same thing, uh, again what we use is already public. The only part, the only part which is not is the travel agency card, but we might push that through a pull request uh on onto the report. So go to the AWS guidance for MCP server on AWS. You will find the GitHub report that will bring you to the cloud formation template and all the code that goes with that. If you want, so you can build your own MCP servers, but if you want also to use MCP servers that have been built by the community, you will also find the second link which is on this site on this slide sorry about the list of MCP servers which is still growing that solution architects are doing uh for you to be able to interact with any AWS services that we have. Also I want to highlight the fact that a few weeks ago we released our open source AI agent SDK. So if you want to build something that look like feel like and as the force of the QCNI you can already. Do that by yourself through this open source SDK we have like made it super easy for you to build your own GEI application, your own agent that support the MCP protocol and can provide far more value uh to your own customers. Finally, I just want to bring you like one slide of all the magnificent session that we have on to this topic. Here you are on to the code talk, but we also have some builder session and some workshop if you want to have some hands on onto those technology and even go even deeper into the authorization logic because MCP servers are like intelligent API gateway. They need orchestration logic and they also need access control logic. So please, if you want to go deeper, follow those sessions. On Wednesday, Fei and I will have like a lightning talk um onto the same topic we will cover a little. A bit more ground on the standards that are governing and if you didn't get enough today you can still join us for a repeat tomorrow on the same topic or send us your friend so that we can also demonstrate to them what we have done. With this being said, thank you for attending today, and now we will open up for any questions that you have. Thank you. Thanks.
