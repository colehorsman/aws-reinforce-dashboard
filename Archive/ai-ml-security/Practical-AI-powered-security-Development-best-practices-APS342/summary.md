# AWS re:Inforce 2025 - Practical AI-powered security: Development best practices (APS342)

**Video Link:** [Watch on YouTube](https://www.youtube.com/watch?v=6SBBg1vIM8A)

## Video Information
- **Author:** AWS Events
- **Duration:** 53.0 minutes
- **Word Count:** 10,671 words
- **Publish Date:** 20250619

## Summary
This session from AWS re:Inforce 2025 features Michael Webb and Milos Markovich (from FINRA) presenting on practical AI-powered security development using Amazon Q Developer, with a focus on the /review agent functionality. The presentation is structured as a playful "mission" format, demonstrating real-world application security scenarios.

The session addresses the technical challenge of shifting security left in the development process, using Amazon Q Developer's AI capabilities powered by Amazon Bedrock. The speakers highlight FINRA's successful implementation across 15 application teams, with plans to expand to 1000 developers by the end of 2025, demonstrating the enterprise-scale potential of the tool.

The presentation centers around a practical demonstration using a Python Flask-based "Book Vault" application, focusing on identifying and fixing security vulnerabilities. The speakers specifically highlight the /review agent's capabilities in performing both workspace-wide and file-specific security scans, incorporating both SAST (Static Application Security Testing) and SCA (Software Composition Analysis) functionalities.

## Key Points
- Amazon Q Developer is an AI-powered assistant integrated into IDEs for secure software development
- The tool features multiple agents including dev, test, doc, transform, and review capabilities
- /review agent provides both workspace-wide and file-specific security scanning options
- The tool supports "shift-left" security by enabling developers to identify vulnerabilities early
- FINRA's successful implementation across 15 teams and 70 developers shows enterprise viability
- The tool is powered by Amazon Bedrock for foundational model capabilities
- Scanning time varies based on project size, with asynchronous operation capability
- Security findings are categorized by severity (critical, high, medium, low, informational)
- Vulnerabilities are mapped to CWE (Common Weakness Enumeration) numbers for security issues
- Integration is available across multiple IDEs including Visual Studio Code, Eclipse, and IntelliJ

## Technical Details
- Built on Amazon Bedrock foundational model service
- Supports multiple IDEs: Visual Studio Code, Eclipse, IntelliJ
- Implements both SAST and SCA scanning capabilities
- Demo application stack: Python Flask framework with Pi JWT library
- Security scan results are grouped into 5 severity categories
- Asynchronous scanning capability for better developer workflow
- CWE mapping for security-specific vulnerabilities
- Integration through IDE extensions
- Supports both full workspace and single file scanning modes
- Requirements.txt dependency scanning capability

## Full Transcript

Welcome fellow agents to code name Project APS 342. We hope you're in the right room. We're very excited today to spend time with you to focus on application security and specifically how it can be practical, but even the more further, we're gonna go on an impossible impossible mission today. I'm Agent Webb, and I'm joined by Ethan Hunt. I mean, wait, who are you? Hello everyone. My name is Milos. I'm the application security engineer from FINRA. I'm really looking forward for today's session where we can see how we can leverage AWSQ slash review agent to find and identify, mitigate security vulnerabilities in our code based directly inside the ID. Different agency I see not with MI6 again. So today we're gonna be covering three specific vulnerabilities and different mission agendas that we're gonna be covering. Now within this mission, we're gonna first give you an overview of Amazon Q Developer and to get it started, who here has used Amazon Q Developer before? We have a few people in the room, OK. If you're a security analyst, uh, would you raise your hand just so we can get a sense of who's in the room? All right, maybe a developer. OK, so a few developers or maybe more leadership. Alright, so a little bit mix of both. Well, today's session is gonna talk about how we can use Amazon Q developer to really help us solve these mission objectives that we have. And at the very end of this session we're then gonna focus on how can we actually take this to the field and what is gonna be useful for us. So today we're gonna spend some real time going through actual code examples today that you'll see so that you can understand how we can solve these missions. So Amazon Q developer is our generative AI artificial powered assistant that helps you uh throughout your software development life cycle to be able to do things like get code suggestions as well as generating that new code and work on your code basis. Now one of the things that we're doing is within the IDE and as you work with Amazon Q developer, we're really trying to shift left the idea of how can we get the security process to developers sooner. So rather than focusing on, hey, I am, you know, passing all my code over to a security engineer, how can I get that ahead of the game so that I can focus on my code and ensuring that it's secure now Amazon Q is powered by Amazon Bedrock, which is our foundational model service that allows you to run models through an API. And so what we're gonna be doing today is focusing on how Amazon Q developer can solve these strategies and specifically some agents within the Amazon Q developer that you can rely on. Now Milos, can you tell us a little bit about, you know, your experience that Finner's had with Amazon Q Developer? Absolutely. uh, thank you, Michael. Uh, being a long term AWS partner, uh, after initial rollout of the Amazon Q developer, we're very interested in testing it, which we did throughout pilot or a project, uh, POC project that we did across the 15 application teams, around 70 developers were involved throughout testing through the fall of 2023 and the summer of 2024. We were very satisfied with the initial results, and that's why we expect by the end of this year 2025 to have around 1000 developers, engineers actively using Amazon Q developer, uh, with daily work and just asks. Awesome. So Agent Markovich, that sounds like you've been in the field a while. So really today I think what we're gonna cover is these missions and how we can resolve these specific objectives with Q Developer. Let's introduce you to the team that we have today to help assist us. So as many of you aren't aware of within Q Developer you have these different agents that. Oh well, we might have had a few agents. Um, seems like some of them have gone missing or rogue, so we have a few agents that existed or that still do exist within the IDE. Those are the dev test, doc, and transform agents, and these do different functionalities. So you have your dev agent that for example, writes code for you that new code, or if you want to build unit tests, you can use something like slash test. Um, as well as slash doc to generate documentation as you can see there, but today we're gonna be focusing on the slash review agent and specifically what this slash review agent can do for you as you're going throughout your development life cycle. So Amazon Q developer agent can review your code base. It has very unique functionality. It has SAS scanning. It has SCA uh software composition analysis, uh, capabilities in it so that as you're going through and writing your code you can actually. Generate and ask you to generate a kind of review of your code in your workspace and you're gonna see today as we go through this actual demo and going through this code talk how we're gonna apply those specific principles throughout the examples that we have today. These missions are gonna be challenging. Now we're not gonna be able to solve all of the OAS top 10 today, but with today we wanna get you started on a journey as new recruits to be able to understand how you can utilize Q developer in your workflows so that as you're going through and as you're writing code, you can also have another agent there beside you, such as the slash review agent. Now with the last review agent we wanna ensure that we're detecting the potential security vulnerabilities and so rather than just having generative AI that is being able to look at your code we're also using automated reasoning capabilities to be able to ensure that it goes against some of the testing strategies that we have of and that we've trained these models upon within Amazon. Now with that being said, Agent Markovich, would you be willing to lead us through the IDE and kind of what that looks like? Sure, absolutely, agent map, if you can just unlock the laptop. Security first, of course. So here we, we, for today's presentation demo we will be using the Visual Studio code as an IDE, but any ID supported by the Amazon Q extension will work just fine, such as the eclipse or Inteligy.D prior of the presentation, installed Amazon Q extension, which we can see in the bottom left corner. So if I just click on the Amazon queue, that's going to bring additional menu panel. From here, we want to go to open the chat panel, which brings the chat panel here. We already run review scan before, so I'm going to close this uh findings very quickly and start from the very beginning. So this is a chat panel. Now we can start utilizing Amazon Q. By crafting our prompts and inputs, by asking you questions about a code base or just general questions that we have, but as AWS services or a code in general, as Michael was saying, we also have different agents at our disposal. We can start using different agents by typing the backslash, which gives us a few options here that we see. For example, slasht, test, doc, transform, and the focus of our presentation today is going to be the slash review. We can see here the slashy view next to it there is a small description saying to identify and fix code issues before committing. That's very important because it's all about the shift left mindset where we want to get these 4 abilities when developers starts building a new projects and new features at that point because we want to release additional burden on security teams having to fix the identify and then security portabilities and additionally work with developer on mitigating those, which can also be additional work on the depth team as well. So here, if I just click on the slash review. This gives me two options. We have the first option to review the workspace and the second option to review the active file. If I decide to go with the first option, review the workspace, that's going to kick up the security scan of my entire project that I have loaded up inside the IDE. Every file folder or director is going to be scanned for security informabilities. Now completion time here ultimately depends on the project size and it's also going to increase proportionally with your project size as well. So if you have, for example, small projects like we have today. It's going to be pretty pretty quickly to the medium project size. Otherwise, with the huge projects without slice of the code, it may take some time. The other option to it is review active file. Review Active file is going to kick off security scam for the active file that we have in focus inside IDE. So for example, you can see here we're doing a Python application today. So if I have Python file open here, it's going to only look for vulnerabilities in a specific file, which can be handy. For example, if you use the review workspace already, you have a bunch of findings. You're already aware of these findings. But let's say in the meantime you build a new feature, new functionalities, you want to scan specifically that file, you can also do so, which is going to also decrease the time that you have to wait for security probabilities. That would really be helpful if you had a large project. Absolutely, and it sounds like we have a project that we're gonna be working on today. So Agent Markovich, would you lead us through what this project is and what it does? Sure, absolutely. So what we have here before kicking off the security scan is our small book full of application. We think it's very important to give the overview of the application what we're dealing with today for our secret mission to mitigate these 3 vulnerabilities critical, the highest before we start. So I'm going to start with the codebase, uh, from the file explorer directly inside the ID and I'm going to hand off to agent web to give us a demo, uh, from the end user perspective directly into the browser. So here we see, as I mentioned, this is a Python Flask application. We see it's pretty straightforward and simple. We have the app.i as the main functionalities and logic in our code as a back end. We have requirements at TXT where we define two libraries that we have specifically Flask and Pi GWT with their respective versions. Flask is this is a Python framework, and then Pi GWT for handling the JWET operations within our application. Additionally, we have a schema SQL which is going to be initiated when we start the application to create some demo users and some demo data. And finally, we have a template folder with some HTML static files that are going to be used for rendering the data coming from the back end. Uh, before handing off to the agent web, I'm going to start the review of workspace security scan. So while he is giving us an overview of the application, the security scan will be running in the background. So how it works, we can go ahead and choose the other option for today's demo. I'm going to stick with the review of the workspace. And as soon as I click it, we see 3 different stages initiating the code review, reviewing your code, and processing review results. And then we can see the workspace review is in progress. And now while this is happening behind the scenes, Eve, can you please give us an introduction of the application itself? Definitely. One of the things I really like about the slash or slash review agent is that it works asynchronously. So while I am focusing on other tasks or being able to complete other items in my workload, I can actually let this agent asynchronously go out and do its own thing. So let's go into the, oh look at that, it's already completed. That's OK. We're gonna give you an overview of the application. So the first thing I'm gonna do is I'm gonna open up a new terminal window to start our application. Now as we can see here, we've already activated our virtual environment so we'll go ahead and open up our app.py and we'll go ahead and start this application. Let's go ahead and jump into this application that's running locally. Ladies and gentlemen, welcome to the book vault. The book vault is a place that you can secretly store all of your books. By being able to log in, for example, with other agents such as agent Angela who works with us, we can log into the book vault. And we can view the books that Angela has access to. Now again, Angela gave me her password, not a best security practice, but as we go through, we can see that these books are stored and we're able to then see what she's going to add to her library. Additional functionality may be needed, or we may be implementing things like creating new, uh, authentication methods. So as we come in here we can add a new book. So let's say for example I wrote a new book called Friendle which is a favorite of one of my children right now. Hopefully they don't get compromised by me writing that out but I can go ahead and add that book. So now I have a book in this web application and as you can see we can see this list of books, uh, that's now been added to Angela's specific profile. Again I can log out and if I needed to, I could also register and create a new account so very simple application. But today's mission, Agent Markovich is for us to solve the specific vulnerabilities that we're dealing with and seeing how Amazon Q developer can help us. So let's go over mission number one. So, ladies and gentlemen, we're gonna start with mission number one. The first thing that we're gonna be resolving is SQL injection. As we know, SQL injection is a common thing in the industry, and that sometimes is overlooked but it's a very specific and common attack that exploiters or attackers try to exploit. So that they can get into our databases or do different things and so today we're gonna be seeing how their SQL injection that's actually encrypted into our book vault to be able to secure that so that we don't run into that same problem. Agent Markovich, do you wanna go ahead and lead us into that and show us how you that's being done in the field today? Absolutely. thank you, Agent F. So let's go ahead back to the IDE, but before I do a deep dive into the SQL injection specific finding, let's also take a look at what we have as a result of our security scan. So we have our terminal where the application is running, and then we can go ahead and check the scan results. We see that we have a 7 total findings among the criticals the highs, and then we also see the 4 among the mediums and lows. When we start a security scan with slash review agent, the findings are going to be populated across different 5 groups with the most critical one, of course, being placed in critical tab, and we can see the most informational ones being put in the informational category or group. So now once we have a vulnerabilities here, it's also really important to mention that not every finding coming from the slash review scan is going to be directly related about the security. It can also be about the code performance issues. If the vulnerability is strictly related to security, it's going to have a CWE and specific number as a prefix, where the CWE stands for the common weakness numeration, where we can use it as a reference to the finding. On the other hand, when it comes to the core performance issues, uh, they're going to be very descriptive when it comes to naming conventional findings. So for example, if I expand the medium tab and make this a little bigger, we can see here that for example, in the medium tab we have the name of the of the code performance issues because you see there is no CWE. It says avoid direct imports of the complete library to change the performance clarity and instability of our code. So we can see from here we already got the idea of what the performance issue is, so we can go ahead and navigate to it and start working on it. Regardless of the finding, it's very important to tackle both security vulnerabilities and findings, uh, related to performance itself, but that's enough talking about that. Let's jump to the SQL injection. But I really do like that slash review agent isn't just focused on security and performance as well, because as we know, performances they can get into, for example, our database. Run queries that are gonna, you know, exploit the performance of our database is another way of attacking. So really this agent comes double packed with not just reviewing security findings but also performance as well. Yes, that's absolutely true. That's why it's very important that we take a look at both of the directly security findings and the performance issues, but for our first mission that Michael was saying is the SCL injection. So here we can see the SQL injection. If we only hover over the vulnerability, we're going to see the small window pop up for the, as you can see here on the screen for the description of vulnerability, but we can most certainly make this bigger by clicking on view details. View details is going to bring additional panel, so I'm going to put this one more down and expand it here, or we can just simply click it here. So now we have the name of the vulnerability, the CW preference, and then the description of the vulnerability itself along with the impact. We can also see that suggested codefix preview is already working on providing the remediation code, but we're going to talk about that just in a second because when we see the details of the mobility, the Amazon QV agent already provides remediation for a finding. So in addition to that, we have the detector library. If you're interested in how Amazon Q defines these findings and how it goes over to Insecure coding patterns, you can also feel free to go ahead depending on the language that you're using. You might have to choose Python or Java or other languages that are supported at this point. So let's go ahead and see what we're dealing with here. So we have the SQL injection vbility, and we see there is a potential SQL injection risk detecting our database operation. But to make it more interactive, let's go ahead and open again Amazon Que. Open chat panel and see the finding itself. So if I just click on the finding, that's going to redirect me to the vulnerable line of the code. In this case, this is 129. So following the description here, we see there is insecure coding practices here in terms of how we build the SQL query. Specifically, what we have here is a string concatenation related to the Python F string where we concatenate the username to the or the existing query. Which you finds out and says this is insecure practice, insecure database operation. We should be using pre prepared statements or parameter queries whenever we are executing SQL queries to make sure that we, we are avoiding the risk of the SQL injection. So here as a malicious user we won't understand where is the username coming from. Can I control the username in such a way to pass a special characters used for a SQLI specific payload so we can actually exploit this more ability? So here before jumping to the remediation, let's go ahead and analyze the code and see what's actually happening. If you remember from Michael's demo when he logged into the application, there is HTPG get request being sent to the dashboard endpoint which we can see. Online 120. After that, we can see developers had already have in mind some access control issues that might arise here. So they are limiting you to see favorite books only tied to your username. But the problem here is how they do it. We can see here string concatenation and then we can see finally 129 lines, which is underlined in the yellow, that it's flagged for SQL injection because indeed we are conting the username. So as a malicious actor, as a hacker, we want to make sure that we understand where the username is coming from. So let's slide a little bit more up and see how it works. If you take a look at the register endpoint, once we send the post request to it, we are in control of the username as a post request parameter right here. If you take a look at the code more closely, we see the comments from developers. Input validation for potentially malicious usernames. But if you wait a second. If I'm looking at this code, right? I'm looking at rejects expressions that they've defined here. But are you leading me to believe that they actually didn't do the full thing in validation that they're not actually parameterizing this? That's correct, agent. It's very weak. We can see full sanitization here. We can see just looking for certain special characters as well as the script in this or projects, which indicates to me this is just looking for the, uh, cross the scripting vriabilities or maybe template injection vulnerabilities that we have here. At this point I'm fairly certain I can see that we have SQL injection vability in our application, and that's a big deal right now because SQL injection itself, it's not going to allow you to only dump the content of a database. You're not being tied to a certain table like we have here, for example, books, you can go ahead and migrate to other tables such as the usernames and passwords. But it can also go more beyond that really depending on the database engine that you have, it can also allow you to read the local files, to write the local files, and most certainly it's under ultimate conditions depending on permissions of the user running the database. It can also allow you to retrieve the remote code execution leading to complete server takeover. So I'm really worried here because we have a simple application. The very first mission is already, uh, very unsecure here and it's a hard, hard challenge for us, for us. But before diving into the remediation itself, let's go ahead and take a look at how the malicious actor can actually exploit this. So now we get to the application itself, you remember, we are controlling the username. And uh we have to register malicious account first with a malicious username. So if I create a username, something along the lines like this, so what does it mean? And with the sample password, anything will work. What this means is that with a single quote, we are escaping the current query what we saw in a second. Then we have the additional operator or the or operator, and there's something that's always universally true, like one is equal 1. This means that this way I can fetch all the books, not only related to myself from the database, and I'm finally using the minus to comment out the rest of the query to avoid any syntax issues or any or any additional SQL query that maybe come after my input. So here I'm going to create this account. We can see here because of the flow remediation, everything went through that there is not a problem with it. And then we can log in with this account, but bear in mind this is a 2nd order SQL injection. It's a more straightforward one because once we register an account, you see nothing happens. But once when the username comes to play when we log into the application, the SQL injection is going to be exploited. So if I click log in here, we can see 4 books, not only the book because this is a fresh from the O account, we shouldn't see any, but we see the Harry Potter, The Lord of the Rings, Great Gatsby, and with each of that added as Angela user. So this is a problem, but at the first glance, it might seem innocent because we are just only able to dump the books from a database. But if you remember, we are not tied to a certain table or even a database, and depending on the permissions of the user running the database, we can leverage this and weaponize it even further to change with other vulnerabilities. So agent web, should you choose to accept to fix us this vulnerability at Amazon Qlash review? I got this. Let me show you how it's done. So the first thing we're gonna do is we're gonna jump back into the IDE. Now I could spend my time. You know, going out on the web looking for the fix to this, but understanding and working with Amazon Q slash review agent, I can come in and look at the suggested code fix preview. Now knowing that, oh this looks like secure code, I could quickly accept the fix, but we should go a little bit above that. So if you scroll down even a little bit more, we actually can understand why this fix is being recommended so being able to see the actual implementation of the fix and what's being done here will really help us understand what we're trying to accomplish. So as you can see here the specific. Code is trying to use a placeholder to be able to parameterize the actual username that is being inputted into the SQL so that we don't get SQL injection like we previously had. So you know what? I'm gonna show you how to fix that really quick. You wanna see. Boom, we're it's already done. Wow, amazing. First, go ahead and complete it. Check it out really quickly. So we can see now 129 we are using the placeholder where the username was previously concatenated with Python F string. This way the user input is properly stored, it's treated as a raw text, it's being executed safely. So we, I would say we saw the first mission we're done with. Can you give us an overview of the second one? Yeah, let's go to mission number 2. Alright, mission #2. Oh no, something's happening. It's not working correctly. Ah, there we go. We have two issues. Uh, there's gonna be a problem. We didn't talk about that other one package vulnerabilities. Let's, let's figure this out. So first thing we're gonna have the proper authentication. So that what we're gonna be showing is how there's JWT tokens that are in our app. that aren't properly being verified we're gonna cover that as our first mission we'll see that in today's example, but then we're also gonna be talking about this package vulnerability, right? The ability for Q developers slash review agent to also look at package vulnerabilities across kind of the industry. So let's go ahead and jump into the IDE and let's solve this one. Absolutely. So for this mission we have two more abilities, the one we didn't expect, uh, so we have no time to waste. Let's go ahead and see what we have. I'm going to pull up again the results of our security scan by clicking Amazon Q and navigate into the chat panel. Um, as Michael was saying, we have the. Two more abilities. The first one is the package vability, so I'm going to expand a little bit more. This time the vulnerabilities you can see here is coming from the requirements of the XT, unlike the previous one which was from our main application logic and functionalities. So if I click on the vulnerability, it's going to redirect me to the vulnerable line of a code, but here we have two findings actually. We see that there are 2 yellow underlinings for both flask and the PIGWT. The problem with that is that we have the two package mo abilities here actually instead of one, but the package moreability for a flask is a low risk one while the package vulnerability for PiGWT with this version is a high one. So we want to take the priority over the high one or high one with over over the low one. So what's it A, have you ever heard of a critical package? Not really. Yeah, I get a lot of them. They come from Amazon, so I continue on. So here we can go ahead and click on view details to to get more insights about the vulnerability itself. So here we can see the Py is a Python implementation for handling various actors when it comes to JWT tokens. The problem here that we have is a high risk vulnerability coming from a specific version of the package. Um, the problem here is that this version of the Pi JWT is going to accept the non algorithm, which is going to be, can be the JWT can be signed with it. So once when you go ahead and obtain a valid JWT token it's a malicious actor, you can simply change the properties from the JWT body, sign it because JWT is a stateless authentication mechanism. Everything about the user is within the body of the JWT token within the payload. So what we have here is You get the value of the valid token, forge it, change the values in the body or payload, and then sign it with no algorithm. Shoot it to the application. A won't be checking the signature in that case, and this can allow you to bypass the authentication or to escalate your privileges because using the JAC focus in our applications really depends on the properties. Usually they are used for authentication or checking the access control. But the problem here is that even if we fix this forability right away, we are not fixing the bigger picture here because there is not only a problem with what version of the package we are using. There is also a problem in the logic of our vability or with how we are actually approaching JWT tokens. So if we take a look at the fixed code preview, we have the updating the major version here from 1.7.1 to the 2.4.0, which is the latest, the most up to-date version when it comes to PIGWT. And now we are mitigating this vulnerability, but we're coming to fix later. The problem here is that what Michael was saying, or the agent web, that we have additional vulnerability, and that's improper authentication, which is coming from the app.ie, specifically line 34. So what's happening here? We can see here the SQL fixed preview is once again run alphabetically, but let's go ahead while it's doing that job. We can go ahead and read the description of the finding itself. So we have the the R code. The codes JSO web token, short for GW one for GWT. Without checking the signature, this can this can be a huge security concern because you can go, nothing is stopping you as a malicious actor user when you have a token to simply forge these properties and then do as you wish. So here we can see that this is coming from the admin panel. We can see the comments from developers saying that we're currently testing the JWT implementation as they want to switch to it maybe from the flask session. It's completely fine. The problem here is coming from the line 34 where we decode the GWT token without verifying the signature. So what does that mean? The thing is, if I get the token from this application, I can do whatever we want and then pass the application. The application just wants to check it at all, it's going to accept it as long as it's a valid format. In order to access the admin panel, as you can see on line 36, we're extracting the role from the payload. And checking if it's an admin. If it's an admin, the user is granted access to the admin panel. Otherwise, the user is denied access. And the admin panels are very lucrative targets for the attackers because admin panel is going to allow you to access sorts of functionalities that are not available to regular user. It's also going to allow you to visit the data from the other users itself, such as resetting the password, visiting residential address, or something along those lines. So this is a serious security concern here. It's not only going to allow us to bypass the check, but also to escalate the privileges. So before going to the remediation portion, let's go ahead and actually jump to see how we can actually exploit this vulnerability. For this one, we don't even have to go to the browser. We can do everything from the terminal using the roll command. So if you remember before I do a deep dive in exploitation, we need to have a token. So how do we get one? Let's go ahead and check it out. When you send the post request to token endpoint, we just need to provide the username in the post request body, and then the username is being used as a user property when it comes to producing the GB token or generating the token for us. The problem here is that we can see developers were thinking of possible access control issues here with the admin panel, so they're generating the tokens with the role hardcoded to the user. So, do you think that's actually really going to solve our problem here? I don't think so either, because we are not checking the signature. Nothing is stopping me to change the role from user to admin once when I have a token. And we can see here the token is not properly protected either, so anyone can just get it. So without further ado, let's actually see how we can do that. So first we have to send the. The HDP post request. With the curl command to our application running on the local host on a port 5000 specifically in this case. And then we need to shoot the token end point. In the post request body by using the D flag, we can provide the username John, for example. Once I send the request, we can see the application generates a GW3 token for me, which is a basic B 64 encoded string. I can take it. And for ease of demonstration and our understanding, we can leverage the visual website to visualize this very nicely. So for that, I'm going to go to the JWT debugger and paste this token value. So here's what we can see. When you see the user is a did draw will be specified in the post request body, and then we can see the role as a user, which means that we correctly understand the application flow. So if I just take the token value as this and try to send the get request to the admin panel once again leveraging the curl command, I'm going to get access denied because my role is indeed not in admin. I have to provide the um GWT token as an authorization header. Type of barrier token? I'm going to paste it and send the request, but access denied. You're not an administrator. That's completely fine. But if you remember, the root cause of our vulnerability is being able to access the admin panel without ever verifying the, the, the signature of a token. So here I can go ahead, agent Markovich. I think I understand what you're saying. So you're saying that if I can just change this token or get access to this token, put it into this application here or this web interface. I could just quickly come in here, update this to admin, copy this new token, and then basically post it back into our application to be able to get the information that I need. Absolutely it's that simple. You saw just a second ago that HMM was changing the properties of a token. The token is being updated on the file in the real time. So the token values or the properties of the body are changed from the user to the admin. So if there is a proper verification of a signature, this will be denied, but otherwise because there is not, as we're going to see just in a second while AM Webb is typing the command, we'll see that we're going to get access granted. The problem here is that even if we are leveraging the secret. Or if you're urging the secret or to sign the token, we are not properly verifying that secret in the signature. As a result, we were able to access the admin panels we can see in the response this time. So the problem here is that the signature is not being verified, which is also what you said here. So if we take a look. What's actually happening here when it comes to remediation itself is that we are importing the OS as an additional module as well as the JWT. We're importing specifically decode to also improve our application functionalities and performance, and then we're also importing proper exceptions here if the or there is invalid token error. So now this time we see a comment where we are using the secure key, secret key to specify the algorithm. It's very important to understand that Q is also going to give us the best security practices here, not only about decoding using the secret or signature, but it's also going to say you should go ahead and define specific algorithms here that you expect, for example, HS 256, because there is, there is a lot of attacks around GWT focus, for example, related to the algorithms, like for example, algorithm confusion that you can leverage. So here you can see here now that when we Use an equal function. So Ari Markovich, if I'm gonna understand this correctly, then this is very similar to, let's say for example someone with a mask that walks into an organization and goes to the security guard. The security guard knows this individual but rather than asking them for identification, they say, Oh, you're good to bypass because it looks close enough. It's kind of what we're running into this JWT token issue. We're just being able to bypass by going through that security guard and saying, uh, I know this guy. Bob, let's let him in. Absolutely he's got a mask on. As long as you have a valid format of a token, you can go through because the application doesn't check the integrity and that's exactly what the queue is saying here. You can leverage it for access control, as that's what we see here for escalating our privileges for a regular basic user to be able to become an admin user. So here what we can see just to continue with your. very quickly is that with the decode function now we are storing the key value and pulling it up from the environment securely from the environment variable called GWT secret key. So now when we provide the token, the signature is properly being verified, which means that if once when the application generates a token for me, if I do not know about the GW secret key, the value of it. I even if I change the properties, which I absolutely can't, I won't be able to pass through because there is a signature mismatch, and this is very important to keep the integrity of the GWT to in one place. Additionally, it's very important to properly secure GWT secret key, making it unique, uh, making it store a secure place, for example, like the environment, because when you generate the GWT token. Uh, what, what can happen if you're using the weak secret key. It can also be extracted in brute force using the brute forcing tool, uh, to get it, for example, like a hash kit. Uh, so what we have here, we're going to specify the algorithm properly. We're going to specify the GW secret key as I verify the signature process, and we're going to hit accept fix. This is going to change our code on the fly, and now we mitigated even the second vulnerability. But remember, second mission has two vulnerabilities. So I still have to go to requirements at TXT. And then to mitigate also the package vulnerability, um, but the package vability when it comes to remediation is pretty straightforward. What we have to do is to update the major version here from the, if I can just find it, package vability view details, and then what I have to do is to accept the fix. It's also going to update to the most recent version, which is a 2.4.0. And HF we, can you help us with the third and final mission? Yeah, definitely. So it sounds like we've solved 2 things today or 3 in fact, but we still have a few more. Let's get to mission #3. Now, this one's pretty straightforward and it, you know, we see this a lot but hardcoded credentials as they come through and they're getting detected and. You know, this mission, it's been real. It's been really good, but I, I think, uh, these agents are really helping us. I mean, as we're going through, it's not only excuse me, me helping you, but I think this water's been poisoned. Agent Markovich, yeah, it's poisoning, he said we just lost Agent Webb. Thankfully we have another agent slash review agent. So what's the deal here? What's actually happening? Let me go ahead and switch to our code back. So the final last but not the least mission that we have is going to be about the hard coded credentials. We see if we expand the code issue step just a little bit. We can see the hard coded credentials are now coming from the uh critical tab or critical group here. Um, hard coded credentials always a hot topic. It's always if you open the cyber news or just IT news in general, you'll see. A different incidents, different approach about the companies finding hardcore credentials doesn't have to be directly on the client side that we have on the server side like we see here on the app, uh, that line 11. It can be also happening still to these days, even being able to store those on the client side in a source code in the source with dev tools you can expect the HTML and see those, uh, there. It's still relevant to these days, unfortunately. So being a hot topic here, um, this is a very nice use case when it comes to slash reviews and being able to spot these hard coded credentials because in the end of the day it's very handy to use hard coded credentials when you are local testing or you're testing lower environments. The problem is when you have a huge code base with enterprise applications, if you start, if you keep going hard coding credentials in different classes, different functionalities, you might forget to to remove and to properly secure those ones when you're ready to commit changes and to push production. So the problem here is that this is where the leaks are happening. You might be working with the open source project or just storing your project data or project code on the publicly available version and control systems like GitHub. malicious actors are constantly browsing it. There is an automated tool constantly looking for secrets, and then they can be leveraged and exploited. Usually the consequence and the impact is huge, being able to. Um, leverage unauthorized access. It doesn't have to be strictly like the API key hard coded like here. It can be credentials for databases, for servers, for admin users. It can be API keys as we can see here, and all sorts of secrets. It can lead, for example, to malicious act or just abusing your API keys and resulting in the financial loss, or it can be resulting in much more worse cases in areas like data breaches and complete compromises. So if we take a look here, if I pull up the code issues panel, we can go ahead and pull the view details panel. And then take a look at what the queue has to say about this one. So there is a potential hard coded credentials being detected. There is a code may contain sensitive data such as the passwords or API in our case. Hard coded credits. Um, are the problem because they can be extracted and misused linked to the unauthorized access or system breaches. So even if you publish the reports or if you, if you commit the the code with the hard coded credentials, there is additional burden on everyone on developers and security teams. First rotating these credentials, then the credentials are going to stay in the committee history if you just simply remove them but do not rotate them. That's another issue. Uh, if, if your repositor has different branches, that's another, another problem. So you can see here that there is additional very close. For everyone, and that's why we want to make sure that we are not hard coding credentials like this, specifically when we are pushing the code to the production finally. So here, the problem is that when you're a malicious actor and you find the hard coded credentials like this one, first you have to understand where they're being used. In this case it's an API key, so we have to find out the endpoint which accepts the API key, which is used for the authorization of the user. And the second thing that we have to do is to have some sort of luck, right, because maybe this is a Not use code anymore. It's not relevant. It's just there. It was used for testing local environment removed by developer developer simply removes for forgets to remove it or just be used in local environments, but we are not in the prod. So let's go ahead and understand our code to see how this is actually being used. If we take a look at the API key, we have to understand where it's being, where it comes to play essentially. So here we can see there is a private API route, and then we can see that API key is being pulled off from the HTP header. X API key and then if it's a mismatch between the XAPI key value header and then again with our API key constant, well sorry, this is, uh, you're getting the access denied invalid API key and the 401 status code. Otherwise you'll be actually able to access the endpoint with a 200. Now that we understand here, this was a pretty straightforward in terms of the understanding the portability and how we can approach it. So here we can go ahead and try try to exploit ourselves. So if I clear the terminal. I start everything from the beginning. I have to send the crew request or the HTP get request to our application once again. And then we are interesting in accessing the private API. Then if you remember, we have to specify this XAPI key and terminal remembers here we have the value for our API key. So API key, if you take a look at it just one more time before we perceive exploitation, is that it seem unique, it seem random, but actually it's not. That's additional, additional talking point. So here we see only 1234 QWER and then secret API key and secret API key is just in fact the name of the header. So it's not impossible for someone to to completely get it, so we may want to make sure that besides storing this properly, they're also unique enough because we can store those properly in the environment with secret managers all day long if they are simply guessable, it can be also find a common brute forcingriist. So it's very important to to go and imple security that, especially when it comes to these very sensitive credentials. So here if I leverage thisro request and I simply send the get request to our private APIN point, we can see the confirmation message. We reached the private APM point, and this is a confirmation that this is a still valid code. This is a still valid API key, and this is a problem because API keys can be exposed or any kinds of. Hard code credentials can be actually exposed for a long time before a team realizing it. This way, as we as we want to make sure that this, we understood everything correctly, if I simply just slightly change the API key, we can see now we are getting the invalid API key, which confirms this is a true positive, which confirms that I can access the private API and point this time. And then this is a problem because just in the name of the path route. We have the private API. The private API indicates maybe just accessible. It was meant to be accessible only by the employees. It was meant to be accessible only by maybe the business users, and it can hold a lot of data there. Um, additionally, being able to access a whole new API, that brings additional sets of we abilities. You might be able to find other sets of variabilities specifically for this API that we don't have in the code currently, but it opens the door for new exploitation possibilities. So what we have here is that if we take a look at the remediation, to remediate this, we want to make sure that we are storing the secrets in environmental variables or use secrets manager like the AWS Secrets manager. So what's happening here in the suggested cofix preview? It's pretty straightforward. We are again similar to JWT importing the US module. Then we are removing the hard code API key right there. And then we are creating a new one and then safely pulling the value for the API key from the environment. This time, only the application itself and developers having access to the server and this environment variables would actually be able to see the API key value. Um, if we plan, for example, to, uh, push this code to the GitHub, if it's, for example, open source project or just meant to be used by others, the other developers have actually to configure their API key environmental variable or however they want to call it. And then they we are properly secure, right? But there is one thing here. What if the storing the values in the environment just simply doesn't work for me? What if the, uh, we can pretend that this is a lambda functionality? What if this is a docker container? Um, environment might not be just working for me and that's completely fine. We have additional approaches here in remediations. What you suggested, uh, is about, for example, using the secret manager like AWS Sets manager. And then let's say I did Googling, I did my research. I really like the idea of storing the values in Secrets manager works perfect for me. Business logic is there. Applic application logic is here. Everything is fine. But I'm hitting some roadblocks and uh obstacles when I try to implement it. I simply maybe do not understand or have time to implement it. It's completely fine. So. First of all, we are going to do is to see here just for a second how we can leverage the Amazon Q developer besides the review agent for our educational purposes as well, because not every time you're going to be familiar with the finding. There might be security vulnerability. You're not very familiar how to actually confirm it's a true policy when it comes to exploitation. There might be the way to, uh, you're not very familiar with the code performance issues as well. So you can go ahead and hit the explain which is going to. Shoot the content of our findings to the chat, and the queue is going to think about it and provide us in S for. This is great because we can learn more about the vulnerability and we are going to get very verbose output. So here we can see if I make this bigger, uh, we can see here that we are getting the uh CW reference to our finding that we are actually want more explanation. And we can see here that what is a CWE, uh, we have the issues in our code. We can see the security impact if we do not understand security impact, if it's a niche for ability or niche code performance finding, and then we can see recommend the fix. So we can see here that essentially it's pretty much the same what we saw before, but um. Now that the queue knows this context and it's very what I'm dealing with specifically the Um, the hard coded credentials for ability with a specific CW number. Uh, now I'm ready to go ahead and ask further questions here. For example, if I don't understand, I can, can you showcase me more details, simplify or give me some resources on the web I can take a look at it, or simply in our case here, uh, I can, uh, craft a prompt is something along the lines of, uh, can you help me? Integrate AWS secrets that should be lower key secrets manager. In order to Safely store value. Of our API key constant. And we can see here, um. That now the queue is going to think about it, it's going to generate a specific code for it, and it's going to integrate the uh AWS secret manager in our code in real time, uh, once we uh send the prompt here. We maybe just have to wait uh for some more time. Uh, but essentially here, uh, we can see that now I'm not only mitigating the vulnerability, but I'm also, uh, let's go ahead and try maybe the new window. I'm not only mitigating the vulnerability, but I'm also learning something new. So this way I'm combining the security and also different approaches, because something that works for me might not be working for you when it comes to the business perspective, when it comes to the application logic. So that's why it's important to have different approaches when it comes to fixing the vulnerability. And what's also really important to uh to mention to say there is no one fix for everything uh there are different approaches fixing the vulnerabilities of course when you have a package for ability there is one straightforward fix but when it comes to the uh fixing different vribilities, there is many different libraries, different approaches that might be working better for you so we can see here, um. Aa Markovich. That was a dizzy. He's a bad son. You're alive. I'm alive. So sounds like you've accomplished a third mission. What are we doing now? What I'm doing now is I'm trying to, uh, leverage AWSQ developer to help me to integrate Amazon, um, Secrets manager so I can properly secure the values of the API keys and other secrets in my code. So the way that, if the environment doesn't work for me for whatever reason, pulling the values from the environment, I have additional alternative here. So what I'm trying to do is I'm having some hard time um implementing the secrets manager. I do not understand how to do it fully and I want to leverage the tool to actually help me do so. You know it's really neat because with Amazon Q developer we actually released this new feature that is a new agentic chat interface so by turning and turning off this feature you can actually have the code be generated within your IDE to actually make changes to your. Code so as you're asking these questions, not only can you just ask and get responses, you can actually work back and forth with Amazon Q developer to be able to actually modify and change your code. So I'm glad to see that you already found this new feature. I hope you found it useful, absolutely so here. Once we turn it on, we can, uh, maybe we can ask the same prompt. Go ahead. Go ahead and try even maybe back here. You can just copy it now when we have the new prompt. When we have the feature turned off now the. Now the prompt should go ahead and be generating our code and modifying our code base to implement the AWS secrets manager, uh, to help us to store the values of the APE key properly. So we can see here then are working. We can see the director is being listed. If I expand this directory, we can see it's a book, uh bookfa directory or a folder of our application. And then we can go ahead and check in to see specific dependencies, because if you saw checking for requirements at the XT, and now we might be required to install furthermore, for example, B3 is what's needed as well. So we are changing requirements at TXT on the flight. Now we're also making changes to FAA to actually leverage the B3 to create new uh AWS Set manager client so we can actually communicate from our account and in the same time, uh, fixing the vulnerability but also fixing it the other way. So if we take a look here, if I could close the codicious panel, we can see here, um, that AAI changes are being applied. Now we can see. The code is being changed in real time. And then we are getting a new functionality, get Secret. We can see also nice comments of it retrieving the secrets from the AW secrets manager specifically we passed the region name, secret name that we want to retrieve and fetch. Um, now this is, of course, coming from the, uh, this can be also found in the AWS guided documentation, how to implement the secret manager. Now we are pulling the secret to get secret value. Uh, we're having some AFL block statements here or the exceptions to gracefully fall if something like this happens, if you're trying to retrieve the secret that simply does not exist. And then finally, um, we can just let you do its thing, um, finish with our code changes in real time. With the green line on the very left, we can also see what is being changed or added. And we can see here that um It's going to, if we take a look at the summary of what it did, we can see that first we install and updated the appendices because it's very important that we uh update requirements of XD accordingly, uh, or for example, appsOM XML I the are different dependencies. Now we are creating the secrets and Secrets manager, um, that we can change this, of course, accordingly as we wish, please. Uh, then we want to configure AWS credentials in order to accessWS environment, so we can also do that. We also have some tips here, for example, for the local development. Or the or the if if the secret manager is not available, we also have a backup plan uh to to to be able to fetch the secrets and ask uh access those credentials. And then finally we have the uh final benefits here. The secrets are no longer hardcoded. The secrets can be rotated without the code changes, which is very helpful. Access to secrets can be controlled using the IM policies, and finally we have the fall back to environment variable. in the edge cases when we simply cannot access Secrets manager, so rather than just getting a response or just like a you know one time thing, it's actually gonna give me the ability to chat back and forth with it as well. So as you go through Amazon Q developer, you can actually accomplish your your challenges and your missions but also get the context as to how you're accomplishing that. With that being said, Agent Markovich, guess what? Our mission has been accomplished. We have secured the book fault. We do still need to work on that secrets manager integration, but at the end of the day, we solved these four specific challenges today using AI powered tools. So while we thought this mission was impossible, it was pretty practical. And one of the things that we wanted to highlight was that some of the takeaways that we had with FINRA when doing this, uh, pilot that with Q Developer, um, is that they were able to actually test and go through and, you know, be able to see the power of QU developer and what it would do for them. Um, some of these numbers are actual results that we got from the pilot as they were going through, um, and they were able to actually work with us. Understand like OAS top 10 coverage to understand, you know, where are things going in the industry with Q Developer as we're continuing to update our tests and things with behind the scenes with Q Developer we're always continuing to have that continuous learning model so that you can see that the security vulnerabilities that exist in the world today or that are coming up are integrated into Qveloper. Um, with that, um, Markovich, we've accomplished the mission. Absolutely. You, you saw that even our application was pretty straightforward and very simple in scope. It does not guarantee it's a more ability free, especially we have some very serious and security flaws that we have there. So I'm very glad that he was able to find it. I was especially you agent, and we were able to, to mitigate those. Awesome. Well, thank you, agent. Hope you've been enlightened and that you're able to, you know, take those tools and learnings back with you. Thank you. Thank you.
